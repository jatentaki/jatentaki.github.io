{"version":3,"file":"main.js","mappings":"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","sources":["webpack://gaussian-splatting-web/./src/packing.ts","webpack://gaussian-splatting-web/./src/ply.ts","webpack://gaussian-splatting-web/./node_modules/wgpu-matrix/dist/2.x/wgpu-matrix.module.js","webpack://gaussian-splatting-web/./src/camera.ts","webpack://gaussian-splatting-web/./src/gpu_context.ts","webpack://gaussian-splatting-web/./src/bitonic.ts","webpack://gaussian-splatting-web/./src/depth_sorter.ts","webpack://gaussian-splatting-web/./src/renderer.ts","webpack://gaussian-splatting-web/./src/shaders.ts","webpack://gaussian-splatting-web/./src/index.ts"],"sourcesContent":["// This file contains the code for packing and unpacking data into webGPU buffers.\n// WebGPU buffers have rules about datatype layouts, padding etc, so it's much easier\n// to define a code which automatically generates the correct packing methods.\n// It is weakly typed and relies on runtime check, a proper solution would be with\n// extensive generics, but that's outside my comfort zone.\nfunction roundUp(n, multiple) {\n    return Math.ceil(n / multiple) * multiple;\n}\nclass PackingError extends Error {\n    constructor(message) {\n        super(message);\n        this.name = 'PackingError';\n    }\n}\nexport class PackingType {\n    constructor(size, alignment) {\n        this.size = size;\n        this.alignment = alignment;\n    }\n}\nclass i32Type extends PackingType {\n    constructor() { super(4, 4); }\n    pack(offset, value, view) {\n        if (typeof value !== 'number') {\n            throw new PackingError(`Expected number, got ${value}`);\n        }\n        view.setInt32(offset, value, true);\n        return offset + this.size;\n    }\n    unpack(offset, view) {\n        const content = view.getInt32(offset, true);\n        return [offset + this.size, content];\n    }\n}\nclass u32Type extends PackingType {\n    constructor() { super(4, 4); }\n    pack(offset, value, view) {\n        if (typeof value !== 'number') {\n            throw new PackingError(`Expected number, got ${value}`);\n        }\n        view.setUint32(offset, value, true);\n        return offset + this.size;\n    }\n    unpack(offset, view) {\n        const content = view.getUint32(offset, true);\n        return [offset + this.size, content];\n    }\n}\nclass f32Type extends PackingType {\n    constructor() { super(4, 4); }\n    pack(offset, value, view) {\n        if (typeof value !== 'number') {\n            throw new PackingError(`Expected number, got ${value}`);\n        }\n        view.setFloat32(offset, value, true);\n        return offset + this.size;\n    }\n    unpack(offset, view) {\n        const content = view.getFloat32(offset, true);\n        return [offset + this.size, content];\n    }\n}\nexport const i32 = new i32Type();\nexport const u32 = new u32Type();\nexport const f32 = new f32Type();\nclass VectorType extends PackingType {\n    constructor(baseType, nValues, alignment) {\n        super(baseType.size * nValues, alignment);\n        this.baseType = baseType;\n        this.nValues = nValues;\n    }\n    pack(offset, values, view) {\n        if (!Array.isArray(values)) {\n            throw new PackingError(`Expected array, got ${values}`);\n        }\n        if (values.length !== this.nValues) {\n            throw new PackingError(`Expected ${this.nValues} values, got ${values.length}`);\n        }\n        while (offset % this.alignment !== 0) {\n            offset++;\n        }\n        for (let i = 0; i < values.length; i++) {\n            try {\n                offset = this.baseType.pack(offset, values[i], view);\n            }\n            catch (e) {\n                if (e instanceof PackingError) {\n                    throw new PackingError(`Error packing value ${i}: ${e.message}`);\n                }\n                else {\n                    throw e;\n                }\n            }\n            ;\n        }\n        return offset;\n    }\n    unpack(offset, view) {\n        const values = [];\n        while (offset % this.alignment !== 0) {\n            offset++;\n        }\n        for (let i = 0; i < this.nValues; i++) {\n            let [newOffset, value] = this.baseType.unpack(offset, view);\n            offset = newOffset;\n            values.push(value);\n        }\n        return [offset, values];\n    }\n}\nexport class vec2 extends VectorType {\n    constructor(baseType) { super(baseType, 2, 8); }\n}\nexport class vec3 extends VectorType {\n    constructor(baseType) { super(baseType, 3, 16); }\n}\nexport class vec4 extends VectorType {\n    constructor(baseType) { super(baseType, 4, 16); }\n}\nexport class Struct extends PackingType {\n    constructor(members) {\n        const alignment = Math.max(...members.map(([_name, type]) => type.alignment));\n        let offset = 0;\n        for (const [_, type] of members) {\n            while (offset % type.alignment !== 0) {\n                offset++;\n            }\n            offset += type.size;\n        }\n        // SizeOf(S) = roundUp(AlignOf(S), justPastLastMember)\n        // where justPastLastMember = OffsetOfMember(S,N) + SizeOfMember(S,N)\n        const size = roundUp(offset, alignment);\n        super(size, alignment);\n        this.members = members;\n    }\n    pack(offset, values, view) {\n        const expectedKeys = this.members.map(([name, _type]) => name);\n        const actualKeys = Object.keys(values);\n        if (expectedKeys.length !== actualKeys.length) {\n            throw new PackingError(`Expected values for ${expectedKeys}, got ${actualKeys}`);\n        }\n        if (!expectedKeys.every((key) => actualKeys.includes(key))) {\n            throw new PackingError(`Expected values for ${expectedKeys}, got ${actualKeys}`);\n        }\n        const startingOffset = offset;\n        while (offset % this.alignment !== 0) {\n            offset++;\n        }\n        for (const [name, type] of this.members) {\n            const value = values[name];\n            try {\n                offset = type.pack(offset, value, view);\n            }\n            catch (e) {\n                // error packing the thing inside\n                if (e instanceof PackingError) {\n                    throw new PackingError(`Error packing value ${name}: ${e.message}`);\n                }\n                else {\n                    throw e;\n                }\n            }\n        }\n        offset += this.size - (offset - startingOffset);\n        return offset;\n    }\n    unpack(offset, view) {\n        const values = {};\n        const startingOffset = offset;\n        while (offset % this.alignment !== 0) {\n            offset++;\n        }\n        for (const [name, type] of this.members) {\n            let [newOffset, value] = type.unpack(offset, view);\n            offset = newOffset;\n            values[name] = value;\n        }\n        offset += this.size - (offset - startingOffset);\n        return [offset, values];\n    }\n}\nexport class StaticArray extends PackingType {\n    constructor(type, nElements) {\n        const alignment = type.alignment;\n        const size = nElements * roundUp(type.size, type.alignment);\n        super(size, alignment);\n        this.type = type;\n        this.nElements = nElements;\n        this.stride = roundUp(type.size, type.alignment);\n    }\n    pack(offset, values, view) {\n        if (!Array.isArray(values)) {\n            throw new PackingError(`Expected array, got ${values}`);\n        }\n        if (values.length !== this.nElements) {\n            throw new PackingError(`Expected ${this.nElements} values, got ${values.length}`);\n        }\n        while (offset % this.alignment !== 0) {\n            offset++;\n        }\n        for (let i = 0; i < values.length; i++) {\n            try {\n                offset = this.type.pack(offset, values[i], view);\n            }\n            catch (e) {\n                if (e instanceof PackingError) {\n                    throw new PackingError(`Error packing value ${i}: ${e.message}`);\n                }\n                else {\n                    throw e;\n                }\n            }\n            offset += this.stride - this.type.size;\n        }\n        return offset;\n    }\n    unpack(offset, view) {\n        const values = [];\n        while (offset % this.alignment !== 0) {\n            offset++;\n        }\n        for (let i = 0; i < this.nElements; i++) {\n            let [newOffset, value] = this.type.unpack(offset, view);\n            offset = newOffset;\n            values.push(value);\n            offset += this.stride - this.type.size;\n        }\n        return [offset, values];\n    }\n}\nclass MatrixType extends PackingType {\n    constructor(baseType, nRows, nColumns) {\n        var vecType;\n        if (nRows === 2) {\n            vecType = new vec2(baseType);\n        }\n        else if (nRows === 3) {\n            vecType = new vec3(baseType);\n        }\n        else if (nRows === 4) {\n            vecType = new vec4(baseType);\n        }\n        else {\n            throw new Error(`Invalid number of rows: ${nRows}`);\n        }\n        const arrayType = new StaticArray(vecType, nColumns);\n        super(arrayType.size, vecType.alignment);\n        this.baseType = baseType;\n        this.nRows = nRows;\n        this.nColumns = nColumns;\n    }\n    pack(offset, values, view) {\n        if (!Array.isArray(values)) {\n            throw new PackingError(`Expected array, got ${values}`);\n        }\n        if (values.length !== this.nColumns) {\n            throw new PackingError(`Expected ${this.nColumns} columns, got ${values.length}`);\n        }\n        while (offset % this.alignment !== 0) {\n            offset++;\n        }\n        const startOffset = offset;\n        for (let i = 0; i < values.length; i++) {\n            if (!Array.isArray(values[i])) {\n                throw new PackingError(`Expected array, got ${values[i]}`);\n            }\n            for (let j = 0; j < values[i].length; j++) {\n                try {\n                    offset = this.baseType.pack(offset, values[i][j], view);\n                }\n                catch (e) {\n                    if (e instanceof PackingError) {\n                        throw new PackingError(`Error packing value ${i},${j}: ${e.message}`);\n                    }\n                    else {\n                        throw e;\n                    }\n                }\n            }\n        }\n        offset = startOffset + this.size;\n        return offset;\n    }\n    unpack(offset, view) {\n        while (offset % this.alignment !== 0) {\n            offset++;\n        }\n        const startOffset = offset;\n        const outerValues = [];\n        for (let i = 0; i < this.nColumns; i++) {\n            const innerValues = [];\n            for (let j = 0; j < this.nRows; j++) {\n                let [newOffset, value] = this.baseType.unpack(offset, view);\n                offset = newOffset;\n                innerValues.push(value);\n            }\n            outerValues.push(innerValues);\n        }\n        offset += this.size - (offset - startOffset);\n        return [offset, outerValues];\n    }\n}\nexport class mat4x4 extends MatrixType {\n    constructor(baseType) { super(baseType, 4, 4); }\n}\n","import { StaticArray, Struct, vec3, vec4, f32 } from \"./packing\";\nexport function loadFileAsArrayBuffer(file) {\n    /* loads a file as an ArrayBuffer (i.e. a binary blob) */\n    return new Promise((resolve, reject) => {\n        const reader = new FileReader();\n        reader.onload = (event) => {\n            if (!event.target || !event.target.result) {\n                reject('Failed to load file');\n                return;\n            }\n            if (typeof event.target.result === 'string') {\n                reject('Got a text file instead of a binary one');\n                return;\n            }\n            resolve(event.target.result);\n        };\n        reader.onerror = (event) => {\n            if (!event.target) {\n                reject('Failed to load file');\n                return;\n            }\n            reject(event.target.error);\n        };\n        reader.readAsArrayBuffer(file);\n    });\n}\nexport class PackedGaussians {\n    static decodeHeader(plyArrayBuffer) {\n        /* decodes the .ply file header and returns a tuple of:\n            * - vertexCount: number of vertices in the point cloud\n            * - propertyTypes: a map from property names to their types\n            * - vertexData: a DataView of the vertex data\n        */\n        const decoder = new TextDecoder();\n        let headerOffset = 0;\n        let headerText = '';\n        while (true) {\n            const headerChunk = new Uint8Array(plyArrayBuffer, headerOffset, 50);\n            headerText += decoder.decode(headerChunk);\n            headerOffset += 50;\n            if (headerText.includes('end_header')) {\n                break;\n            }\n        }\n        const headerLines = headerText.split('\\n');\n        let vertexCount = 0;\n        let propertyTypes = {};\n        for (let i = 0; i < headerLines.length; i++) {\n            const line = headerLines[i].trim();\n            if (line.startsWith('element vertex')) {\n                const vertexCountMatch = line.match(/\\d+/);\n                if (vertexCountMatch) {\n                    vertexCount = parseInt(vertexCountMatch[0]);\n                }\n            }\n            else if (line.startsWith('property')) {\n                const propertyMatch = line.match(/(\\w+)\\s+(\\w+)\\s+(\\w+)/);\n                if (propertyMatch) {\n                    const propertyType = propertyMatch[2];\n                    const propertyName = propertyMatch[3];\n                    propertyTypes[propertyName] = propertyType;\n                }\n            }\n            else if (line === 'end_header') {\n                break;\n            }\n        }\n        const vertexByteOffset = headerText.indexOf('end_header') + 'end_header'.length + 1;\n        const vertexData = new DataView(plyArrayBuffer, vertexByteOffset);\n        return [\n            vertexCount,\n            propertyTypes,\n            vertexData,\n        ];\n    }\n    readRawVertex(offset, vertexData, propertyTypes) {\n        /* reads a single vertex from the vertexData DataView and returns a tuple of:\n            * - offset: the offset of the next vertex in the vertexData DataView\n            * - rawVertex: a map from property names to their values\n        */\n        let rawVertex = {};\n        for (const property in propertyTypes) {\n            const propertyType = propertyTypes[property];\n            if (propertyType === 'float') {\n                rawVertex[property] = vertexData.getFloat32(offset, true);\n                offset += Float32Array.BYTES_PER_ELEMENT;\n            }\n            else if (propertyType === 'uchar') {\n                rawVertex[property] = vertexData.getUint8(offset) / 255.0;\n                offset += Uint8Array.BYTES_PER_ELEMENT;\n            }\n        }\n        return [offset, rawVertex];\n    }\n    get nShCoeffs() {\n        /* returns the expected number of spherical harmonics coefficients */\n        if (this.sphericalHarmonicsDegree === 0) {\n            return 1;\n        }\n        else if (this.sphericalHarmonicsDegree === 1) {\n            return 4;\n        }\n        else if (this.sphericalHarmonicsDegree === 2) {\n            return 9;\n        }\n        else if (this.sphericalHarmonicsDegree === 3) {\n            return 16;\n        }\n        else {\n            throw new Error(`Unsupported SH degree: ${this.sphericalHarmonicsDegree}`);\n        }\n    }\n    arrangeVertex(rawVertex, shFeatureOrder) {\n        /* arranges a raw vertex into a vertex that can be packed by the gaussianLayout utility */\n        const shCoeffs = [];\n        for (let i = 0; i < this.nShCoeffs; ++i) {\n            const coeff = [];\n            for (let j = 0; j < 3; ++j) {\n                const coeffName = shFeatureOrder[i * 3 + j];\n                coeff.push(rawVertex[coeffName]);\n            }\n            shCoeffs.push(coeff);\n        }\n        const arrangedVertex = {\n            position: [rawVertex.x, rawVertex.y, rawVertex.z],\n            logScale: [rawVertex.scale_0, rawVertex.scale_1, rawVertex.scale_2],\n            rotQuat: [rawVertex.rot_0, rawVertex.rot_1, rawVertex.rot_2, rawVertex.rot_3],\n            opacityLogit: rawVertex.opacity,\n            shCoeffs: shCoeffs,\n        };\n        return arrangedVertex;\n    }\n    constructor(arrayBuffer) {\n        // decode the header\n        const [vertexCount, propertyTypes, vertexData] = PackedGaussians.decodeHeader(arrayBuffer);\n        this.numGaussians = vertexCount;\n        // figure out the SH degree from the number of coefficients\n        var nRestCoeffs = 0;\n        for (const propertyName in propertyTypes) {\n            if (propertyName.startsWith('f_rest_')) {\n                nRestCoeffs += 1;\n            }\n        }\n        const nCoeffsPerColor = nRestCoeffs / 3;\n        this.sphericalHarmonicsDegree = Math.sqrt(nCoeffsPerColor + 1) - 1;\n        console.log('Detected degree', this.sphericalHarmonicsDegree, 'with ', nCoeffsPerColor, 'coefficients per color');\n        // figure out the order in which spherical harmonics should be read\n        const shFeatureOrder = [];\n        for (let rgb = 0; rgb < 3; ++rgb) {\n            shFeatureOrder.push(`f_dc_${rgb}`);\n        }\n        for (let i = 0; i < nCoeffsPerColor; ++i) {\n            for (let rgb = 0; rgb < 3; ++rgb) {\n                shFeatureOrder.push(`f_rest_${rgb * nCoeffsPerColor + i}`);\n            }\n        }\n        // define the layout of a single point\n        this.gaussianLayout = new Struct([\n            ['position', new vec3(f32)],\n            ['logScale', new vec3(f32)],\n            ['rotQuat', new vec4(f32)],\n            ['opacityLogit', f32],\n            ['shCoeffs', new StaticArray(new vec3(f32), this.nShCoeffs)],\n        ]);\n        // define the layout of the entire point cloud\n        this.gaussianArrayLayout = new StaticArray(this.gaussianLayout, vertexCount);\n        this.positionsLayout = new vec3(f32);\n        this.positionsArrayLayout = new StaticArray(this.positionsLayout, vertexCount);\n        // pack the points\n        this.gaussiansBuffer = new ArrayBuffer(this.gaussianArrayLayout.size);\n        const gaussianWriteView = new DataView(this.gaussiansBuffer);\n        this.positionsBuffer = new ArrayBuffer(this.positionsArrayLayout.size);\n        const positionsWriteView = new DataView(this.positionsBuffer);\n        var readOffset = 0;\n        var gaussianWriteOffset = 0;\n        var positionWriteOffset = 0;\n        for (let i = 0; i < vertexCount; i++) {\n            const [newReadOffset, rawVertex] = this.readRawVertex(readOffset, vertexData, propertyTypes);\n            readOffset = newReadOffset;\n            gaussianWriteOffset = this.gaussianLayout.pack(gaussianWriteOffset, this.arrangeVertex(rawVertex, shFeatureOrder), gaussianWriteView);\n            positionWriteOffset = this.positionsLayout.pack(positionWriteOffset, [rawVertex.x, rawVertex.y, rawVertex.z], positionsWriteView);\n        }\n    }\n}\n","/* wgpu-matrix@2.5.0, license MIT */\n/*\n * Copyright 2022 Gregg Tavares\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL\n * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\nlet EPSILON = 0.000001;\n/**\n * Set the value for EPSILON for various checks\n * @param v - Value to use for EPSILON.\n * @returns previous value of EPSILON;\n */\nfunction setEpsilon(v) {\n    const old = EPSILON;\n    EPSILON = v;\n    return old;\n}\n/**\n * Convert degrees to radians\n * @param degrees - Angle in degrees\n * @returns angle converted to radians\n */\nfunction degToRad(degrees) {\n    return degrees * Math.PI / 180;\n}\n/**\n * Convert radians to degrees\n * @param radians - Angle in radians\n * @returns angle converted to degrees\n */\nfunction radToDeg(radians) {\n    return radians * 180 / Math.PI;\n}\n/**\n * Lerps between a and b via t\n * @param a - starting value\n * @param b - ending value\n * @param t - value where 0 = a and 1 = b\n * @returns a + (b - a) * t\n */\nfunction lerp$4(a, b, t) {\n    return a + (b - a) * t;\n}\n/**\n * Compute the opposite of lerp. Given a and b and a value between\n * a and b returns a value between 0 and 1. 0 if a, 1 if b.\n * Note: no clamping is done.\n * @param a - start value\n * @param b - end value\n * @param v - value between a and b\n * @returns (v - a) / (b - a)\n */\nfunction inverseLerp(a, b, v) {\n    const d = b - a;\n    return (Math.abs(b - a) < EPSILON)\n        ? a\n        : (v - a) / d;\n}\n/**\n * Compute the euclidean modulo\n *\n * ```\n * // table for n / 3\n * -5, -4, -3, -2, -1,  0,  1,  2,  3,  4,  5   <- n\n * ------------------------------------\n * -2  -1  -0  -2  -1   0,  1,  2,  0,  1,  2   <- n % 3\n *  1   2   0   1   2   0,  1,  2,  0,  1,  2   <- euclideanModule(n, 3)\n * ```\n *\n * @param n - dividend\n * @param m - divisor\n * @returns the euclidean modulo of n / m\n */\nfunction euclideanModulo(n, m) {\n    return ((n % m) + m) % m;\n}\n\nvar utils = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    get EPSILON () { return EPSILON; },\n    setEpsilon: setEpsilon,\n    degToRad: degToRad,\n    radToDeg: radToDeg,\n    lerp: lerp$4,\n    inverseLerp: inverseLerp,\n    euclideanModulo: euclideanModulo\n});\n\n/*\n * Copyright 2022 Gregg Tavares\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL\n * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n/**\n *\n * Vec2 math functions.\n *\n * Almost all functions take an optional `dst` argument. If it is not passed in the\n * functions will create a new Vec2. In other words you can do this\n *\n *     const v = vec2.cross(v1, v2);  // Creates a new Vec2 with the cross product of v1 x v2.\n *\n * or\n *\n *     const v = vec2.create();\n *     vec2.cross(v1, v2, v);  // Puts the cross product of v1 x v2 in v\n *\n * The first style is often easier but depending on where it's used it generates garbage where\n * as there is almost never allocation with the second style.\n *\n * It is always safe to pass any vector as the destination. So for example\n *\n *     vec2.cross(v1, v2, v1);  // Puts the cross product of v1 x v2 in v1\n *\n */\nlet VecType$2 = Float32Array;\n/**\n * Sets the type this library creates for a Vec2\n * @param ctor - the constructor for the type. Either `Float32Array`, `Float64Array`, or `Array`\n * @returns previous constructor for Vec2\n */\nfunction setDefaultType$6(ctor) {\n    const oldType = VecType$2;\n    VecType$2 = ctor;\n    return oldType;\n}\n/**\n * Creates a Vec2; may be called with x, y, z to set initial values.\n *\n * Note: Since passing in a raw JavaScript array\n * is valid in all circumstances, if you want to\n * force a JavaScript array into a Vec2's specified type\n * it would be faster to use\n *\n * ```\n * const v = vec2.clone(someJSArray);\n * ```\n *\n * Note: a consequence of the implementation is if your Vec2Type = `Array`\n * instead of `Float32Array` or `Float64Array` then any values you\n * don't pass in will be undefined. Usually this is not an issue since\n * (a) using `Array` is rare and (b) using `vec2.create` is usually used\n * to create a Vec2 to be filled out as in\n *\n * ```\n * const sum = vec2.create();\n * vec2.add(v1, v2, sum);\n * ```\n *\n * @param x - Initial x value.\n * @param y - Initial y value.\n * @returns the created vector\n */\nfunction create$5(x = 0, y = 0) {\n    const dst = new VecType$2(2);\n    if (x !== undefined) {\n        dst[0] = x;\n        if (y !== undefined) {\n            dst[1] = y;\n        }\n    }\n    return dst;\n}\n\n/*\n * Copyright 2022 Gregg Tavares\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL\n * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n/**\n * Creates a Vec2; may be called with x, y, z to set initial values. (same as create)\n * @param x - Initial x value.\n * @param y - Initial y value.\n * @returns the created vector\n */\nconst fromValues$3 = create$5;\n/**\n * Sets the values of a Vec2\n * Also see {@link vec2.create} and {@link vec2.copy}\n *\n * @param x first value\n * @param y second value\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns A vector with its elements set.\n */\nfunction set$5(x, y, dst) {\n    dst = dst || new VecType$2(2);\n    dst[0] = x;\n    dst[1] = y;\n    return dst;\n}\n/**\n * Applies Math.ceil to each element of vector\n * @param v - Operand vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns A vector that is the ceil of each element of v.\n */\nfunction ceil$2(v, dst) {\n    dst = dst || new VecType$2(2);\n    dst[0] = Math.ceil(v[0]);\n    dst[1] = Math.ceil(v[1]);\n    return dst;\n}\n/**\n * Applies Math.floor to each element of vector\n * @param v - Operand vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns A vector that is the floor of each element of v.\n */\nfunction floor$2(v, dst) {\n    dst = dst || new VecType$2(2);\n    dst[0] = Math.floor(v[0]);\n    dst[1] = Math.floor(v[1]);\n    return dst;\n}\n/**\n * Applies Math.round to each element of vector\n * @param v - Operand vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns A vector that is the round of each element of v.\n */\nfunction round$2(v, dst) {\n    dst = dst || new VecType$2(2);\n    dst[0] = Math.round(v[0]);\n    dst[1] = Math.round(v[1]);\n    return dst;\n}\n/**\n * Clamp each element of vector between min and max\n * @param v - Operand vector.\n * @param max - Min value, default 0\n * @param min - Max value, default 1\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns A vector that the clamped value of each element of v.\n */\nfunction clamp$2(v, min = 0, max = 1, dst) {\n    dst = dst || new VecType$2(2);\n    dst[0] = Math.min(max, Math.max(min, v[0]));\n    dst[1] = Math.min(max, Math.max(min, v[1]));\n    return dst;\n}\n/**\n * Adds two vectors; assumes a and b have the same dimension.\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns A vector that is the sum of a and b.\n */\nfunction add$3(a, b, dst) {\n    dst = dst || new VecType$2(2);\n    dst[0] = a[0] + b[0];\n    dst[1] = a[1] + b[1];\n    return dst;\n}\n/**\n * Adds two vectors, scaling the 2nd; assumes a and b have the same dimension.\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @param scale - Amount to scale b\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns A vector that is the sum of a + b * scale.\n */\nfunction addScaled$2(a, b, scale, dst) {\n    dst = dst || new VecType$2(2);\n    dst[0] = a[0] + b[0] * scale;\n    dst[1] = a[1] + b[1] * scale;\n    return dst;\n}\n/**\n * Returns the angle in radians between two vectors.\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @returns The angle in radians between the 2 vectors.\n */\nfunction angle$2(a, b) {\n    const ax = a[0];\n    const ay = a[1];\n    const bx = a[0];\n    const by = a[1];\n    const mag1 = Math.sqrt(ax * ax + ay * ay);\n    const mag2 = Math.sqrt(bx * bx + by * by);\n    const mag = mag1 * mag2;\n    const cosine = mag && dot$3(a, b) / mag;\n    return Math.acos(cosine);\n}\n/**\n * Subtracts two vectors.\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns A vector that is the difference of a and b.\n */\nfunction subtract$3(a, b, dst) {\n    dst = dst || new VecType$2(2);\n    dst[0] = a[0] - b[0];\n    dst[1] = a[1] - b[1];\n    return dst;\n}\n/**\n * Subtracts two vectors.\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns A vector that is the difference of a and b.\n */\nconst sub$3 = subtract$3;\n/**\n * Check if 2 vectors are approximately equal\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @returns true if vectors are approximately equal\n */\nfunction equalsApproximately$5(a, b) {\n    return Math.abs(a[0] - b[0]) < EPSILON &&\n        Math.abs(a[1] - b[1]) < EPSILON;\n}\n/**\n * Check if 2 vectors are exactly equal\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @returns true if vectors are exactly equal\n */\nfunction equals$5(a, b) {\n    return a[0] === b[0] && a[1] === b[1];\n}\n/**\n * Performs linear interpolation on two vectors.\n * Given vectors a and b and interpolation coefficient t, returns\n * a + t * (b - a).\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @param t - Interpolation coefficient.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns The linear interpolated result.\n */\nfunction lerp$3(a, b, t, dst) {\n    dst = dst || new VecType$2(2);\n    dst[0] = a[0] + t * (b[0] - a[0]);\n    dst[1] = a[1] + t * (b[1] - a[1]);\n    return dst;\n}\n/**\n * Performs linear interpolation on two vectors.\n * Given vectors a and b and interpolation coefficient vector t, returns\n * a + t * (b - a).\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @param t - Interpolation coefficients vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns the linear interpolated result.\n */\nfunction lerpV$2(a, b, t, dst) {\n    dst = dst || new VecType$2(2);\n    dst[0] = a[0] + t[0] * (b[0] - a[0]);\n    dst[1] = a[1] + t[1] * (b[1] - a[1]);\n    return dst;\n}\n/**\n * Return max values of two vectors.\n * Given vectors a and b returns\n * [max(a[0], b[0]), max(a[1], b[1]), max(a[2], b[2])].\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns The max components vector.\n */\nfunction max$2(a, b, dst) {\n    dst = dst || new VecType$2(2);\n    dst[0] = Math.max(a[0], b[0]);\n    dst[1] = Math.max(a[1], b[1]);\n    return dst;\n}\n/**\n * Return min values of two vectors.\n * Given vectors a and b returns\n * [min(a[0], b[0]), min(a[1], b[1]), min(a[2], b[2])].\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns The min components vector.\n */\nfunction min$2(a, b, dst) {\n    dst = dst || new VecType$2(2);\n    dst[0] = Math.min(a[0], b[0]);\n    dst[1] = Math.min(a[1], b[1]);\n    return dst;\n}\n/**\n * Multiplies a vector by a scalar.\n * @param v - The vector.\n * @param k - The scalar.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns The scaled vector.\n */\nfunction mulScalar$3(v, k, dst) {\n    dst = dst || new VecType$2(2);\n    dst[0] = v[0] * k;\n    dst[1] = v[1] * k;\n    return dst;\n}\n/**\n * Multiplies a vector by a scalar. (same as mulScalar)\n * @param v - The vector.\n * @param k - The scalar.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns The scaled vector.\n */\nconst scale$5 = mulScalar$3;\n/**\n * Divides a vector by a scalar.\n * @param v - The vector.\n * @param k - The scalar.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns The scaled vector.\n */\nfunction divScalar$3(v, k, dst) {\n    dst = dst || new VecType$2(2);\n    dst[0] = v[0] / k;\n    dst[1] = v[1] / k;\n    return dst;\n}\n/**\n * Inverse a vector.\n * @param v - The vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns The inverted vector.\n */\nfunction inverse$5(v, dst) {\n    dst = dst || new VecType$2(2);\n    dst[0] = 1 / v[0];\n    dst[1] = 1 / v[1];\n    return dst;\n}\n/**\n * Invert a vector. (same as inverse)\n * @param v - The vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns The inverted vector.\n */\nconst invert$4 = inverse$5;\n/**\n * Computes the cross product of two vectors; assumes both vectors have\n * three entries.\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns The vector of a cross b.\n */\nfunction cross$1(a, b, dst) {\n    dst = dst || new VecType$2(3);\n    const z = a[0] * b[1] - a[1] * b[0];\n    dst[0] = 0;\n    dst[1] = 0;\n    dst[2] = z;\n    return dst;\n}\n/**\n * Computes the dot product of two vectors; assumes both vectors have\n * three entries.\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @returns dot product\n */\nfunction dot$3(a, b) {\n    return a[0] * b[0] + a[1] * b[1];\n}\n/**\n * Computes the length of vector\n * @param v - vector.\n * @returns length of vector.\n */\nfunction length$3(v) {\n    const v0 = v[0];\n    const v1 = v[1];\n    return Math.sqrt(v0 * v0 + v1 * v1);\n}\n/**\n * Computes the length of vector (same as length)\n * @param v - vector.\n * @returns length of vector.\n */\nconst len$3 = length$3;\n/**\n * Computes the square of the length of vector\n * @param v - vector.\n * @returns square of the length of vector.\n */\nfunction lengthSq$3(v) {\n    const v0 = v[0];\n    const v1 = v[1];\n    return v0 * v0 + v1 * v1;\n}\n/**\n * Computes the square of the length of vector (same as lengthSq)\n * @param v - vector.\n * @returns square of the length of vector.\n */\nconst lenSq$3 = lengthSq$3;\n/**\n * Computes the distance between 2 points\n * @param a - vector.\n * @param b - vector.\n * @returns distance between a and b\n */\nfunction distance$2(a, b) {\n    const dx = a[0] - b[0];\n    const dy = a[1] - b[1];\n    return Math.sqrt(dx * dx + dy * dy);\n}\n/**\n * Computes the distance between 2 points (same as distance)\n * @param a - vector.\n * @param b - vector.\n * @returns distance between a and b\n */\nconst dist$2 = distance$2;\n/**\n * Computes the square of the distance between 2 points\n * @param a - vector.\n * @param b - vector.\n * @returns square of the distance between a and b\n */\nfunction distanceSq$2(a, b) {\n    const dx = a[0] - b[0];\n    const dy = a[1] - b[1];\n    return dx * dx + dy * dy;\n}\n/**\n * Computes the square of the distance between 2 points (same as distanceSq)\n * @param a - vector.\n * @param b - vector.\n * @returns square of the distance between a and b\n */\nconst distSq$2 = distanceSq$2;\n/**\n * Divides a vector by its Euclidean length and returns the quotient.\n * @param v - The vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns The normalized vector.\n */\nfunction normalize$3(v, dst) {\n    dst = dst || new VecType$2(2);\n    const v0 = v[0];\n    const v1 = v[1];\n    const len = Math.sqrt(v0 * v0 + v1 * v1);\n    if (len > 0.00001) {\n        dst[0] = v0 / len;\n        dst[1] = v1 / len;\n    }\n    else {\n        dst[0] = 0;\n        dst[1] = 0;\n    }\n    return dst;\n}\n/**\n * Negates a vector.\n * @param v - The vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns -v.\n */\nfunction negate$4(v, dst) {\n    dst = dst || new VecType$2(2);\n    dst[0] = -v[0];\n    dst[1] = -v[1];\n    return dst;\n}\n/**\n * Copies a vector. (same as {@link vec2.clone})\n * Also see {@link vec2.create} and {@link vec2.set}\n * @param v - The vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns A copy of v.\n */\nfunction copy$5(v, dst) {\n    dst = dst || new VecType$2(2);\n    dst[0] = v[0];\n    dst[1] = v[1];\n    return dst;\n}\n/**\n * Clones a vector. (same as {@link vec2.copy})\n * Also see {@link vec2.create} and {@link vec2.set}\n * @param v - The vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns A copy of v.\n */\nconst clone$5 = copy$5;\n/**\n * Multiplies a vector by another vector (component-wise); assumes a and\n * b have the same length.\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns The vector of products of entries of a and b.\n */\nfunction multiply$5(a, b, dst) {\n    dst = dst || new VecType$2(2);\n    dst[0] = a[0] * b[0];\n    dst[1] = a[1] * b[1];\n    return dst;\n}\n/**\n * Multiplies a vector by another vector (component-wise); assumes a and\n * b have the same length. (same as mul)\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns The vector of products of entries of a and b.\n */\nconst mul$5 = multiply$5;\n/**\n * Divides a vector by another vector (component-wise); assumes a and\n * b have the same length.\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns The vector of quotients of entries of a and b.\n */\nfunction divide$2(a, b, dst) {\n    dst = dst || new VecType$2(2);\n    dst[0] = a[0] / b[0];\n    dst[1] = a[1] / b[1];\n    return dst;\n}\n/**\n * Divides a vector by another vector (component-wise); assumes a and\n * b have the same length. (same as divide)\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns The vector of quotients of entries of a and b.\n */\nconst div$2 = divide$2;\n/**\n * Creates a random unit vector * scale\n * @param scale - Default 1\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns The random vector.\n */\nfunction random$1(scale = 1, dst) {\n    dst = dst || new VecType$2(2);\n    const angle = Math.random() * 2 * Math.PI;\n    dst[0] = Math.cos(angle) * scale;\n    dst[1] = Math.sin(angle) * scale;\n    return dst;\n}\n/**\n * Zero's a vector\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns The zeroed vector.\n */\nfunction zero$2(dst) {\n    dst = dst || new VecType$2(2);\n    dst[0] = 0;\n    dst[1] = 0;\n    return dst;\n}\n/**\n * transform Vec2 by 4x4 matrix\n * @param v - the vector\n * @param m - The matrix.\n * @param dst - optional Vec2 to store result. If not passed a new one is created.\n * @returns the transformed vector\n */\nfunction transformMat4$2(v, m, dst) {\n    dst = dst || new VecType$2(2);\n    const x = v[0];\n    const y = v[1];\n    dst[0] = x * m[0] + y * m[4] + m[12];\n    dst[1] = x * m[1] + y * m[5] + m[13];\n    return dst;\n}\n/**\n * Transforms vec4 by 3x3 matrix\n *\n * @param v - the vector\n * @param m - The matrix.\n * @param dst - optional Vec2 to store result. If not passed a new one is created.\n * @returns the transformed vector\n */\nfunction transformMat3$1(v, m, dst) {\n    dst = dst || new VecType$2(2);\n    const x = v[0];\n    const y = v[1];\n    dst[0] = m[0] * x + m[4] * y + m[8];\n    dst[1] = m[1] * x + m[5] * y + m[9];\n    return dst;\n}\n\nvar vec2Impl = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    create: create$5,\n    setDefaultType: setDefaultType$6,\n    fromValues: fromValues$3,\n    set: set$5,\n    ceil: ceil$2,\n    floor: floor$2,\n    round: round$2,\n    clamp: clamp$2,\n    add: add$3,\n    addScaled: addScaled$2,\n    angle: angle$2,\n    subtract: subtract$3,\n    sub: sub$3,\n    equalsApproximately: equalsApproximately$5,\n    equals: equals$5,\n    lerp: lerp$3,\n    lerpV: lerpV$2,\n    max: max$2,\n    min: min$2,\n    mulScalar: mulScalar$3,\n    scale: scale$5,\n    divScalar: divScalar$3,\n    inverse: inverse$5,\n    invert: invert$4,\n    cross: cross$1,\n    dot: dot$3,\n    length: length$3,\n    len: len$3,\n    lengthSq: lengthSq$3,\n    lenSq: lenSq$3,\n    distance: distance$2,\n    dist: dist$2,\n    distanceSq: distanceSq$2,\n    distSq: distSq$2,\n    normalize: normalize$3,\n    negate: negate$4,\n    copy: copy$5,\n    clone: clone$5,\n    multiply: multiply$5,\n    mul: mul$5,\n    divide: divide$2,\n    div: div$2,\n    random: random$1,\n    zero: zero$2,\n    transformMat4: transformMat4$2,\n    transformMat3: transformMat3$1\n});\n\n/*\n * Copyright 2022 Gregg Tavares\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL\n * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n/**\n * 3x3 Matrix math math functions.\n *\n * Almost all functions take an optional `dst` argument. If it is not passed in the\n * functions will create a new matrix. In other words you can do this\n *\n *     const mat = mat3.translation([1, 2, 3]);  // Creates a new translation matrix\n *\n * or\n *\n *     const mat = mat3.create();\n *     mat3.translation([1, 2, 3], mat);  // Puts translation matrix in mat.\n *\n * The first style is often easier but depending on where it's used it generates garbage where\n * as there is almost never allocation with the second style.\n *\n * It is always save to pass any matrix as the destination. So for example\n *\n *     const mat = mat3.identity();\n *     const trans = mat3.translation([1, 2, 3]);\n *     mat3.multiply(mat, trans, mat);  // Multiplies mat * trans and puts result in mat.\n *\n */\nlet MatType$1 = Float32Array;\n// This mess is because with Mat3 we have 3 unused elements.\n// For Float32Array and Float64Array that's not an issue\n// but for Array it's troublesome\nconst ctorMap = new Map([\n    [Float32Array, () => new Float32Array(12)],\n    [Float64Array, () => new Float64Array(12)],\n    [Array, () => new Array(12).fill(0)],\n]);\nlet newMat3 = ctorMap.get(Float32Array);\n/**\n * Sets the type this library creates for a Mat3\n * @param ctor - the constructor for the type. Either `Float32Array`, `Float64Array`, or `Array`\n * @returns previous constructor for Mat3\n */\nfunction setDefaultType$5(ctor) {\n    const oldType = MatType$1;\n    MatType$1 = ctor;\n    newMat3 = ctorMap.get(ctor);\n    return oldType;\n}\n/**\n * Create a Mat3 from values\n *\n * Note: Since passing in a raw JavaScript array\n * is valid in all circumstances, if you want to\n * force a JavaScript array into a Mat3's specified type\n * it would be faster to use\n *\n * ```\n * const m = mat3.clone(someJSArray);\n * ```\n *\n * Note: a consequence of the implementation is if your Mat3Type = `Array`\n * instead of `Float32Array` or `Float64Array` then any values you\n * don't pass in will be undefined. Usually this is not an issue since\n * (a) using `Array` is rare and (b) using `mat3.create` is usually used\n * to create a Mat3 to be filled out as in\n *\n * ```\n * const m = mat3.create();\n * mat3.perspective(fov, aspect, near, far, m);\n * ```\n *\n * @param v0 - value for element 0\n * @param v1 - value for element 1\n * @param v2 - value for element 2\n * @param v3 - value for element 3\n * @param v4 - value for element 4\n * @param v5 - value for element 5\n * @param v6 - value for element 6\n * @param v7 - value for element 7\n * @param v8 - value for element 8\n * @returns matrix created from values.\n */\nfunction create$4(v0, v1, v2, v3, v4, v5, v6, v7, v8) {\n    const dst = newMat3();\n    // to make the array homogenous\n    dst[3] = 0;\n    dst[7] = 0;\n    dst[11] = 0;\n    if (v0 !== undefined) {\n        dst[0] = v0;\n        if (v1 !== undefined) {\n            dst[1] = v1;\n            if (v2 !== undefined) {\n                dst[2] = v2;\n                if (v3 !== undefined) {\n                    dst[4] = v3;\n                    if (v4 !== undefined) {\n                        dst[5] = v4;\n                        if (v5 !== undefined) {\n                            dst[6] = v5;\n                            if (v6 !== undefined) {\n                                dst[8] = v6;\n                                if (v7 !== undefined) {\n                                    dst[9] = v7;\n                                    if (v8 !== undefined) {\n                                        dst[10] = v8;\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n    return dst;\n}\n/**\n * Sets the values of a Mat3\n * Also see {@link mat3.create} and {@link mat3.copy}\n *\n * @param v0 - value for element 0\n * @param v1 - value for element 1\n * @param v2 - value for element 2\n * @param v3 - value for element 3\n * @param v4 - value for element 4\n * @param v5 - value for element 5\n * @param v6 - value for element 6\n * @param v7 - value for element 7\n * @param v8 - value for element 8\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns Mat3 set from values.\n */\nfunction set$4(v0, v1, v2, v3, v4, v5, v6, v7, v8, dst) {\n    dst = dst || newMat3();\n    dst[0] = v0;\n    dst[1] = v1;\n    dst[2] = v2;\n    dst[3] = 0;\n    dst[4] = v3;\n    dst[5] = v4;\n    dst[6] = v5;\n    dst[7] = 0;\n    dst[8] = v6;\n    dst[9] = v7;\n    dst[10] = v8;\n    dst[11] = 0;\n    return dst;\n}\n/**\n * Creates a Mat3 from the upper left 3x3 part of a Mat4\n * @param m4 - source matrix\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns Mat3 made from m4\n */\nfunction fromMat4(m4, dst) {\n    dst = dst || newMat3();\n    dst[0] = m4[0];\n    dst[1] = m4[1];\n    dst[2] = m4[2];\n    dst[3] = 0;\n    dst[4] = m4[4];\n    dst[5] = m4[5];\n    dst[6] = m4[6];\n    dst[7] = 0;\n    dst[8] = m4[8];\n    dst[9] = m4[9];\n    dst[10] = m4[10];\n    dst[11] = 0;\n    return dst;\n}\n/**\n * Creates a Mat3 rotation matrix from a quaternion\n * @param q - quaternion to create matrix from\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns Mat3 made from q\n */\nfunction fromQuat$1(q, dst) {\n    dst = dst || newMat3();\n    const x = q[0];\n    const y = q[1];\n    const z = q[2];\n    const w = q[3];\n    const x2 = x + x;\n    const y2 = y + y;\n    const z2 = z + z;\n    const xx = x * x2;\n    const yx = y * x2;\n    const yy = y * y2;\n    const zx = z * x2;\n    const zy = z * y2;\n    const zz = z * z2;\n    const wx = w * x2;\n    const wy = w * y2;\n    const wz = w * z2;\n    dst[0] = 1 - yy - zz;\n    dst[1] = yx + wz;\n    dst[2] = zx - wy;\n    dst[3] = 0;\n    dst[4] = yx - wz;\n    dst[5] = 1 - xx - zz;\n    dst[6] = zy + wx;\n    dst[7] = 0;\n    dst[8] = zx + wy;\n    dst[9] = zy - wx;\n    dst[10] = 1 - xx - yy;\n    dst[11] = 0;\n    return dst;\n}\n/**\n * Negates a matrix.\n * @param m - The matrix.\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns -m.\n */\nfunction negate$3(m, dst) {\n    dst = dst || newMat3();\n    dst[0] = -m[0];\n    dst[1] = -m[1];\n    dst[2] = -m[2];\n    dst[4] = -m[4];\n    dst[5] = -m[5];\n    dst[6] = -m[6];\n    dst[8] = -m[8];\n    dst[9] = -m[9];\n    dst[10] = -m[10];\n    return dst;\n}\n/**\n * Copies a matrix. (same as {@link mat3.clone})\n * Also see {@link mat3.create} and {@link mat3.set}\n * @param m - The matrix.\n * @param dst - The matrix. If not passed a new one is created.\n * @returns A copy of m.\n */\nfunction copy$4(m, dst) {\n    dst = dst || newMat3();\n    dst[0] = m[0];\n    dst[1] = m[1];\n    dst[2] = m[2];\n    dst[4] = m[4];\n    dst[5] = m[5];\n    dst[6] = m[6];\n    dst[8] = m[8];\n    dst[9] = m[9];\n    dst[10] = m[10];\n    return dst;\n}\n/**\n * Copies a matrix (same as {@link mat3.copy})\n * Also see {@link mat3.create} and {@link mat3.set}\n * @param m - The matrix.\n * @param dst - The matrix. If not passed a new one is created.\n * @returns A copy of m.\n */\nconst clone$4 = copy$4;\n/**\n * Check if 2 matrices are approximately equal\n * @param a Operand matrix.\n * @param b Operand matrix.\n * @returns true if matrices are approximately equal\n */\nfunction equalsApproximately$4(a, b) {\n    return Math.abs(a[0] - b[0]) < EPSILON &&\n        Math.abs(a[1] - b[1]) < EPSILON &&\n        Math.abs(a[2] - b[2]) < EPSILON &&\n        Math.abs(a[4] - b[4]) < EPSILON &&\n        Math.abs(a[5] - b[5]) < EPSILON &&\n        Math.abs(a[6] - b[6]) < EPSILON &&\n        Math.abs(a[8] - b[8]) < EPSILON &&\n        Math.abs(a[9] - b[9]) < EPSILON &&\n        Math.abs(a[10] - b[10]) < EPSILON;\n}\n/**\n * Check if 2 matrices are exactly equal\n * @param a Operand matrix.\n * @param b Operand matrix.\n * @returns true if matrices are exactly equal\n */\nfunction equals$4(a, b) {\n    return a[0] === b[0] &&\n        a[1] === b[1] &&\n        a[2] === b[2] &&\n        a[4] === b[4] &&\n        a[5] === b[5] &&\n        a[6] === b[6] &&\n        a[8] === b[8] &&\n        a[9] === b[9] &&\n        a[10] === b[10];\n}\n/**\n * Creates a 3-by-3 identity matrix.\n *\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns A 3-by-3 identity matrix.\n */\nfunction identity$2(dst) {\n    dst = dst || newMat3();\n    dst[0] = 1;\n    dst[1] = 0;\n    dst[2] = 0;\n    dst[4] = 0;\n    dst[5] = 1;\n    dst[6] = 0;\n    dst[8] = 0;\n    dst[9] = 0;\n    dst[10] = 1;\n    return dst;\n}\n/**\n * Takes the transpose of a matrix.\n * @param m - The matrix.\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns The transpose of m.\n */\nfunction transpose$1(m, dst) {\n    dst = dst || newMat3();\n    if (dst === m) {\n        let t;\n        // 0 1 2\n        // 4 5 6\n        // 8 9 10\n        t = m[1];\n        m[1] = m[4];\n        m[4] = t;\n        t = m[2];\n        m[2] = m[8];\n        m[8] = t;\n        t = m[6];\n        m[6] = m[9];\n        m[9] = t;\n        return dst;\n    }\n    const m00 = m[0 * 4 + 0];\n    const m01 = m[0 * 4 + 1];\n    const m02 = m[0 * 4 + 2];\n    const m10 = m[1 * 4 + 0];\n    const m11 = m[1 * 4 + 1];\n    const m12 = m[1 * 4 + 2];\n    const m20 = m[2 * 4 + 0];\n    const m21 = m[2 * 4 + 1];\n    const m22 = m[2 * 4 + 2];\n    dst[0] = m00;\n    dst[1] = m10;\n    dst[2] = m20;\n    dst[4] = m01;\n    dst[5] = m11;\n    dst[6] = m21;\n    dst[8] = m02;\n    dst[9] = m12;\n    dst[10] = m22;\n    return dst;\n}\n/**\n * Computes the inverse of a 3-by-3 matrix.\n * @param m - The matrix.\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns The inverse of m.\n */\nfunction inverse$4(m, dst) {\n    dst = dst || newMat3();\n    const m00 = m[0 * 4 + 0];\n    const m01 = m[0 * 4 + 1];\n    const m02 = m[0 * 4 + 2];\n    const m10 = m[1 * 4 + 0];\n    const m11 = m[1 * 4 + 1];\n    const m12 = m[1 * 4 + 2];\n    const m20 = m[2 * 4 + 0];\n    const m21 = m[2 * 4 + 1];\n    const m22 = m[2 * 4 + 2];\n    const b01 = m22 * m11 - m12 * m21;\n    const b11 = -m22 * m10 + m12 * m20;\n    const b21 = m21 * m10 - m11 * m20;\n    const invDet = 1 / (m00 * b01 + m01 * b11 + m02 * b21);\n    dst[0] = b01 * invDet;\n    dst[1] = (-m22 * m01 + m02 * m21) * invDet;\n    dst[2] = (m12 * m01 - m02 * m11) * invDet;\n    dst[4] = b11 * invDet;\n    dst[5] = (m22 * m00 - m02 * m20) * invDet;\n    dst[6] = (-m12 * m00 + m02 * m10) * invDet;\n    dst[8] = b21 * invDet;\n    dst[9] = (-m21 * m00 + m01 * m20) * invDet;\n    dst[10] = (m11 * m00 - m01 * m10) * invDet;\n    return dst;\n}\n/**\n * Compute the determinant of a matrix\n * @param m - the matrix\n * @returns the determinant\n */\nfunction determinant$1(m) {\n    const m00 = m[0 * 4 + 0];\n    const m01 = m[0 * 4 + 1];\n    const m02 = m[0 * 4 + 2];\n    const m10 = m[1 * 4 + 0];\n    const m11 = m[1 * 4 + 1];\n    const m12 = m[1 * 4 + 2];\n    const m20 = m[2 * 4 + 0];\n    const m21 = m[2 * 4 + 1];\n    const m22 = m[2 * 4 + 2];\n    return m00 * (m11 * m22 - m21 * m12) -\n        m10 * (m01 * m22 - m21 * m02) +\n        m20 * (m01 * m12 - m11 * m02);\n}\n/**\n * Computes the inverse of a 3-by-3 matrix. (same as inverse)\n * @param m - The matrix.\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns The inverse of m.\n */\nconst invert$3 = inverse$4;\n/**\n * Multiplies two 3-by-3 matrices with a on the left and b on the right\n * @param a - The matrix on the left.\n * @param b - The matrix on the right.\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns The matrix product of a and b.\n */\nfunction multiply$4(a, b, dst) {\n    dst = dst || newMat3();\n    const a00 = a[0];\n    const a01 = a[1];\n    const a02 = a[2];\n    const a10 = a[4 + 0];\n    const a11 = a[4 + 1];\n    const a12 = a[4 + 2];\n    const a20 = a[8 + 0];\n    const a21 = a[8 + 1];\n    const a22 = a[8 + 2];\n    const b00 = b[0];\n    const b01 = b[1];\n    const b02 = b[2];\n    const b10 = b[4 + 0];\n    const b11 = b[4 + 1];\n    const b12 = b[4 + 2];\n    const b20 = b[8 + 0];\n    const b21 = b[8 + 1];\n    const b22 = b[8 + 2];\n    dst[0] = a00 * b00 + a10 * b01 + a20 * b02;\n    dst[1] = a01 * b00 + a11 * b01 + a21 * b02;\n    dst[2] = a02 * b00 + a12 * b01 + a22 * b02;\n    dst[4] = a00 * b10 + a10 * b11 + a20 * b12;\n    dst[5] = a01 * b10 + a11 * b11 + a21 * b12;\n    dst[6] = a02 * b10 + a12 * b11 + a22 * b12;\n    dst[8] = a00 * b20 + a10 * b21 + a20 * b22;\n    dst[9] = a01 * b20 + a11 * b21 + a21 * b22;\n    dst[10] = a02 * b20 + a12 * b21 + a22 * b22;\n    return dst;\n}\n/**\n * Multiplies two 3-by-3 matrices with a on the left and b on the right (same as multiply)\n * @param a - The matrix on the left.\n * @param b - The matrix on the right.\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns The matrix product of a and b.\n */\nconst mul$4 = multiply$4;\n/**\n * Sets the translation component of a 3-by-3 matrix to the given\n * vector.\n * @param a - The matrix.\n * @param v - The vector.\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns The matrix with translation set.\n */\nfunction setTranslation$1(a, v, dst) {\n    dst = dst || identity$2();\n    if (a !== dst) {\n        dst[0] = a[0];\n        dst[1] = a[1];\n        dst[2] = a[2];\n        dst[4] = a[4];\n        dst[5] = a[5];\n        dst[6] = a[6];\n    }\n    dst[8] = v[0];\n    dst[9] = v[1];\n    dst[10] = 1;\n    return dst;\n}\n/**\n * Returns the translation component of a 3-by-3 matrix as a vector with 3\n * entries.\n * @param m - The matrix.\n * @param dst - vector to hold result. If not passed a new one is created.\n * @returns The translation component of m.\n */\nfunction getTranslation$2(m, dst) {\n    dst = dst || create$5();\n    dst[0] = m[8];\n    dst[1] = m[9];\n    return dst;\n}\n/**\n * Returns an axis of a 3x3 matrix as a vector with 2 entries\n * @param m - The matrix.\n * @param axis - The axis 0 = x, 1 = y,\n * @returns The axis component of m.\n */\nfunction getAxis$2(m, axis, dst) {\n    dst = dst || create$5();\n    const off = axis * 4;\n    dst[0] = m[off + 0];\n    dst[1] = m[off + 1];\n    return dst;\n}\n/**\n * Sets an axis of a 3x3 matrix as a vector with 2 entries\n * @param m - The matrix.\n * @param v - the axis vector\n * @param axis - The axis  0 = x, 1 = y;\n * @param dst - The matrix to set. If not passed a new one is created.\n * @returns The matrix with axis set.\n */\nfunction setAxis$1(m, v, axis, dst) {\n    if (dst !== m) {\n        dst = copy$4(m, dst);\n    }\n    const off = axis * 4;\n    dst[off + 0] = v[0];\n    dst[off + 1] = v[1];\n    return dst;\n}\n/**\n * Returns the scaling component of the matrix\n * @param m - The Matrix\n * @param dst - The vector to set. If not passed a new one is created.\n */\nfunction getScaling$2(m, dst) {\n    dst = dst || create$5();\n    const xx = m[0];\n    const xy = m[1];\n    const yx = m[4];\n    const yy = m[5];\n    dst[0] = Math.sqrt(xx * xx + xy * xy);\n    dst[1] = Math.sqrt(yx * yx + yy * yy);\n    return dst;\n}\n/**\n * Creates a 3-by-3 matrix which translates by the given vector v.\n * @param v - The vector by which to translate.\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns The translation matrix.\n */\nfunction translation$1(v, dst) {\n    dst = dst || newMat3();\n    dst[0] = 1;\n    dst[1] = 0;\n    dst[2] = 0;\n    dst[4] = 0;\n    dst[5] = 1;\n    dst[6] = 0;\n    dst[8] = v[0];\n    dst[9] = v[1];\n    dst[10] = 1;\n    return dst;\n}\n/**\n * Translates the given 3-by-3 matrix by the given vector v.\n * @param m - The matrix.\n * @param v - The vector by which to translate.\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns The translated matrix.\n */\nfunction translate$1(m, v, dst) {\n    dst = dst || newMat3();\n    const v0 = v[0];\n    const v1 = v[1];\n    const m00 = m[0];\n    const m01 = m[1];\n    const m02 = m[2];\n    const m10 = m[1 * 4 + 0];\n    const m11 = m[1 * 4 + 1];\n    const m12 = m[1 * 4 + 2];\n    const m20 = m[2 * 4 + 0];\n    const m21 = m[2 * 4 + 1];\n    const m22 = m[2 * 4 + 2];\n    if (m !== dst) {\n        dst[0] = m00;\n        dst[1] = m01;\n        dst[2] = m02;\n        dst[4] = m10;\n        dst[5] = m11;\n        dst[6] = m12;\n    }\n    dst[8] = m00 * v0 + m10 * v1 + m20;\n    dst[9] = m01 * v0 + m11 * v1 + m21;\n    dst[10] = m02 * v0 + m12 * v1 + m22;\n    return dst;\n}\n/**\n * Creates a 3-by-3 matrix which rotates  by the given angle.\n * @param angleInRadians - The angle by which to rotate (in radians).\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns The rotation matrix.\n */\nfunction rotation$1(angleInRadians, dst) {\n    dst = dst || newMat3();\n    const c = Math.cos(angleInRadians);\n    const s = Math.sin(angleInRadians);\n    dst[0] = c;\n    dst[1] = s;\n    dst[2] = 0;\n    dst[4] = -s;\n    dst[5] = c;\n    dst[6] = 0;\n    dst[8] = 0;\n    dst[9] = 0;\n    dst[10] = 1;\n    return dst;\n}\n/**\n * Rotates the given 3-by-3 matrix  by the given angle.\n * @param m - The matrix.\n * @param angleInRadians - The angle by which to rotate (in radians).\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns The rotated matrix.\n */\nfunction rotate$1(m, angleInRadians, dst) {\n    dst = dst || newMat3();\n    const m00 = m[0 * 4 + 0];\n    const m01 = m[0 * 4 + 1];\n    const m02 = m[0 * 4 + 2];\n    const m10 = m[1 * 4 + 0];\n    const m11 = m[1 * 4 + 1];\n    const m12 = m[1 * 4 + 2];\n    const c = Math.cos(angleInRadians);\n    const s = Math.sin(angleInRadians);\n    dst[0] = c * m00 + s * m10;\n    dst[1] = c * m01 + s * m11;\n    dst[2] = c * m02 + s * m12;\n    dst[4] = c * m10 - s * m00;\n    dst[5] = c * m11 - s * m01;\n    dst[6] = c * m12 - s * m02;\n    if (m !== dst) {\n        dst[8] = m[8];\n        dst[9] = m[9];\n        dst[10] = m[10];\n    }\n    return dst;\n}\n/**\n * Creates a 3-by-3 matrix which scales in each dimension by an amount given by\n * the corresponding entry in the given vector; assumes the vector has three\n * entries.\n * @param v - A vector of\n *     2 entries specifying the factor by which to scale in each dimension.\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns The scaling matrix.\n */\nfunction scaling$1(v, dst) {\n    dst = dst || newMat3();\n    dst[0] = v[0];\n    dst[1] = 0;\n    dst[2] = 0;\n    dst[4] = 0;\n    dst[5] = v[1];\n    dst[6] = 0;\n    dst[8] = 0;\n    dst[9] = 0;\n    dst[10] = 1;\n    return dst;\n}\n/**\n * Scales the given 3-by-3 matrix in each dimension by an amount\n * given by the corresponding entry in the given vector; assumes the vector has\n * three entries.\n * @param m - The matrix to be modified.\n * @param v - A vector of 2 entries specifying the\n *     factor by which to scale in each dimension.\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns The scaled matrix.\n */\nfunction scale$4(m, v, dst) {\n    dst = dst || newMat3();\n    const v0 = v[0];\n    const v1 = v[1];\n    dst[0] = v0 * m[0 * 4 + 0];\n    dst[1] = v0 * m[0 * 4 + 1];\n    dst[2] = v0 * m[0 * 4 + 2];\n    dst[4] = v1 * m[1 * 4 + 0];\n    dst[5] = v1 * m[1 * 4 + 1];\n    dst[6] = v1 * m[1 * 4 + 2];\n    if (m !== dst) {\n        dst[8] = m[8];\n        dst[9] = m[9];\n        dst[10] = m[10];\n    }\n    return dst;\n}\n/**\n * Creates a 3-by-3 matrix which scales uniformly in each dimension\n * @param s - Amount to scale\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns The scaling matrix.\n */\nfunction uniformScaling$1(s, dst) {\n    dst = dst || newMat3();\n    dst[0] = s;\n    dst[1] = 0;\n    dst[2] = 0;\n    dst[4] = 0;\n    dst[5] = s;\n    dst[6] = 0;\n    dst[8] = 0;\n    dst[9] = 0;\n    dst[10] = 1;\n    return dst;\n}\n/**\n * Scales the given 3-by-3 matrix in each dimension by an amount\n * given.\n * @param m - The matrix to be modified.\n * @param s - Amount to scale.\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns The scaled matrix.\n */\nfunction uniformScale$1(m, s, dst) {\n    dst = dst || newMat3();\n    dst[0] = s * m[0 * 4 + 0];\n    dst[1] = s * m[0 * 4 + 1];\n    dst[2] = s * m[0 * 4 + 2];\n    dst[4] = s * m[1 * 4 + 0];\n    dst[5] = s * m[1 * 4 + 1];\n    dst[6] = s * m[1 * 4 + 2];\n    if (m !== dst) {\n        dst[8] = m[8];\n        dst[9] = m[9];\n        dst[10] = m[10];\n    }\n    return dst;\n}\n\nvar mat3Impl = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    setDefaultType: setDefaultType$5,\n    create: create$4,\n    set: set$4,\n    fromMat4: fromMat4,\n    fromQuat: fromQuat$1,\n    negate: negate$3,\n    copy: copy$4,\n    clone: clone$4,\n    equalsApproximately: equalsApproximately$4,\n    equals: equals$4,\n    identity: identity$2,\n    transpose: transpose$1,\n    inverse: inverse$4,\n    determinant: determinant$1,\n    invert: invert$3,\n    multiply: multiply$4,\n    mul: mul$4,\n    setTranslation: setTranslation$1,\n    getTranslation: getTranslation$2,\n    getAxis: getAxis$2,\n    setAxis: setAxis$1,\n    getScaling: getScaling$2,\n    translation: translation$1,\n    translate: translate$1,\n    rotation: rotation$1,\n    rotate: rotate$1,\n    scaling: scaling$1,\n    scale: scale$4,\n    uniformScaling: uniformScaling$1,\n    uniformScale: uniformScale$1\n});\n\n/*\n * Copyright 2022 Gregg Tavares\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL\n * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n/**\n *\n * Vec3 math functions.\n *\n * Almost all functions take an optional `dst` argument. If it is not passed in the\n * functions will create a new `Vec3`. In other words you can do this\n *\n *     const v = vec3.cross(v1, v2);  // Creates a new Vec3 with the cross product of v1 x v2.\n *\n * or\n *\n *     const v = vec3.create();\n *     vec3.cross(v1, v2, v);  // Puts the cross product of v1 x v2 in v\n *\n * The first style is often easier but depending on where it's used it generates garbage where\n * as there is almost never allocation with the second style.\n *\n * It is always safe to pass any vector as the destination. So for example\n *\n *     vec3.cross(v1, v2, v1);  // Puts the cross product of v1 x v2 in v1\n *\n */\nlet VecType$1 = Float32Array;\n/**\n * Sets the type this library creates for a Vec3\n * @param ctor - the constructor for the type. Either `Float32Array`, `Float64Array`, or `Array`\n * @returns previous constructor for Vec3\n */\nfunction setDefaultType$4(ctor) {\n    const oldType = VecType$1;\n    VecType$1 = ctor;\n    return oldType;\n}\n/**\n * Creates a vec3; may be called with x, y, z to set initial values.\n * @param x - Initial x value.\n * @param y - Initial y value.\n * @param z - Initial z value.\n * @returns the created vector\n */\nfunction create$3(x, y, z) {\n    const dst = new VecType$1(3);\n    if (x !== undefined) {\n        dst[0] = x;\n        if (y !== undefined) {\n            dst[1] = y;\n            if (z !== undefined) {\n                dst[2] = z;\n            }\n        }\n    }\n    return dst;\n}\n\n/*\n * Copyright 2022 Gregg Tavares\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL\n * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n/**\n * Creates a vec3; may be called with x, y, z to set initial values. (same as create)\n * @param x - Initial x value.\n * @param y - Initial y value.\n * @param z - Initial z value.\n * @returns the created vector\n */\nconst fromValues$2 = create$3;\n/**\n * Sets the values of a Vec3\n * Also see {@link vec3.create} and {@link vec3.copy}\n *\n * @param x first value\n * @param y second value\n * @param z third value\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns A vector with its elements set.\n */\nfunction set$3(x, y, z, dst) {\n    dst = dst || new VecType$1(3);\n    dst[0] = x;\n    dst[1] = y;\n    dst[2] = z;\n    return dst;\n}\n/**\n * Applies Math.ceil to each element of vector\n * @param v - Operand vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns A vector that is the ceil of each element of v.\n */\nfunction ceil$1(v, dst) {\n    dst = dst || new VecType$1(3);\n    dst[0] = Math.ceil(v[0]);\n    dst[1] = Math.ceil(v[1]);\n    dst[2] = Math.ceil(v[2]);\n    return dst;\n}\n/**\n * Applies Math.floor to each element of vector\n * @param v - Operand vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns A vector that is the floor of each element of v.\n */\nfunction floor$1(v, dst) {\n    dst = dst || new VecType$1(3);\n    dst[0] = Math.floor(v[0]);\n    dst[1] = Math.floor(v[1]);\n    dst[2] = Math.floor(v[2]);\n    return dst;\n}\n/**\n * Applies Math.round to each element of vector\n * @param v - Operand vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns A vector that is the round of each element of v.\n */\nfunction round$1(v, dst) {\n    dst = dst || new VecType$1(3);\n    dst[0] = Math.round(v[0]);\n    dst[1] = Math.round(v[1]);\n    dst[2] = Math.round(v[2]);\n    return dst;\n}\n/**\n * Clamp each element of vector between min and max\n * @param v - Operand vector.\n * @param max - Min value, default 0\n * @param min - Max value, default 1\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns A vector that the clamped value of each element of v.\n */\nfunction clamp$1(v, min = 0, max = 1, dst) {\n    dst = dst || new VecType$1(3);\n    dst[0] = Math.min(max, Math.max(min, v[0]));\n    dst[1] = Math.min(max, Math.max(min, v[1]));\n    dst[2] = Math.min(max, Math.max(min, v[2]));\n    return dst;\n}\n/**\n * Adds two vectors; assumes a and b have the same dimension.\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns A vector that is the sum of a and b.\n */\nfunction add$2(a, b, dst) {\n    dst = dst || new VecType$1(3);\n    dst[0] = a[0] + b[0];\n    dst[1] = a[1] + b[1];\n    dst[2] = a[2] + b[2];\n    return dst;\n}\n/**\n * Adds two vectors, scaling the 2nd; assumes a and b have the same dimension.\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @param scale - Amount to scale b\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns A vector that is the sum of a + b * scale.\n */\nfunction addScaled$1(a, b, scale, dst) {\n    dst = dst || new VecType$1(3);\n    dst[0] = a[0] + b[0] * scale;\n    dst[1] = a[1] + b[1] * scale;\n    dst[2] = a[2] + b[2] * scale;\n    return dst;\n}\n/**\n * Returns the angle in radians between two vectors.\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @returns The angle in radians between the 2 vectors.\n */\nfunction angle$1(a, b) {\n    const ax = a[0];\n    const ay = a[1];\n    const az = a[2];\n    const bx = a[0];\n    const by = a[1];\n    const bz = a[2];\n    const mag1 = Math.sqrt(ax * ax + ay * ay + az * az);\n    const mag2 = Math.sqrt(bx * bx + by * by + bz * bz);\n    const mag = mag1 * mag2;\n    const cosine = mag && dot$2(a, b) / mag;\n    return Math.acos(cosine);\n}\n/**\n * Subtracts two vectors.\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns A vector that is the difference of a and b.\n */\nfunction subtract$2(a, b, dst) {\n    dst = dst || new VecType$1(3);\n    dst[0] = a[0] - b[0];\n    dst[1] = a[1] - b[1];\n    dst[2] = a[2] - b[2];\n    return dst;\n}\n/**\n * Subtracts two vectors.\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns A vector that is the difference of a and b.\n */\nconst sub$2 = subtract$2;\n/**\n * Check if 2 vectors are approximately equal\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @returns true if vectors are approximately equal\n */\nfunction equalsApproximately$3(a, b) {\n    return Math.abs(a[0] - b[0]) < EPSILON &&\n        Math.abs(a[1] - b[1]) < EPSILON &&\n        Math.abs(a[2] - b[2]) < EPSILON;\n}\n/**\n * Check if 2 vectors are exactly equal\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @returns true if vectors are exactly equal\n */\nfunction equals$3(a, b) {\n    return a[0] === b[0] && a[1] === b[1] && a[2] === b[2];\n}\n/**\n * Performs linear interpolation on two vectors.\n * Given vectors a and b and interpolation coefficient t, returns\n * a + t * (b - a).\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @param t - Interpolation coefficient.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns The linear interpolated result.\n */\nfunction lerp$2(a, b, t, dst) {\n    dst = dst || new VecType$1(3);\n    dst[0] = a[0] + t * (b[0] - a[0]);\n    dst[1] = a[1] + t * (b[1] - a[1]);\n    dst[2] = a[2] + t * (b[2] - a[2]);\n    return dst;\n}\n/**\n * Performs linear interpolation on two vectors.\n * Given vectors a and b and interpolation coefficient vector t, returns\n * a + t * (b - a).\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @param t - Interpolation coefficients vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns the linear interpolated result.\n */\nfunction lerpV$1(a, b, t, dst) {\n    dst = dst || new VecType$1(3);\n    dst[0] = a[0] + t[0] * (b[0] - a[0]);\n    dst[1] = a[1] + t[1] * (b[1] - a[1]);\n    dst[2] = a[2] + t[2] * (b[2] - a[2]);\n    return dst;\n}\n/**\n * Return max values of two vectors.\n * Given vectors a and b returns\n * [max(a[0], b[0]), max(a[1], b[1]), max(a[2], b[2])].\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns The max components vector.\n */\nfunction max$1(a, b, dst) {\n    dst = dst || new VecType$1(3);\n    dst[0] = Math.max(a[0], b[0]);\n    dst[1] = Math.max(a[1], b[1]);\n    dst[2] = Math.max(a[2], b[2]);\n    return dst;\n}\n/**\n * Return min values of two vectors.\n * Given vectors a and b returns\n * [min(a[0], b[0]), min(a[1], b[1]), min(a[2], b[2])].\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns The min components vector.\n */\nfunction min$1(a, b, dst) {\n    dst = dst || new VecType$1(3);\n    dst[0] = Math.min(a[0], b[0]);\n    dst[1] = Math.min(a[1], b[1]);\n    dst[2] = Math.min(a[2], b[2]);\n    return dst;\n}\n/**\n * Multiplies a vector by a scalar.\n * @param v - The vector.\n * @param k - The scalar.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns The scaled vector.\n */\nfunction mulScalar$2(v, k, dst) {\n    dst = dst || new VecType$1(3);\n    dst[0] = v[0] * k;\n    dst[1] = v[1] * k;\n    dst[2] = v[2] * k;\n    return dst;\n}\n/**\n * Multiplies a vector by a scalar. (same as mulScalar)\n * @param v - The vector.\n * @param k - The scalar.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns The scaled vector.\n */\nconst scale$3 = mulScalar$2;\n/**\n * Divides a vector by a scalar.\n * @param v - The vector.\n * @param k - The scalar.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns The scaled vector.\n */\nfunction divScalar$2(v, k, dst) {\n    dst = dst || new VecType$1(3);\n    dst[0] = v[0] / k;\n    dst[1] = v[1] / k;\n    dst[2] = v[2] / k;\n    return dst;\n}\n/**\n * Inverse a vector.\n * @param v - The vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns The inverted vector.\n */\nfunction inverse$3(v, dst) {\n    dst = dst || new VecType$1(3);\n    dst[0] = 1 / v[0];\n    dst[1] = 1 / v[1];\n    dst[2] = 1 / v[2];\n    return dst;\n}\n/**\n * Invert a vector. (same as inverse)\n * @param v - The vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns The inverted vector.\n */\nconst invert$2 = inverse$3;\n/**\n * Computes the cross product of two vectors; assumes both vectors have\n * three entries.\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns The vector of a cross b.\n */\nfunction cross(a, b, dst) {\n    dst = dst || new VecType$1(3);\n    const t1 = a[2] * b[0] - a[0] * b[2];\n    const t2 = a[0] * b[1] - a[1] * b[0];\n    dst[0] = a[1] * b[2] - a[2] * b[1];\n    dst[1] = t1;\n    dst[2] = t2;\n    return dst;\n}\n/**\n * Computes the dot product of two vectors; assumes both vectors have\n * three entries.\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @returns dot product\n */\nfunction dot$2(a, b) {\n    return (a[0] * b[0]) + (a[1] * b[1]) + (a[2] * b[2]);\n}\n/**\n * Computes the length of vector\n * @param v - vector.\n * @returns length of vector.\n */\nfunction length$2(v) {\n    const v0 = v[0];\n    const v1 = v[1];\n    const v2 = v[2];\n    return Math.sqrt(v0 * v0 + v1 * v1 + v2 * v2);\n}\n/**\n * Computes the length of vector (same as length)\n * @param v - vector.\n * @returns length of vector.\n */\nconst len$2 = length$2;\n/**\n * Computes the square of the length of vector\n * @param v - vector.\n * @returns square of the length of vector.\n */\nfunction lengthSq$2(v) {\n    const v0 = v[0];\n    const v1 = v[1];\n    const v2 = v[2];\n    return v0 * v0 + v1 * v1 + v2 * v2;\n}\n/**\n * Computes the square of the length of vector (same as lengthSq)\n * @param v - vector.\n * @returns square of the length of vector.\n */\nconst lenSq$2 = lengthSq$2;\n/**\n * Computes the distance between 2 points\n * @param a - vector.\n * @param b - vector.\n * @returns distance between a and b\n */\nfunction distance$1(a, b) {\n    const dx = a[0] - b[0];\n    const dy = a[1] - b[1];\n    const dz = a[2] - b[2];\n    return Math.sqrt(dx * dx + dy * dy + dz * dz);\n}\n/**\n * Computes the distance between 2 points (same as distance)\n * @param a - vector.\n * @param b - vector.\n * @returns distance between a and b\n */\nconst dist$1 = distance$1;\n/**\n * Computes the square of the distance between 2 points\n * @param a - vector.\n * @param b - vector.\n * @returns square of the distance between a and b\n */\nfunction distanceSq$1(a, b) {\n    const dx = a[0] - b[0];\n    const dy = a[1] - b[1];\n    const dz = a[2] - b[2];\n    return dx * dx + dy * dy + dz * dz;\n}\n/**\n * Computes the square of the distance between 2 points (same as distanceSq)\n * @param a - vector.\n * @param b - vector.\n * @returns square of the distance between a and b\n */\nconst distSq$1 = distanceSq$1;\n/**\n * Divides a vector by its Euclidean length and returns the quotient.\n * @param v - The vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns The normalized vector.\n */\nfunction normalize$2(v, dst) {\n    dst = dst || new VecType$1(3);\n    const v0 = v[0];\n    const v1 = v[1];\n    const v2 = v[2];\n    const len = Math.sqrt(v0 * v0 + v1 * v1 + v2 * v2);\n    if (len > 0.00001) {\n        dst[0] = v0 / len;\n        dst[1] = v1 / len;\n        dst[2] = v2 / len;\n    }\n    else {\n        dst[0] = 0;\n        dst[1] = 0;\n        dst[2] = 0;\n    }\n    return dst;\n}\n/**\n * Negates a vector.\n * @param v - The vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns -v.\n */\nfunction negate$2(v, dst) {\n    dst = dst || new VecType$1(3);\n    dst[0] = -v[0];\n    dst[1] = -v[1];\n    dst[2] = -v[2];\n    return dst;\n}\n/**\n * Copies a vector. (same as {@link vec3.clone})\n * Also see {@link vec3.create} and {@link vec3.set}\n * @param v - The vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns A copy of v.\n */\nfunction copy$3(v, dst) {\n    dst = dst || new VecType$1(3);\n    dst[0] = v[0];\n    dst[1] = v[1];\n    dst[2] = v[2];\n    return dst;\n}\n/**\n * Clones a vector. (same as {@link vec3.copy})\n * Also see {@link vec3.create} and {@link vec3.set}\n * @param v - The vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns A copy of v.\n */\nconst clone$3 = copy$3;\n/**\n * Multiplies a vector by another vector (component-wise); assumes a and\n * b have the same length.\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns The vector of products of entries of a and b.\n */\nfunction multiply$3(a, b, dst) {\n    dst = dst || new VecType$1(3);\n    dst[0] = a[0] * b[0];\n    dst[1] = a[1] * b[1];\n    dst[2] = a[2] * b[2];\n    return dst;\n}\n/**\n * Multiplies a vector by another vector (component-wise); assumes a and\n * b have the same length. (same as mul)\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns The vector of products of entries of a and b.\n */\nconst mul$3 = multiply$3;\n/**\n * Divides a vector by another vector (component-wise); assumes a and\n * b have the same length.\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns The vector of quotients of entries of a and b.\n */\nfunction divide$1(a, b, dst) {\n    dst = dst || new VecType$1(3);\n    dst[0] = a[0] / b[0];\n    dst[1] = a[1] / b[1];\n    dst[2] = a[2] / b[2];\n    return dst;\n}\n/**\n * Divides a vector by another vector (component-wise); assumes a and\n * b have the same length. (same as divide)\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns The vector of quotients of entries of a and b.\n */\nconst div$1 = divide$1;\n/**\n * Creates a random vector\n * @param scale - Default 1\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns The random vector.\n */\nfunction random(scale = 1, dst) {\n    dst = dst || new VecType$1(3);\n    const angle = Math.random() * 2 * Math.PI;\n    const z = Math.random() * 2 - 1;\n    const zScale = Math.sqrt(1 - z * z) * scale;\n    dst[0] = Math.cos(angle) * zScale;\n    dst[1] = Math.sin(angle) * zScale;\n    dst[2] = z * scale;\n    return dst;\n}\n/**\n * Zero's a vector\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns The zeroed vector.\n */\nfunction zero$1(dst) {\n    dst = dst || new VecType$1(3);\n    dst[0] = 0;\n    dst[1] = 0;\n    dst[2] = 0;\n    return dst;\n}\n/**\n * transform vec3 by 4x4 matrix\n * @param v - the vector\n * @param m - The matrix.\n * @param dst - optional vec3 to store result. If not passed a new one is created.\n * @returns the transformed vector\n */\nfunction transformMat4$1(v, m, dst) {\n    dst = dst || new VecType$1(3);\n    const x = v[0];\n    const y = v[1];\n    const z = v[2];\n    const w = (m[3] * x + m[7] * y + m[11] * z + m[15]) || 1;\n    dst[0] = (m[0] * x + m[4] * y + m[8] * z + m[12]) / w;\n    dst[1] = (m[1] * x + m[5] * y + m[9] * z + m[13]) / w;\n    dst[2] = (m[2] * x + m[6] * y + m[10] * z + m[14]) / w;\n    return dst;\n}\n/**\n * Transform vec4 by upper 3x3 matrix inside 4x4 matrix.\n * @param v - The direction.\n * @param m - The matrix.\n * @param dst - optional Vec3 to store result. If not passed a new one is created.\n * @returns The transformed vector.\n */\nfunction transformMat4Upper3x3(v, m, dst) {\n    dst = dst || new VecType$1(3);\n    const v0 = v[0];\n    const v1 = v[1];\n    const v2 = v[2];\n    dst[0] = v0 * m[0 * 4 + 0] + v1 * m[1 * 4 + 0] + v2 * m[2 * 4 + 0];\n    dst[1] = v0 * m[0 * 4 + 1] + v1 * m[1 * 4 + 1] + v2 * m[2 * 4 + 1];\n    dst[2] = v0 * m[0 * 4 + 2] + v1 * m[1 * 4 + 2] + v2 * m[2 * 4 + 2];\n    return dst;\n}\n/**\n * Transforms vec3 by 3x3 matrix\n *\n * @param v - the vector\n * @param m - The matrix.\n * @param dst - optional vec3 to store result. If not passed a new one is created.\n * @returns the transformed vector\n */\nfunction transformMat3(v, m, dst) {\n    dst = dst || new VecType$1(3);\n    const x = v[0];\n    const y = v[1];\n    const z = v[2];\n    dst[0] = x * m[0] + y * m[4] + z * m[8];\n    dst[1] = x * m[1] + y * m[5] + z * m[9];\n    dst[2] = x * m[2] + y * m[6] + z * m[10];\n    return dst;\n}\n/**\n * Transforms vec3 by Quaternion\n * @param v - the vector to transform\n * @param q - the quaternion to transform by\n * @param dst - optional vec3 to store result. If not passed a new one is created.\n * @returns the transformed\n */\nfunction transformQuat(v, q, dst) {\n    dst = dst || new VecType$1(3);\n    const qx = q[0];\n    const qy = q[1];\n    const qz = q[2];\n    const w2 = q[3] * 2;\n    const x = v[0];\n    const y = v[1];\n    const z = v[2];\n    const uvX = qy * z - qz * y;\n    const uvY = qz * x - qx * z;\n    const uvZ = qx * y - qy * x;\n    dst[0] = x + uvX * w2 + (qy * uvZ - qz * uvY) * 2;\n    dst[1] = y + uvY * w2 + (qz * uvX - qx * uvZ) * 2;\n    dst[2] = z + uvZ * w2 + (qx * uvY - qy * uvX) * 2;\n    return dst;\n}\n/**\n * Returns the translation component of a 4-by-4 matrix as a vector with 3\n * entries.\n * @param m - The matrix.\n * @param dst - vector to hold result. If not passed a new one is created.\n * @returns The translation component of m.\n */\nfunction getTranslation$1(m, dst) {\n    dst = dst || new VecType$1(3);\n    dst[0] = m[12];\n    dst[1] = m[13];\n    dst[2] = m[14];\n    return dst;\n}\n/**\n * Returns an axis of a 4x4 matrix as a vector with 3 entries\n * @param m - The matrix.\n * @param axis - The axis 0 = x, 1 = y, 2 = z;\n * @returns The axis component of m.\n */\nfunction getAxis$1(m, axis, dst) {\n    dst = dst || new VecType$1(3);\n    const off = axis * 4;\n    dst[0] = m[off + 0];\n    dst[1] = m[off + 1];\n    dst[2] = m[off + 2];\n    return dst;\n}\n/**\n * Returns the scaling component of the matrix\n * @param m - The Matrix\n * @param dst - The vector to set. If not passed a new one is created.\n */\nfunction getScaling$1(m, dst) {\n    dst = dst || new VecType$1(3);\n    const xx = m[0];\n    const xy = m[1];\n    const xz = m[2];\n    const yx = m[4];\n    const yy = m[5];\n    const yz = m[6];\n    const zx = m[8];\n    const zy = m[9];\n    const zz = m[10];\n    dst[0] = Math.sqrt(xx * xx + xy * xy + xz * xz);\n    dst[1] = Math.sqrt(yx * yx + yy * yy + yz * yz);\n    dst[2] = Math.sqrt(zx * zx + zy * zy + zz * zz);\n    return dst;\n}\n\nvar vec3Impl = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    create: create$3,\n    setDefaultType: setDefaultType$4,\n    fromValues: fromValues$2,\n    set: set$3,\n    ceil: ceil$1,\n    floor: floor$1,\n    round: round$1,\n    clamp: clamp$1,\n    add: add$2,\n    addScaled: addScaled$1,\n    angle: angle$1,\n    subtract: subtract$2,\n    sub: sub$2,\n    equalsApproximately: equalsApproximately$3,\n    equals: equals$3,\n    lerp: lerp$2,\n    lerpV: lerpV$1,\n    max: max$1,\n    min: min$1,\n    mulScalar: mulScalar$2,\n    scale: scale$3,\n    divScalar: divScalar$2,\n    inverse: inverse$3,\n    invert: invert$2,\n    cross: cross,\n    dot: dot$2,\n    length: length$2,\n    len: len$2,\n    lengthSq: lengthSq$2,\n    lenSq: lenSq$2,\n    distance: distance$1,\n    dist: dist$1,\n    distanceSq: distanceSq$1,\n    distSq: distSq$1,\n    normalize: normalize$2,\n    negate: negate$2,\n    copy: copy$3,\n    clone: clone$3,\n    multiply: multiply$3,\n    mul: mul$3,\n    divide: divide$1,\n    div: div$1,\n    random: random,\n    zero: zero$1,\n    transformMat4: transformMat4$1,\n    transformMat4Upper3x3: transformMat4Upper3x3,\n    transformMat3: transformMat3,\n    transformQuat: transformQuat,\n    getTranslation: getTranslation$1,\n    getAxis: getAxis$1,\n    getScaling: getScaling$1\n});\n\n/**\n * 4x4 Matrix math math functions.\n *\n * Almost all functions take an optional `dst` argument. If it is not passed in the\n * functions will create a new matrix. In other words you can do this\n *\n *     const mat = mat4.translation([1, 2, 3]);  // Creates a new translation matrix\n *\n * or\n *\n *     const mat = mat4.create();\n *     mat4.translation([1, 2, 3], mat);  // Puts translation matrix in mat.\n *\n * The first style is often easier but depending on where it's used it generates garbage where\n * as there is almost never allocation with the second style.\n *\n * It is always save to pass any matrix as the destination. So for example\n *\n *     const mat = mat4.identity();\n *     const trans = mat4.translation([1, 2, 3]);\n *     mat4.multiply(mat, trans, mat);  // Multiplies mat * trans and puts result in mat.\n *\n */\nlet MatType = Float32Array;\n/**\n * Sets the type this library creates for a Mat4\n * @param ctor - the constructor for the type. Either `Float32Array`, `Float64Array`, or `Array`\n * @returns previous constructor for Mat4\n */\nfunction setDefaultType$3(ctor) {\n    const oldType = MatType;\n    MatType = ctor;\n    return oldType;\n}\n/**\n * Create a Mat4 from values\n *\n * Note: Since passing in a raw JavaScript array\n * is valid in all circumstances, if you want to\n * force a JavaScript array into a Mat4's specified type\n * it would be faster to use\n *\n * ```\n * const m = mat4.clone(someJSArray);\n * ```\n *\n * Note: a consequence of the implementation is if your Mat4Type = `Array`\n * instead of `Float32Array` or `Float64Array` then any values you\n * don't pass in will be undefined. Usually this is not an issue since\n * (a) using `Array` is rare and (b) using `mat4.create` is usually used\n * to create a Mat4 to be filled out as in\n *\n * ```\n * const m = mat4.create();\n * mat4.perspective(fov, aspect, near, far, m);\n * ```\n *\n * @param v0 - value for element 0\n * @param v1 - value for element 1\n * @param v2 - value for element 2\n * @param v3 - value for element 3\n * @param v4 - value for element 4\n * @param v5 - value for element 5\n * @param v6 - value for element 6\n * @param v7 - value for element 7\n * @param v8 - value for element 8\n * @param v9 - value for element 9\n * @param v10 - value for element 10\n * @param v11 - value for element 11\n * @param v12 - value for element 12\n * @param v13 - value for element 13\n * @param v14 - value for element 14\n * @param v15 - value for element 15\n * @returns created from values.\n */\nfunction create$2(v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15) {\n    const dst = new MatType(16);\n    if (v0 !== undefined) {\n        dst[0] = v0;\n        if (v1 !== undefined) {\n            dst[1] = v1;\n            if (v2 !== undefined) {\n                dst[2] = v2;\n                if (v3 !== undefined) {\n                    dst[3] = v3;\n                    if (v4 !== undefined) {\n                        dst[4] = v4;\n                        if (v5 !== undefined) {\n                            dst[5] = v5;\n                            if (v6 !== undefined) {\n                                dst[6] = v6;\n                                if (v7 !== undefined) {\n                                    dst[7] = v7;\n                                    if (v8 !== undefined) {\n                                        dst[8] = v8;\n                                        if (v9 !== undefined) {\n                                            dst[9] = v9;\n                                            if (v10 !== undefined) {\n                                                dst[10] = v10;\n                                                if (v11 !== undefined) {\n                                                    dst[11] = v11;\n                                                    if (v12 !== undefined) {\n                                                        dst[12] = v12;\n                                                        if (v13 !== undefined) {\n                                                            dst[13] = v13;\n                                                            if (v14 !== undefined) {\n                                                                dst[14] = v14;\n                                                                if (v15 !== undefined) {\n                                                                    dst[15] = v15;\n                                                                }\n                                                            }\n                                                        }\n                                                    }\n                                                }\n                                            }\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n    return dst;\n}\n/**\n * Sets the values of a Mat4\n * Also see {@link mat4.create} and {@link mat4.copy}\n *\n * @param v0 - value for element 0\n * @param v1 - value for element 1\n * @param v2 - value for element 2\n * @param v3 - value for element 3\n * @param v4 - value for element 4\n * @param v5 - value for element 5\n * @param v6 - value for element 6\n * @param v7 - value for element 7\n * @param v8 - value for element 8\n * @param v9 - value for element 9\n * @param v10 - value for element 10\n * @param v11 - value for element 11\n * @param v12 - value for element 12\n * @param v13 - value for element 13\n * @param v14 - value for element 14\n * @param v15 - value for element 15\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns Mat4 created from values.\n */\nfunction set$2(v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, dst) {\n    dst = dst || new MatType(16);\n    dst[0] = v0;\n    dst[1] = v1;\n    dst[2] = v2;\n    dst[3] = v3;\n    dst[4] = v4;\n    dst[5] = v5;\n    dst[6] = v6;\n    dst[7] = v7;\n    dst[8] = v8;\n    dst[9] = v9;\n    dst[10] = v10;\n    dst[11] = v11;\n    dst[12] = v12;\n    dst[13] = v13;\n    dst[14] = v14;\n    dst[15] = v15;\n    return dst;\n}\n/**\n * Creates a Mat4 from a Mat3\n * @param m3 - source matrix\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns Mat4 made from m3\n */\nfunction fromMat3(m3, dst) {\n    dst = dst || new MatType(16);\n    dst[0] = m3[0];\n    dst[1] = m3[1];\n    dst[2] = m3[2];\n    dst[3] = 0;\n    dst[4] = m3[4];\n    dst[5] = m3[5];\n    dst[6] = m3[6];\n    dst[7] = 0;\n    dst[8] = m3[8];\n    dst[9] = m3[9];\n    dst[10] = m3[10];\n    dst[11] = 0;\n    dst[12] = 0;\n    dst[13] = 0;\n    dst[14] = 0;\n    dst[15] = 1;\n    return dst;\n}\n/**\n * Creates a Mat4 rotation matrix from a quaternion\n * @param q - quaternion to create matrix from\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns Mat4 made from q\n */\nfunction fromQuat(q, dst) {\n    dst = dst || new MatType(16);\n    const x = q[0];\n    const y = q[1];\n    const z = q[2];\n    const w = q[3];\n    const x2 = x + x;\n    const y2 = y + y;\n    const z2 = z + z;\n    const xx = x * x2;\n    const yx = y * x2;\n    const yy = y * y2;\n    const zx = z * x2;\n    const zy = z * y2;\n    const zz = z * z2;\n    const wx = w * x2;\n    const wy = w * y2;\n    const wz = w * z2;\n    dst[0] = 1 - yy - zz;\n    dst[1] = yx + wz;\n    dst[2] = zx - wy;\n    dst[3] = 0;\n    dst[4] = yx - wz;\n    dst[5] = 1 - xx - zz;\n    dst[6] = zy + wx;\n    dst[7] = 0;\n    dst[8] = zx + wy;\n    dst[9] = zy - wx;\n    dst[10] = 1 - xx - yy;\n    dst[11] = 0;\n    dst[12] = 0;\n    dst[13] = 0;\n    dst[14] = 0;\n    dst[15] = 1;\n    return dst;\n}\n/**\n * Negates a matrix.\n * @param m - The matrix.\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns -m.\n */\nfunction negate$1(m, dst) {\n    dst = dst || new MatType(16);\n    dst[0] = -m[0];\n    dst[1] = -m[1];\n    dst[2] = -m[2];\n    dst[3] = -m[3];\n    dst[4] = -m[4];\n    dst[5] = -m[5];\n    dst[6] = -m[6];\n    dst[7] = -m[7];\n    dst[8] = -m[8];\n    dst[9] = -m[9];\n    dst[10] = -m[10];\n    dst[11] = -m[11];\n    dst[12] = -m[12];\n    dst[13] = -m[13];\n    dst[14] = -m[14];\n    dst[15] = -m[15];\n    return dst;\n}\n/**\n * Copies a matrix. (same as {@link mat4.clone})\n * Also see {@link mat4.create} and {@link mat4.set}\n * @param m - The matrix.\n * @param dst - The matrix. If not passed a new one is created.\n * @returns A copy of m.\n */\nfunction copy$2(m, dst) {\n    dst = dst || new MatType(16);\n    dst[0] = m[0];\n    dst[1] = m[1];\n    dst[2] = m[2];\n    dst[3] = m[3];\n    dst[4] = m[4];\n    dst[5] = m[5];\n    dst[6] = m[6];\n    dst[7] = m[7];\n    dst[8] = m[8];\n    dst[9] = m[9];\n    dst[10] = m[10];\n    dst[11] = m[11];\n    dst[12] = m[12];\n    dst[13] = m[13];\n    dst[14] = m[14];\n    dst[15] = m[15];\n    return dst;\n}\n/**\n * Copies a matrix (same as {@link mat4.copy})\n * Also see {@link mat4.create} and {@link mat4.set}\n * @param m - The matrix.\n * @param dst - The matrix. If not passed a new one is created.\n * @returns A copy of m.\n */\nconst clone$2 = copy$2;\n/**\n * Check if 2 matrices are approximately equal\n * @param a - Operand matrix.\n * @param b - Operand matrix.\n * @returns true if matrices are approximately equal\n */\nfunction equalsApproximately$2(a, b) {\n    return Math.abs(a[0] - b[0]) < EPSILON &&\n        Math.abs(a[1] - b[1]) < EPSILON &&\n        Math.abs(a[2] - b[2]) < EPSILON &&\n        Math.abs(a[3] - b[3]) < EPSILON &&\n        Math.abs(a[4] - b[4]) < EPSILON &&\n        Math.abs(a[5] - b[5]) < EPSILON &&\n        Math.abs(a[6] - b[6]) < EPSILON &&\n        Math.abs(a[7] - b[7]) < EPSILON &&\n        Math.abs(a[8] - b[8]) < EPSILON &&\n        Math.abs(a[9] - b[9]) < EPSILON &&\n        Math.abs(a[10] - b[10]) < EPSILON &&\n        Math.abs(a[11] - b[11]) < EPSILON &&\n        Math.abs(a[12] - b[12]) < EPSILON &&\n        Math.abs(a[13] - b[13]) < EPSILON &&\n        Math.abs(a[14] - b[14]) < EPSILON &&\n        Math.abs(a[15] - b[15]) < EPSILON;\n}\n/**\n * Check if 2 matrices are exactly equal\n * @param a - Operand matrix.\n * @param b - Operand matrix.\n * @returns true if matrices are exactly equal\n */\nfunction equals$2(a, b) {\n    return a[0] === b[0] &&\n        a[1] === b[1] &&\n        a[2] === b[2] &&\n        a[3] === b[3] &&\n        a[4] === b[4] &&\n        a[5] === b[5] &&\n        a[6] === b[6] &&\n        a[7] === b[7] &&\n        a[8] === b[8] &&\n        a[9] === b[9] &&\n        a[10] === b[10] &&\n        a[11] === b[11] &&\n        a[12] === b[12] &&\n        a[13] === b[13] &&\n        a[14] === b[14] &&\n        a[15] === b[15];\n}\n/**\n * Creates a 4-by-4 identity matrix.\n *\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns A 4-by-4 identity matrix.\n */\nfunction identity$1(dst) {\n    dst = dst || new MatType(16);\n    dst[0] = 1;\n    dst[1] = 0;\n    dst[2] = 0;\n    dst[3] = 0;\n    dst[4] = 0;\n    dst[5] = 1;\n    dst[6] = 0;\n    dst[7] = 0;\n    dst[8] = 0;\n    dst[9] = 0;\n    dst[10] = 1;\n    dst[11] = 0;\n    dst[12] = 0;\n    dst[13] = 0;\n    dst[14] = 0;\n    dst[15] = 1;\n    return dst;\n}\n/**\n * Takes the transpose of a matrix.\n * @param m - The matrix.\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns The transpose of m.\n */\nfunction transpose(m, dst) {\n    dst = dst || new MatType(16);\n    if (dst === m) {\n        let t;\n        t = m[1];\n        m[1] = m[4];\n        m[4] = t;\n        t = m[2];\n        m[2] = m[8];\n        m[8] = t;\n        t = m[3];\n        m[3] = m[12];\n        m[12] = t;\n        t = m[6];\n        m[6] = m[9];\n        m[9] = t;\n        t = m[7];\n        m[7] = m[13];\n        m[13] = t;\n        t = m[11];\n        m[11] = m[14];\n        m[14] = t;\n        return dst;\n    }\n    const m00 = m[0 * 4 + 0];\n    const m01 = m[0 * 4 + 1];\n    const m02 = m[0 * 4 + 2];\n    const m03 = m[0 * 4 + 3];\n    const m10 = m[1 * 4 + 0];\n    const m11 = m[1 * 4 + 1];\n    const m12 = m[1 * 4 + 2];\n    const m13 = m[1 * 4 + 3];\n    const m20 = m[2 * 4 + 0];\n    const m21 = m[2 * 4 + 1];\n    const m22 = m[2 * 4 + 2];\n    const m23 = m[2 * 4 + 3];\n    const m30 = m[3 * 4 + 0];\n    const m31 = m[3 * 4 + 1];\n    const m32 = m[3 * 4 + 2];\n    const m33 = m[3 * 4 + 3];\n    dst[0] = m00;\n    dst[1] = m10;\n    dst[2] = m20;\n    dst[3] = m30;\n    dst[4] = m01;\n    dst[5] = m11;\n    dst[6] = m21;\n    dst[7] = m31;\n    dst[8] = m02;\n    dst[9] = m12;\n    dst[10] = m22;\n    dst[11] = m32;\n    dst[12] = m03;\n    dst[13] = m13;\n    dst[14] = m23;\n    dst[15] = m33;\n    return dst;\n}\n/**\n * Computes the inverse of a 4-by-4 matrix.\n * @param m - The matrix.\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns The inverse of m.\n */\nfunction inverse$2(m, dst) {\n    dst = dst || new MatType(16);\n    const m00 = m[0 * 4 + 0];\n    const m01 = m[0 * 4 + 1];\n    const m02 = m[0 * 4 + 2];\n    const m03 = m[0 * 4 + 3];\n    const m10 = m[1 * 4 + 0];\n    const m11 = m[1 * 4 + 1];\n    const m12 = m[1 * 4 + 2];\n    const m13 = m[1 * 4 + 3];\n    const m20 = m[2 * 4 + 0];\n    const m21 = m[2 * 4 + 1];\n    const m22 = m[2 * 4 + 2];\n    const m23 = m[2 * 4 + 3];\n    const m30 = m[3 * 4 + 0];\n    const m31 = m[3 * 4 + 1];\n    const m32 = m[3 * 4 + 2];\n    const m33 = m[3 * 4 + 3];\n    const tmp0 = m22 * m33;\n    const tmp1 = m32 * m23;\n    const tmp2 = m12 * m33;\n    const tmp3 = m32 * m13;\n    const tmp4 = m12 * m23;\n    const tmp5 = m22 * m13;\n    const tmp6 = m02 * m33;\n    const tmp7 = m32 * m03;\n    const tmp8 = m02 * m23;\n    const tmp9 = m22 * m03;\n    const tmp10 = m02 * m13;\n    const tmp11 = m12 * m03;\n    const tmp12 = m20 * m31;\n    const tmp13 = m30 * m21;\n    const tmp14 = m10 * m31;\n    const tmp15 = m30 * m11;\n    const tmp16 = m10 * m21;\n    const tmp17 = m20 * m11;\n    const tmp18 = m00 * m31;\n    const tmp19 = m30 * m01;\n    const tmp20 = m00 * m21;\n    const tmp21 = m20 * m01;\n    const tmp22 = m00 * m11;\n    const tmp23 = m10 * m01;\n    const t0 = (tmp0 * m11 + tmp3 * m21 + tmp4 * m31) -\n        (tmp1 * m11 + tmp2 * m21 + tmp5 * m31);\n    const t1 = (tmp1 * m01 + tmp6 * m21 + tmp9 * m31) -\n        (tmp0 * m01 + tmp7 * m21 + tmp8 * m31);\n    const t2 = (tmp2 * m01 + tmp7 * m11 + tmp10 * m31) -\n        (tmp3 * m01 + tmp6 * m11 + tmp11 * m31);\n    const t3 = (tmp5 * m01 + tmp8 * m11 + tmp11 * m21) -\n        (tmp4 * m01 + tmp9 * m11 + tmp10 * m21);\n    const d = 1 / (m00 * t0 + m10 * t1 + m20 * t2 + m30 * t3);\n    dst[0] = d * t0;\n    dst[1] = d * t1;\n    dst[2] = d * t2;\n    dst[3] = d * t3;\n    dst[4] = d * ((tmp1 * m10 + tmp2 * m20 + tmp5 * m30) -\n        (tmp0 * m10 + tmp3 * m20 + tmp4 * m30));\n    dst[5] = d * ((tmp0 * m00 + tmp7 * m20 + tmp8 * m30) -\n        (tmp1 * m00 + tmp6 * m20 + tmp9 * m30));\n    dst[6] = d * ((tmp3 * m00 + tmp6 * m10 + tmp11 * m30) -\n        (tmp2 * m00 + tmp7 * m10 + tmp10 * m30));\n    dst[7] = d * ((tmp4 * m00 + tmp9 * m10 + tmp10 * m20) -\n        (tmp5 * m00 + tmp8 * m10 + tmp11 * m20));\n    dst[8] = d * ((tmp12 * m13 + tmp15 * m23 + tmp16 * m33) -\n        (tmp13 * m13 + tmp14 * m23 + tmp17 * m33));\n    dst[9] = d * ((tmp13 * m03 + tmp18 * m23 + tmp21 * m33) -\n        (tmp12 * m03 + tmp19 * m23 + tmp20 * m33));\n    dst[10] = d * ((tmp14 * m03 + tmp19 * m13 + tmp22 * m33) -\n        (tmp15 * m03 + tmp18 * m13 + tmp23 * m33));\n    dst[11] = d * ((tmp17 * m03 + tmp20 * m13 + tmp23 * m23) -\n        (tmp16 * m03 + tmp21 * m13 + tmp22 * m23));\n    dst[12] = d * ((tmp14 * m22 + tmp17 * m32 + tmp13 * m12) -\n        (tmp16 * m32 + tmp12 * m12 + tmp15 * m22));\n    dst[13] = d * ((tmp20 * m32 + tmp12 * m02 + tmp19 * m22) -\n        (tmp18 * m22 + tmp21 * m32 + tmp13 * m02));\n    dst[14] = d * ((tmp18 * m12 + tmp23 * m32 + tmp15 * m02) -\n        (tmp22 * m32 + tmp14 * m02 + tmp19 * m12));\n    dst[15] = d * ((tmp22 * m22 + tmp16 * m02 + tmp21 * m12) -\n        (tmp20 * m12 + tmp23 * m22 + tmp17 * m02));\n    return dst;\n}\n/**\n * Compute the determinant of a matrix\n * @param m - the matrix\n * @returns the determinant\n */\nfunction determinant(m) {\n    const m00 = m[0 * 4 + 0];\n    const m01 = m[0 * 4 + 1];\n    const m02 = m[0 * 4 + 2];\n    const m03 = m[0 * 4 + 3];\n    const m10 = m[1 * 4 + 0];\n    const m11 = m[1 * 4 + 1];\n    const m12 = m[1 * 4 + 2];\n    const m13 = m[1 * 4 + 3];\n    const m20 = m[2 * 4 + 0];\n    const m21 = m[2 * 4 + 1];\n    const m22 = m[2 * 4 + 2];\n    const m23 = m[2 * 4 + 3];\n    const m30 = m[3 * 4 + 0];\n    const m31 = m[3 * 4 + 1];\n    const m32 = m[3 * 4 + 2];\n    const m33 = m[3 * 4 + 3];\n    const tmp0 = m22 * m33;\n    const tmp1 = m32 * m23;\n    const tmp2 = m12 * m33;\n    const tmp3 = m32 * m13;\n    const tmp4 = m12 * m23;\n    const tmp5 = m22 * m13;\n    const tmp6 = m02 * m33;\n    const tmp7 = m32 * m03;\n    const tmp8 = m02 * m23;\n    const tmp9 = m22 * m03;\n    const tmp10 = m02 * m13;\n    const tmp11 = m12 * m03;\n    const t0 = (tmp0 * m11 + tmp3 * m21 + tmp4 * m31) -\n        (tmp1 * m11 + tmp2 * m21 + tmp5 * m31);\n    const t1 = (tmp1 * m01 + tmp6 * m21 + tmp9 * m31) -\n        (tmp0 * m01 + tmp7 * m21 + tmp8 * m31);\n    const t2 = (tmp2 * m01 + tmp7 * m11 + tmp10 * m31) -\n        (tmp3 * m01 + tmp6 * m11 + tmp11 * m31);\n    const t3 = (tmp5 * m01 + tmp8 * m11 + tmp11 * m21) -\n        (tmp4 * m01 + tmp9 * m11 + tmp10 * m21);\n    return m00 * t0 + m10 * t1 + m20 * t2 + m30 * t3;\n}\n/**\n * Computes the inverse of a 4-by-4 matrix. (same as inverse)\n * @param m - The matrix.\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns The inverse of m.\n */\nconst invert$1 = inverse$2;\n/**\n * Multiplies two 4-by-4 matrices with a on the left and b on the right\n * @param a - The matrix on the left.\n * @param b - The matrix on the right.\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns The matrix product of a and b.\n */\nfunction multiply$2(a, b, dst) {\n    dst = dst || new MatType(16);\n    const a00 = a[0];\n    const a01 = a[1];\n    const a02 = a[2];\n    const a03 = a[3];\n    const a10 = a[4 + 0];\n    const a11 = a[4 + 1];\n    const a12 = a[4 + 2];\n    const a13 = a[4 + 3];\n    const a20 = a[8 + 0];\n    const a21 = a[8 + 1];\n    const a22 = a[8 + 2];\n    const a23 = a[8 + 3];\n    const a30 = a[12 + 0];\n    const a31 = a[12 + 1];\n    const a32 = a[12 + 2];\n    const a33 = a[12 + 3];\n    const b00 = b[0];\n    const b01 = b[1];\n    const b02 = b[2];\n    const b03 = b[3];\n    const b10 = b[4 + 0];\n    const b11 = b[4 + 1];\n    const b12 = b[4 + 2];\n    const b13 = b[4 + 3];\n    const b20 = b[8 + 0];\n    const b21 = b[8 + 1];\n    const b22 = b[8 + 2];\n    const b23 = b[8 + 3];\n    const b30 = b[12 + 0];\n    const b31 = b[12 + 1];\n    const b32 = b[12 + 2];\n    const b33 = b[12 + 3];\n    dst[0] = a00 * b00 + a10 * b01 + a20 * b02 + a30 * b03;\n    dst[1] = a01 * b00 + a11 * b01 + a21 * b02 + a31 * b03;\n    dst[2] = a02 * b00 + a12 * b01 + a22 * b02 + a32 * b03;\n    dst[3] = a03 * b00 + a13 * b01 + a23 * b02 + a33 * b03;\n    dst[4] = a00 * b10 + a10 * b11 + a20 * b12 + a30 * b13;\n    dst[5] = a01 * b10 + a11 * b11 + a21 * b12 + a31 * b13;\n    dst[6] = a02 * b10 + a12 * b11 + a22 * b12 + a32 * b13;\n    dst[7] = a03 * b10 + a13 * b11 + a23 * b12 + a33 * b13;\n    dst[8] = a00 * b20 + a10 * b21 + a20 * b22 + a30 * b23;\n    dst[9] = a01 * b20 + a11 * b21 + a21 * b22 + a31 * b23;\n    dst[10] = a02 * b20 + a12 * b21 + a22 * b22 + a32 * b23;\n    dst[11] = a03 * b20 + a13 * b21 + a23 * b22 + a33 * b23;\n    dst[12] = a00 * b30 + a10 * b31 + a20 * b32 + a30 * b33;\n    dst[13] = a01 * b30 + a11 * b31 + a21 * b32 + a31 * b33;\n    dst[14] = a02 * b30 + a12 * b31 + a22 * b32 + a32 * b33;\n    dst[15] = a03 * b30 + a13 * b31 + a23 * b32 + a33 * b33;\n    return dst;\n}\n/**\n * Multiplies two 4-by-4 matrices with a on the left and b on the right (same as multiply)\n * @param a - The matrix on the left.\n * @param b - The matrix on the right.\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns The matrix product of a and b.\n */\nconst mul$2 = multiply$2;\n/**\n * Sets the translation component of a 4-by-4 matrix to the given\n * vector.\n * @param a - The matrix.\n * @param v - The vector.\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns The matrix with translation set.\n */\nfunction setTranslation(a, v, dst) {\n    dst = dst || identity$1();\n    if (a !== dst) {\n        dst[0] = a[0];\n        dst[1] = a[1];\n        dst[2] = a[2];\n        dst[3] = a[3];\n        dst[4] = a[4];\n        dst[5] = a[5];\n        dst[6] = a[6];\n        dst[7] = a[7];\n        dst[8] = a[8];\n        dst[9] = a[9];\n        dst[10] = a[10];\n        dst[11] = a[11];\n    }\n    dst[12] = v[0];\n    dst[13] = v[1];\n    dst[14] = v[2];\n    dst[15] = 1;\n    return dst;\n}\n/**\n * Returns the translation component of a 4-by-4 matrix as a vector with 3\n * entries.\n * @param m - The matrix.\n * @param dst - vector to hold result. If not passed a new one is created.\n * @returns The translation component of m.\n */\nfunction getTranslation(m, dst) {\n    dst = dst || create$3();\n    dst[0] = m[12];\n    dst[1] = m[13];\n    dst[2] = m[14];\n    return dst;\n}\n/**\n * Returns an axis of a 4x4 matrix as a vector with 3 entries\n * @param m - The matrix.\n * @param axis - The axis 0 = x, 1 = y, 2 = z;\n * @returns The axis component of m.\n */\nfunction getAxis(m, axis, dst) {\n    dst = dst || create$3();\n    const off = axis * 4;\n    dst[0] = m[off + 0];\n    dst[1] = m[off + 1];\n    dst[2] = m[off + 2];\n    return dst;\n}\n/**\n * Sets an axis of a 4x4 matrix as a vector with 3 entries\n * @param m - The matrix.\n * @param v - the axis vector\n * @param axis - The axis  0 = x, 1 = y, 2 = z;\n * @param dst - The matrix to set. If not passed a new one is created.\n * @returns The matrix with axis set.\n */\nfunction setAxis(a, v, axis, dst) {\n    if (dst !== a) {\n        dst = copy$2(a, dst);\n    }\n    const off = axis * 4;\n    dst[off + 0] = v[0];\n    dst[off + 1] = v[1];\n    dst[off + 2] = v[2];\n    return dst;\n}\n/**\n * Returns the scaling component of the matrix\n * @param m - The Matrix\n * @param dst - The vector to set. If not passed a new one is created.\n */\nfunction getScaling(m, dst) {\n    dst = dst || create$3();\n    const xx = m[0];\n    const xy = m[1];\n    const xz = m[2];\n    const yx = m[4];\n    const yy = m[5];\n    const yz = m[6];\n    const zx = m[8];\n    const zy = m[9];\n    const zz = m[10];\n    dst[0] = Math.sqrt(xx * xx + xy * xy + xz * xz);\n    dst[1] = Math.sqrt(yx * yx + yy * yy + yz * yz);\n    dst[2] = Math.sqrt(zx * zx + zy * zy + zz * zz);\n    return dst;\n}\n/**\n * Computes a 4-by-4 perspective transformation matrix given the angular height\n * of the frustum, the aspect ratio, and the near and far clipping planes.  The\n * arguments define a frustum extending in the negative z direction.  The given\n * angle is the vertical angle of the frustum, and the horizontal angle is\n * determined to produce the given aspect ratio.  The arguments near and far are\n * the distances to the near and far clipping planes.  Note that near and far\n * are not z coordinates, but rather they are distances along the negative\n * z-axis.  The matrix generated sends the viewing frustum to the unit box.\n * We assume a unit box extending from -1 to 1 in the x and y dimensions and\n * from 0 to 1 in the z dimension.\n *\n * Note: If you pass `Infinity` for zFar then it will produce a projection matrix\n * returns -Infinity for Z when transforming coordinates with Z <= 0 and +Infinity for Z\n * otherwise.\n *\n * @param fieldOfViewYInRadians - The camera angle from top to bottom (in radians).\n * @param aspect - The aspect ratio width / height.\n * @param zNear - The depth (negative z coordinate)\n *     of the near clipping plane.\n * @param zFar - The depth (negative z coordinate)\n *     of the far clipping plane.\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns The perspective matrix.\n */\nfunction perspective(fieldOfViewYInRadians, aspect, zNear, zFar, dst) {\n    dst = dst || new MatType(16);\n    const f = Math.tan(Math.PI * 0.5 - 0.5 * fieldOfViewYInRadians);\n    dst[0] = f / aspect;\n    dst[1] = 0;\n    dst[2] = 0;\n    dst[3] = 0;\n    dst[4] = 0;\n    dst[5] = f;\n    dst[6] = 0;\n    dst[7] = 0;\n    dst[8] = 0;\n    dst[9] = 0;\n    dst[11] = -1;\n    dst[12] = 0;\n    dst[13] = 0;\n    dst[15] = 0;\n    if (zFar === Infinity) {\n        dst[10] = -1;\n        dst[14] = -zNear;\n    }\n    else {\n        const rangeInv = 1 / (zNear - zFar);\n        dst[10] = zFar * rangeInv;\n        dst[14] = zFar * zNear * rangeInv;\n    }\n    return dst;\n}\n/**\n * Computes a 4-by-4 orthogonal transformation matrix that transforms from\n * the given the left, right, bottom, and top dimensions to -1 +1 in x, and y\n * and 0 to +1 in z.\n * @param left - Left side of the near clipping plane viewport.\n * @param right - Right side of the near clipping plane viewport.\n * @param bottom - Bottom of the near clipping plane viewport.\n * @param top - Top of the near clipping plane viewport.\n * @param near - The depth (negative z coordinate)\n *     of the near clipping plane.\n * @param far - The depth (negative z coordinate)\n *     of the far clipping plane.\n * @param dst - Output matrix. If not passed a new one is created.\n * @returns The orthographic projection matrix.\n */\nfunction ortho(left, right, bottom, top, near, far, dst) {\n    dst = dst || new MatType(16);\n    dst[0] = 2 / (right - left);\n    dst[1] = 0;\n    dst[2] = 0;\n    dst[3] = 0;\n    dst[4] = 0;\n    dst[5] = 2 / (top - bottom);\n    dst[6] = 0;\n    dst[7] = 0;\n    dst[8] = 0;\n    dst[9] = 0;\n    dst[10] = 1 / (near - far);\n    dst[11] = 0;\n    dst[12] = (right + left) / (left - right);\n    dst[13] = (top + bottom) / (bottom - top);\n    dst[14] = near / (near - far);\n    dst[15] = 1;\n    return dst;\n}\n/**\n * Computes a 4-by-4 perspective transformation matrix given the left, right,\n * top, bottom, near and far clipping planes. The arguments define a frustum\n * extending in the negative z direction. The arguments near and far are the\n * distances to the near and far clipping planes. Note that near and far are not\n * z coordinates, but rather they are distances along the negative z-axis. The\n * matrix generated sends the viewing frustum to the unit box. We assume a unit\n * box extending from -1 to 1 in the x and y dimensions and from 0 to 1 in the z\n * dimension.\n * @param left - The x coordinate of the left plane of the box.\n * @param right - The x coordinate of the right plane of the box.\n * @param bottom - The y coordinate of the bottom plane of the box.\n * @param top - The y coordinate of the right plane of the box.\n * @param near - The negative z coordinate of the near plane of the box.\n * @param far - The negative z coordinate of the far plane of the box.\n * @param dst - Output matrix. If not passed a new one is created.\n * @returns The perspective projection matrix.\n */\nfunction frustum(left, right, bottom, top, near, far, dst) {\n    dst = dst || new MatType(16);\n    const dx = (right - left);\n    const dy = (top - bottom);\n    const dz = (near - far);\n    dst[0] = 2 * near / dx;\n    dst[1] = 0;\n    dst[2] = 0;\n    dst[3] = 0;\n    dst[4] = 0;\n    dst[5] = 2 * near / dy;\n    dst[6] = 0;\n    dst[7] = 0;\n    dst[8] = (left + right) / dx;\n    dst[9] = (top + bottom) / dy;\n    dst[10] = far / dz;\n    dst[11] = -1;\n    dst[12] = 0;\n    dst[13] = 0;\n    dst[14] = near * far / dz;\n    dst[15] = 0;\n    return dst;\n}\nlet xAxis;\nlet yAxis;\nlet zAxis;\n/**\n * Computes a 4-by-4 aim transformation.\n *\n * This is a matrix which positions an object aiming down positive Z.\n * toward the target.\n *\n * Note: this is **NOT** the inverse of lookAt as lookAt looks at negative Z.\n *\n * @param position - The position of the object.\n * @param target - The position meant to be aimed at.\n * @param up - A vector pointing up.\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns The aim matrix.\n */\nfunction aim(position, target, up, dst) {\n    dst = dst || new MatType(16);\n    xAxis = xAxis || create$3();\n    yAxis = yAxis || create$3();\n    zAxis = zAxis || create$3();\n    normalize$2(subtract$2(target, position, zAxis), zAxis);\n    normalize$2(cross(up, zAxis, xAxis), xAxis);\n    normalize$2(cross(zAxis, xAxis, yAxis), yAxis);\n    dst[0] = xAxis[0];\n    dst[1] = xAxis[1];\n    dst[2] = xAxis[2];\n    dst[3] = 0;\n    dst[4] = yAxis[0];\n    dst[5] = yAxis[1];\n    dst[6] = yAxis[2];\n    dst[7] = 0;\n    dst[8] = zAxis[0];\n    dst[9] = zAxis[1];\n    dst[10] = zAxis[2];\n    dst[11] = 0;\n    dst[12] = position[0];\n    dst[13] = position[1];\n    dst[14] = position[2];\n    dst[15] = 1;\n    return dst;\n}\n/**\n * Computes a 4-by-4 camera aim transformation.\n *\n * This is a matrix which positions an object aiming down negative Z.\n * toward the target.\n *\n * Note: this is the inverse of `lookAt`\n *\n * @param eye - The position of the object.\n * @param target - The position meant to be aimed at.\n * @param up - A vector pointing up.\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns The aim matrix.\n */\nfunction cameraAim(eye, target, up, dst) {\n    dst = dst || new MatType(16);\n    xAxis = xAxis || create$3();\n    yAxis = yAxis || create$3();\n    zAxis = zAxis || create$3();\n    normalize$2(subtract$2(eye, target, zAxis), zAxis);\n    normalize$2(cross(up, zAxis, xAxis), xAxis);\n    normalize$2(cross(zAxis, xAxis, yAxis), yAxis);\n    dst[0] = xAxis[0];\n    dst[1] = xAxis[1];\n    dst[2] = xAxis[2];\n    dst[3] = 0;\n    dst[4] = yAxis[0];\n    dst[5] = yAxis[1];\n    dst[6] = yAxis[2];\n    dst[7] = 0;\n    dst[8] = zAxis[0];\n    dst[9] = zAxis[1];\n    dst[10] = zAxis[2];\n    dst[11] = 0;\n    dst[12] = eye[0];\n    dst[13] = eye[1];\n    dst[14] = eye[2];\n    dst[15] = 1;\n    return dst;\n}\n/**\n * Computes a 4-by-4 view transformation.\n *\n * This is a view matrix which transforms all other objects\n * to be in the space of the view defined by the parameters.\n *\n * @param eye - The position of the object.\n * @param target - The position meant to be aimed at.\n * @param up - A vector pointing up.\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns The look-at matrix.\n */\nfunction lookAt(eye, target, up, dst) {\n    dst = dst || new MatType(16);\n    xAxis = xAxis || create$3();\n    yAxis = yAxis || create$3();\n    zAxis = zAxis || create$3();\n    normalize$2(subtract$2(eye, target, zAxis), zAxis);\n    normalize$2(cross(up, zAxis, xAxis), xAxis);\n    normalize$2(cross(zAxis, xAxis, yAxis), yAxis);\n    dst[0] = xAxis[0];\n    dst[1] = yAxis[0];\n    dst[2] = zAxis[0];\n    dst[3] = 0;\n    dst[4] = xAxis[1];\n    dst[5] = yAxis[1];\n    dst[6] = zAxis[1];\n    dst[7] = 0;\n    dst[8] = xAxis[2];\n    dst[9] = yAxis[2];\n    dst[10] = zAxis[2];\n    dst[11] = 0;\n    dst[12] = -(xAxis[0] * eye[0] + xAxis[1] * eye[1] + xAxis[2] * eye[2]);\n    dst[13] = -(yAxis[0] * eye[0] + yAxis[1] * eye[1] + yAxis[2] * eye[2]);\n    dst[14] = -(zAxis[0] * eye[0] + zAxis[1] * eye[1] + zAxis[2] * eye[2]);\n    dst[15] = 1;\n    return dst;\n}\n/**\n * Creates a 4-by-4 matrix which translates by the given vector v.\n * @param v - The vector by\n *     which to translate.\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns The translation matrix.\n */\nfunction translation(v, dst) {\n    dst = dst || new MatType(16);\n    dst[0] = 1;\n    dst[1] = 0;\n    dst[2] = 0;\n    dst[3] = 0;\n    dst[4] = 0;\n    dst[5] = 1;\n    dst[6] = 0;\n    dst[7] = 0;\n    dst[8] = 0;\n    dst[9] = 0;\n    dst[10] = 1;\n    dst[11] = 0;\n    dst[12] = v[0];\n    dst[13] = v[1];\n    dst[14] = v[2];\n    dst[15] = 1;\n    return dst;\n}\n/**\n * Translates the given 4-by-4 matrix by the given vector v.\n * @param m - The matrix.\n * @param v - The vector by\n *     which to translate.\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns The translated matrix.\n */\nfunction translate(m, v, dst) {\n    dst = dst || new MatType(16);\n    const v0 = v[0];\n    const v1 = v[1];\n    const v2 = v[2];\n    const m00 = m[0];\n    const m01 = m[1];\n    const m02 = m[2];\n    const m03 = m[3];\n    const m10 = m[1 * 4 + 0];\n    const m11 = m[1 * 4 + 1];\n    const m12 = m[1 * 4 + 2];\n    const m13 = m[1 * 4 + 3];\n    const m20 = m[2 * 4 + 0];\n    const m21 = m[2 * 4 + 1];\n    const m22 = m[2 * 4 + 2];\n    const m23 = m[2 * 4 + 3];\n    const m30 = m[3 * 4 + 0];\n    const m31 = m[3 * 4 + 1];\n    const m32 = m[3 * 4 + 2];\n    const m33 = m[3 * 4 + 3];\n    if (m !== dst) {\n        dst[0] = m00;\n        dst[1] = m01;\n        dst[2] = m02;\n        dst[3] = m03;\n        dst[4] = m10;\n        dst[5] = m11;\n        dst[6] = m12;\n        dst[7] = m13;\n        dst[8] = m20;\n        dst[9] = m21;\n        dst[10] = m22;\n        dst[11] = m23;\n    }\n    dst[12] = m00 * v0 + m10 * v1 + m20 * v2 + m30;\n    dst[13] = m01 * v0 + m11 * v1 + m21 * v2 + m31;\n    dst[14] = m02 * v0 + m12 * v1 + m22 * v2 + m32;\n    dst[15] = m03 * v0 + m13 * v1 + m23 * v2 + m33;\n    return dst;\n}\n/**\n * Creates a 4-by-4 matrix which rotates around the x-axis by the given angle.\n * @param angleInRadians - The angle by which to rotate (in radians).\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns The rotation matrix.\n */\nfunction rotationX(angleInRadians, dst) {\n    dst = dst || new MatType(16);\n    const c = Math.cos(angleInRadians);\n    const s = Math.sin(angleInRadians);\n    dst[0] = 1;\n    dst[1] = 0;\n    dst[2] = 0;\n    dst[3] = 0;\n    dst[4] = 0;\n    dst[5] = c;\n    dst[6] = s;\n    dst[7] = 0;\n    dst[8] = 0;\n    dst[9] = -s;\n    dst[10] = c;\n    dst[11] = 0;\n    dst[12] = 0;\n    dst[13] = 0;\n    dst[14] = 0;\n    dst[15] = 1;\n    return dst;\n}\n/**\n * Rotates the given 4-by-4 matrix around the x-axis by the given\n * angle.\n * @param m - The matrix.\n * @param angleInRadians - The angle by which to rotate (in radians).\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns The rotated matrix.\n */\nfunction rotateX$1(m, angleInRadians, dst) {\n    dst = dst || new MatType(16);\n    const m10 = m[4];\n    const m11 = m[5];\n    const m12 = m[6];\n    const m13 = m[7];\n    const m20 = m[8];\n    const m21 = m[9];\n    const m22 = m[10];\n    const m23 = m[11];\n    const c = Math.cos(angleInRadians);\n    const s = Math.sin(angleInRadians);\n    dst[4] = c * m10 + s * m20;\n    dst[5] = c * m11 + s * m21;\n    dst[6] = c * m12 + s * m22;\n    dst[7] = c * m13 + s * m23;\n    dst[8] = c * m20 - s * m10;\n    dst[9] = c * m21 - s * m11;\n    dst[10] = c * m22 - s * m12;\n    dst[11] = c * m23 - s * m13;\n    if (m !== dst) {\n        dst[0] = m[0];\n        dst[1] = m[1];\n        dst[2] = m[2];\n        dst[3] = m[3];\n        dst[12] = m[12];\n        dst[13] = m[13];\n        dst[14] = m[14];\n        dst[15] = m[15];\n    }\n    return dst;\n}\n/**\n * Creates a 4-by-4 matrix which rotates around the y-axis by the given angle.\n * @param angleInRadians - The angle by which to rotate (in radians).\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns The rotation matrix.\n */\nfunction rotationY(angleInRadians, dst) {\n    dst = dst || new MatType(16);\n    const c = Math.cos(angleInRadians);\n    const s = Math.sin(angleInRadians);\n    dst[0] = c;\n    dst[1] = 0;\n    dst[2] = -s;\n    dst[3] = 0;\n    dst[4] = 0;\n    dst[5] = 1;\n    dst[6] = 0;\n    dst[7] = 0;\n    dst[8] = s;\n    dst[9] = 0;\n    dst[10] = c;\n    dst[11] = 0;\n    dst[12] = 0;\n    dst[13] = 0;\n    dst[14] = 0;\n    dst[15] = 1;\n    return dst;\n}\n/**\n * Rotates the given 4-by-4 matrix around the y-axis by the given\n * angle.\n * @param m - The matrix.\n * @param angleInRadians - The angle by which to rotate (in radians).\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns The rotated matrix.\n */\nfunction rotateY$1(m, angleInRadians, dst) {\n    dst = dst || new MatType(16);\n    const m00 = m[0 * 4 + 0];\n    const m01 = m[0 * 4 + 1];\n    const m02 = m[0 * 4 + 2];\n    const m03 = m[0 * 4 + 3];\n    const m20 = m[2 * 4 + 0];\n    const m21 = m[2 * 4 + 1];\n    const m22 = m[2 * 4 + 2];\n    const m23 = m[2 * 4 + 3];\n    const c = Math.cos(angleInRadians);\n    const s = Math.sin(angleInRadians);\n    dst[0] = c * m00 - s * m20;\n    dst[1] = c * m01 - s * m21;\n    dst[2] = c * m02 - s * m22;\n    dst[3] = c * m03 - s * m23;\n    dst[8] = c * m20 + s * m00;\n    dst[9] = c * m21 + s * m01;\n    dst[10] = c * m22 + s * m02;\n    dst[11] = c * m23 + s * m03;\n    if (m !== dst) {\n        dst[4] = m[4];\n        dst[5] = m[5];\n        dst[6] = m[6];\n        dst[7] = m[7];\n        dst[12] = m[12];\n        dst[13] = m[13];\n        dst[14] = m[14];\n        dst[15] = m[15];\n    }\n    return dst;\n}\n/**\n * Creates a 4-by-4 matrix which rotates around the z-axis by the given angle.\n * @param angleInRadians - The angle by which to rotate (in radians).\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns The rotation matrix.\n */\nfunction rotationZ(angleInRadians, dst) {\n    dst = dst || new MatType(16);\n    const c = Math.cos(angleInRadians);\n    const s = Math.sin(angleInRadians);\n    dst[0] = c;\n    dst[1] = s;\n    dst[2] = 0;\n    dst[3] = 0;\n    dst[4] = -s;\n    dst[5] = c;\n    dst[6] = 0;\n    dst[7] = 0;\n    dst[8] = 0;\n    dst[9] = 0;\n    dst[10] = 1;\n    dst[11] = 0;\n    dst[12] = 0;\n    dst[13] = 0;\n    dst[14] = 0;\n    dst[15] = 1;\n    return dst;\n}\n/**\n * Rotates the given 4-by-4 matrix around the z-axis by the given\n * angle.\n * @param m - The matrix.\n * @param angleInRadians - The angle by which to rotate (in radians).\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns The rotated matrix.\n */\nfunction rotateZ$1(m, angleInRadians, dst) {\n    dst = dst || new MatType(16);\n    const m00 = m[0 * 4 + 0];\n    const m01 = m[0 * 4 + 1];\n    const m02 = m[0 * 4 + 2];\n    const m03 = m[0 * 4 + 3];\n    const m10 = m[1 * 4 + 0];\n    const m11 = m[1 * 4 + 1];\n    const m12 = m[1 * 4 + 2];\n    const m13 = m[1 * 4 + 3];\n    const c = Math.cos(angleInRadians);\n    const s = Math.sin(angleInRadians);\n    dst[0] = c * m00 + s * m10;\n    dst[1] = c * m01 + s * m11;\n    dst[2] = c * m02 + s * m12;\n    dst[3] = c * m03 + s * m13;\n    dst[4] = c * m10 - s * m00;\n    dst[5] = c * m11 - s * m01;\n    dst[6] = c * m12 - s * m02;\n    dst[7] = c * m13 - s * m03;\n    if (m !== dst) {\n        dst[8] = m[8];\n        dst[9] = m[9];\n        dst[10] = m[10];\n        dst[11] = m[11];\n        dst[12] = m[12];\n        dst[13] = m[13];\n        dst[14] = m[14];\n        dst[15] = m[15];\n    }\n    return dst;\n}\n/**\n * Creates a 4-by-4 matrix which rotates around the given axis by the given\n * angle.\n * @param axis - The axis\n *     about which to rotate.\n * @param angleInRadians - The angle by which to rotate (in radians).\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns A matrix which rotates angle radians\n *     around the axis.\n */\nfunction axisRotation(axis, angleInRadians, dst) {\n    dst = dst || new MatType(16);\n    let x = axis[0];\n    let y = axis[1];\n    let z = axis[2];\n    const n = Math.sqrt(x * x + y * y + z * z);\n    x /= n;\n    y /= n;\n    z /= n;\n    const xx = x * x;\n    const yy = y * y;\n    const zz = z * z;\n    const c = Math.cos(angleInRadians);\n    const s = Math.sin(angleInRadians);\n    const oneMinusCosine = 1 - c;\n    dst[0] = xx + (1 - xx) * c;\n    dst[1] = x * y * oneMinusCosine + z * s;\n    dst[2] = x * z * oneMinusCosine - y * s;\n    dst[3] = 0;\n    dst[4] = x * y * oneMinusCosine - z * s;\n    dst[5] = yy + (1 - yy) * c;\n    dst[6] = y * z * oneMinusCosine + x * s;\n    dst[7] = 0;\n    dst[8] = x * z * oneMinusCosine + y * s;\n    dst[9] = y * z * oneMinusCosine - x * s;\n    dst[10] = zz + (1 - zz) * c;\n    dst[11] = 0;\n    dst[12] = 0;\n    dst[13] = 0;\n    dst[14] = 0;\n    dst[15] = 1;\n    return dst;\n}\n/**\n * Creates a 4-by-4 matrix which rotates around the given axis by the given\n * angle. (same as axisRotation)\n * @param axis - The axis\n *     about which to rotate.\n * @param angleInRadians - The angle by which to rotate (in radians).\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns A matrix which rotates angle radians\n *     around the axis.\n */\nconst rotation = axisRotation;\n/**\n * Rotates the given 4-by-4 matrix around the given axis by the\n * given angle.\n * @param m - The matrix.\n * @param axis - The axis\n *     about which to rotate.\n * @param angleInRadians - The angle by which to rotate (in radians).\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns The rotated matrix.\n */\nfunction axisRotate(m, axis, angleInRadians, dst) {\n    dst = dst || new MatType(16);\n    let x = axis[0];\n    let y = axis[1];\n    let z = axis[2];\n    const n = Math.sqrt(x * x + y * y + z * z);\n    x /= n;\n    y /= n;\n    z /= n;\n    const xx = x * x;\n    const yy = y * y;\n    const zz = z * z;\n    const c = Math.cos(angleInRadians);\n    const s = Math.sin(angleInRadians);\n    const oneMinusCosine = 1 - c;\n    const r00 = xx + (1 - xx) * c;\n    const r01 = x * y * oneMinusCosine + z * s;\n    const r02 = x * z * oneMinusCosine - y * s;\n    const r10 = x * y * oneMinusCosine - z * s;\n    const r11 = yy + (1 - yy) * c;\n    const r12 = y * z * oneMinusCosine + x * s;\n    const r20 = x * z * oneMinusCosine + y * s;\n    const r21 = y * z * oneMinusCosine - x * s;\n    const r22 = zz + (1 - zz) * c;\n    const m00 = m[0];\n    const m01 = m[1];\n    const m02 = m[2];\n    const m03 = m[3];\n    const m10 = m[4];\n    const m11 = m[5];\n    const m12 = m[6];\n    const m13 = m[7];\n    const m20 = m[8];\n    const m21 = m[9];\n    const m22 = m[10];\n    const m23 = m[11];\n    dst[0] = r00 * m00 + r01 * m10 + r02 * m20;\n    dst[1] = r00 * m01 + r01 * m11 + r02 * m21;\n    dst[2] = r00 * m02 + r01 * m12 + r02 * m22;\n    dst[3] = r00 * m03 + r01 * m13 + r02 * m23;\n    dst[4] = r10 * m00 + r11 * m10 + r12 * m20;\n    dst[5] = r10 * m01 + r11 * m11 + r12 * m21;\n    dst[6] = r10 * m02 + r11 * m12 + r12 * m22;\n    dst[7] = r10 * m03 + r11 * m13 + r12 * m23;\n    dst[8] = r20 * m00 + r21 * m10 + r22 * m20;\n    dst[9] = r20 * m01 + r21 * m11 + r22 * m21;\n    dst[10] = r20 * m02 + r21 * m12 + r22 * m22;\n    dst[11] = r20 * m03 + r21 * m13 + r22 * m23;\n    if (m !== dst) {\n        dst[12] = m[12];\n        dst[13] = m[13];\n        dst[14] = m[14];\n        dst[15] = m[15];\n    }\n    return dst;\n}\n/**\n * Rotates the given 4-by-4 matrix around the given axis by the\n * given angle. (same as rotate)\n * @param m - The matrix.\n * @param axis - The axis\n *     about which to rotate.\n * @param angleInRadians - The angle by which to rotate (in radians).\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns The rotated matrix.\n */\nconst rotate = axisRotate;\n/**\n * Creates a 4-by-4 matrix which scales in each dimension by an amount given by\n * the corresponding entry in the given vector; assumes the vector has three\n * entries.\n * @param v - A vector of\n *     three entries specifying the factor by which to scale in each dimension.\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns The scaling matrix.\n */\nfunction scaling(v, dst) {\n    dst = dst || new MatType(16);\n    dst[0] = v[0];\n    dst[1] = 0;\n    dst[2] = 0;\n    dst[3] = 0;\n    dst[4] = 0;\n    dst[5] = v[1];\n    dst[6] = 0;\n    dst[7] = 0;\n    dst[8] = 0;\n    dst[9] = 0;\n    dst[10] = v[2];\n    dst[11] = 0;\n    dst[12] = 0;\n    dst[13] = 0;\n    dst[14] = 0;\n    dst[15] = 1;\n    return dst;\n}\n/**\n * Scales the given 4-by-4 matrix in each dimension by an amount\n * given by the corresponding entry in the given vector; assumes the vector has\n * three entries.\n * @param m - The matrix to be modified.\n * @param v - A vector of three entries specifying the\n *     factor by which to scale in each dimension.\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns The scaled matrix.\n */\nfunction scale$2(m, v, dst) {\n    dst = dst || new MatType(16);\n    const v0 = v[0];\n    const v1 = v[1];\n    const v2 = v[2];\n    dst[0] = v0 * m[0 * 4 + 0];\n    dst[1] = v0 * m[0 * 4 + 1];\n    dst[2] = v0 * m[0 * 4 + 2];\n    dst[3] = v0 * m[0 * 4 + 3];\n    dst[4] = v1 * m[1 * 4 + 0];\n    dst[5] = v1 * m[1 * 4 + 1];\n    dst[6] = v1 * m[1 * 4 + 2];\n    dst[7] = v1 * m[1 * 4 + 3];\n    dst[8] = v2 * m[2 * 4 + 0];\n    dst[9] = v2 * m[2 * 4 + 1];\n    dst[10] = v2 * m[2 * 4 + 2];\n    dst[11] = v2 * m[2 * 4 + 3];\n    if (m !== dst) {\n        dst[12] = m[12];\n        dst[13] = m[13];\n        dst[14] = m[14];\n        dst[15] = m[15];\n    }\n    return dst;\n}\n/**\n * Creates a 4-by-4 matrix which scales a uniform amount in each dimension.\n * @param s - the amount to scale\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns The scaling matrix.\n */\nfunction uniformScaling(s, dst) {\n    dst = dst || new MatType(16);\n    dst[0] = s;\n    dst[1] = 0;\n    dst[2] = 0;\n    dst[3] = 0;\n    dst[4] = 0;\n    dst[5] = s;\n    dst[6] = 0;\n    dst[7] = 0;\n    dst[8] = 0;\n    dst[9] = 0;\n    dst[10] = s;\n    dst[11] = 0;\n    dst[12] = 0;\n    dst[13] = 0;\n    dst[14] = 0;\n    dst[15] = 1;\n    return dst;\n}\n/**\n * Scales the given 4-by-4 matrix in each dimension by a uniform scale.\n * @param m - The matrix to be modified.\n * @param s - The amount to scale.\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns The scaled matrix.\n */\nfunction uniformScale(m, s, dst) {\n    dst = dst || new MatType(16);\n    dst[0] = s * m[0 * 4 + 0];\n    dst[1] = s * m[0 * 4 + 1];\n    dst[2] = s * m[0 * 4 + 2];\n    dst[3] = s * m[0 * 4 + 3];\n    dst[4] = s * m[1 * 4 + 0];\n    dst[5] = s * m[1 * 4 + 1];\n    dst[6] = s * m[1 * 4 + 2];\n    dst[7] = s * m[1 * 4 + 3];\n    dst[8] = s * m[2 * 4 + 0];\n    dst[9] = s * m[2 * 4 + 1];\n    dst[10] = s * m[2 * 4 + 2];\n    dst[11] = s * m[2 * 4 + 3];\n    if (m !== dst) {\n        dst[12] = m[12];\n        dst[13] = m[13];\n        dst[14] = m[14];\n        dst[15] = m[15];\n    }\n    return dst;\n}\n\nvar mat4Impl = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    setDefaultType: setDefaultType$3,\n    create: create$2,\n    set: set$2,\n    fromMat3: fromMat3,\n    fromQuat: fromQuat,\n    negate: negate$1,\n    copy: copy$2,\n    clone: clone$2,\n    equalsApproximately: equalsApproximately$2,\n    equals: equals$2,\n    identity: identity$1,\n    transpose: transpose,\n    inverse: inverse$2,\n    determinant: determinant,\n    invert: invert$1,\n    multiply: multiply$2,\n    mul: mul$2,\n    setTranslation: setTranslation,\n    getTranslation: getTranslation,\n    getAxis: getAxis,\n    setAxis: setAxis,\n    getScaling: getScaling,\n    perspective: perspective,\n    ortho: ortho,\n    frustum: frustum,\n    aim: aim,\n    cameraAim: cameraAim,\n    lookAt: lookAt,\n    translation: translation,\n    translate: translate,\n    rotationX: rotationX,\n    rotateX: rotateX$1,\n    rotationY: rotationY,\n    rotateY: rotateY$1,\n    rotationZ: rotationZ,\n    rotateZ: rotateZ$1,\n    axisRotation: axisRotation,\n    rotation: rotation,\n    axisRotate: axisRotate,\n    rotate: rotate,\n    scaling: scaling,\n    scale: scale$2,\n    uniformScaling: uniformScaling,\n    uniformScale: uniformScale\n});\n\n/*\n * Copyright 2022 Gregg Tavares\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL\n * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n/**\n *\n * Quat4 math functions.\n *\n * Almost all functions take an optional `dst` argument. If it is not passed in the\n * functions will create a new `Quat4`. In other words you can do this\n *\n *     const v = quat4.cross(v1, v2);  // Creates a new Quat4 with the cross product of v1 x v2.\n *\n * or\n *\n *     const v = quat4.create();\n *     quat4.cross(v1, v2, v);  // Puts the cross product of v1 x v2 in v\n *\n * The first style is often easier but depending on where it's used it generates garbage where\n * as there is almost never allocation with the second style.\n *\n * It is always safe to pass any vector as the destination. So for example\n *\n *     quat4.cross(v1, v2, v1);  // Puts the cross product of v1 x v2 in v1\n *\n */\nlet QuatType = Float32Array;\n/**\n * Sets the type this library creates for a Quat4\n * @param ctor - the constructor for the type. Either `Float32Array`, `Float64Array`, or `Array`\n * @returns previous constructor for Quat4\n */\nfunction setDefaultType$2(ctor) {\n    const oldType = QuatType;\n    QuatType = ctor;\n    return oldType;\n}\n/**\n * Creates a quat4; may be called with x, y, z to set initial values.\n * @param x - Initial x value.\n * @param y - Initial y value.\n * @param z - Initial z value.\n * @param w - Initial w value.\n * @returns the created vector\n */\nfunction create$1(x, y, z, w) {\n    const dst = new QuatType(4);\n    if (x !== undefined) {\n        dst[0] = x;\n        if (y !== undefined) {\n            dst[1] = y;\n            if (z !== undefined) {\n                dst[2] = z;\n                if (w !== undefined) {\n                    dst[3] = w;\n                }\n            }\n        }\n    }\n    return dst;\n}\n\n/*\n * Copyright 2022 Gregg Tavares\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL\n * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n/**\n * Creates a Quat; may be called with x, y, z to set initial values. (same as create)\n * @param x - Initial x value.\n * @param y - Initial y value.\n * @param z - Initial z value.\n * @param z - Initial w value.\n * @returns the created vector\n */\nconst fromValues$1 = create$1;\n/**\n * Sets the values of a Quat\n * Also see {@link quat.create} and {@link quat.copy}\n *\n * @param x first value\n * @param y second value\n * @param z third value\n * @param w fourth value\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns A vector with its elements set.\n */\nfunction set$1(x, y, z, w, dst) {\n    dst = dst || new QuatType(4);\n    dst[0] = x;\n    dst[1] = y;\n    dst[2] = z;\n    dst[3] = w;\n    return dst;\n}\n/**\n * Sets a quaternion from the given angle and  axis,\n * then returns it.\n *\n * @param axis - the axis to rotate around\n * @param angleInRadians - the angle\n * @param dst - quaternion to hold result. If not passed in a new one is created.\n * @returns The quaternion that represents the given axis and angle\n **/\nfunction fromAxisAngle(axis, angleInRadians, dst) {\n    dst = dst || new QuatType(4);\n    const halfAngle = angleInRadians * 0.5;\n    const s = Math.sin(halfAngle);\n    dst[0] = s * axis[0];\n    dst[1] = s * axis[1];\n    dst[2] = s * axis[2];\n    dst[3] = Math.cos(halfAngle);\n    return dst;\n}\n/**\n * Gets the rotation axis and angle\n * @param q - quaternion to compute from\n * @param dst - Vec3 to hold result. If not passed in a new one is created.\n * @return angle and axis\n */\nfunction toAxisAngle(q, dst) {\n    dst = dst || create$3(4);\n    const angle = Math.acos(q[3]) * 2;\n    const s = Math.sin(angle * 0.5);\n    if (s > EPSILON) {\n        dst[0] = q[0] / s;\n        dst[1] = q[1] / s;\n        dst[2] = q[2] / s;\n    }\n    else {\n        dst[0] = 1;\n        dst[1] = 0;\n        dst[2] = 0;\n    }\n    return { angle, axis: dst };\n}\n/**\n * Returns the angle in degrees between two rotations a and b.\n * @param a - quaternion a\n * @param b - quaternion b\n * @return angle in radians between the two quaternions\n */\nfunction angle(a, b) {\n    const d = dot$1(a, b);\n    return Math.acos(2 * d * d - 1);\n}\n/**\n * Multiplies two quaternions\n *\n * @param a - the first quaternion\n * @param b - the second quaternion\n * @param dst - quaternion to hold result. If not passed in a new one is created.\n * @returns A quaternion that is the result of a * b\n */\nfunction multiply$1(a, b, dst) {\n    dst = dst || new QuatType(4);\n    const ax = a[0];\n    const ay = a[1];\n    const az = a[2];\n    const aw = a[3];\n    const bx = b[0];\n    const by = b[1];\n    const bz = b[2];\n    const bw = b[3];\n    dst[0] = ax * bw + aw * bx + ay * bz - az * by;\n    dst[1] = ay * bw + aw * by + az * bx - ax * bz;\n    dst[2] = az * bw + aw * bz + ax * by - ay * bx;\n    dst[3] = aw * bw - ax * bx - ay * by - az * bz;\n    return dst;\n}\n/**\n * Multiplies two quaternions\n *\n * @param a - the first quaternion\n * @param b - the second quaternion\n * @param dst - quaternion to hold result. If not passed in a new one is created.\n * @returns A quaternion that is the result of a * b\n */\nconst mul$1 = multiply$1;\n/**\n * Rotates the given quaternion around the X axis by the given angle.\n * @param q - quaternion to rotate\n * @param angleInRadians - The angle by which to rotate\n * @param dst - quaternion to hold result. If not passed in a new one is created.\n * @returns A quaternion that is the result of a * b\n */\nfunction rotateX(q, angleInRadians, dst) {\n    dst = dst || new QuatType(4);\n    const halfAngle = angleInRadians * 0.5;\n    const qx = q[0];\n    const qy = q[1];\n    const qz = q[2];\n    const qw = q[3];\n    const bx = Math.sin(halfAngle);\n    const bw = Math.cos(halfAngle);\n    dst[0] = qx * bw + qw * bx;\n    dst[1] = qy * bw + qz * bx;\n    dst[2] = qz * bw - qy * bx;\n    dst[3] = qw * bw - qx * bx;\n    return dst;\n}\n/**\n * Rotates the given quaternion around the Y axis by the given angle.\n * @param q - quaternion to rotate\n * @param angleInRadians - The angle by which to rotate\n * @param dst - quaternion to hold result. If not passed in a new one is created.\n * @returns A quaternion that is the result of a * b\n */\nfunction rotateY(q, angleInRadians, dst) {\n    dst = dst || new QuatType(4);\n    const halfAngle = angleInRadians * 0.5;\n    const qx = q[0];\n    const qy = q[1];\n    const qz = q[2];\n    const qw = q[3];\n    const by = Math.sin(halfAngle);\n    const bw = Math.cos(halfAngle);\n    dst[0] = qx * bw - qz * by;\n    dst[1] = qy * bw + qw * by;\n    dst[2] = qz * bw + qx * by;\n    dst[3] = qw * bw - qy * by;\n    return dst;\n}\n/**\n * Rotates the given quaternion around the Z axis by the given angle.\n * @param q - quaternion to rotate\n * @param angleInRadians - The angle by which to rotate\n * @param dst - quaternion to hold result. If not passed in a new one is created.\n * @returns A quaternion that is the result of a * b\n */\nfunction rotateZ(q, angleInRadians, dst) {\n    dst = dst || new QuatType(4);\n    const halfAngle = angleInRadians * 0.5;\n    const qx = q[0];\n    const qy = q[1];\n    const qz = q[2];\n    const qw = q[3];\n    const bz = Math.sin(halfAngle);\n    const bw = Math.cos(halfAngle);\n    dst[0] = qx * bw + qy * bz;\n    dst[1] = qy * bw - qx * bz;\n    dst[2] = qz * bw + qw * bz;\n    dst[3] = qw * bw - qz * bz;\n    return dst;\n}\n/**\n * Spherically linear interpolate between two quaternions\n *\n * @param a - starting value\n * @param b - ending value\n * @param t - value where 0 = a and 1 = b\n * @param dst - quaternion to hold result. If not passed in a new one is created.\n * @returns A quaternion that is the result of a * b\n */\nfunction slerp(a, b, t, dst) {\n    dst = dst || new QuatType(4);\n    const ax = a[0];\n    const ay = a[1];\n    const az = a[2];\n    const aw = a[3];\n    let bx = b[0];\n    let by = b[1];\n    let bz = b[2];\n    let bw = b[3];\n    let cosOmega = ax * bx + ay * by + az * bz + aw * bw;\n    if (cosOmega < 0) {\n        cosOmega = -cosOmega;\n        bx = -bx;\n        by = -by;\n        bz = -bz;\n        bw = -bw;\n    }\n    let scale0;\n    let scale1;\n    if (1.0 - cosOmega > EPSILON) {\n        const omega = Math.acos(cosOmega);\n        const sinOmega = Math.sin(omega);\n        scale0 = Math.sin((1 - t) * omega) / sinOmega;\n        scale1 = Math.sin(t * omega) / sinOmega;\n    }\n    else {\n        scale0 = 1.0 - t;\n        scale1 = t;\n    }\n    dst[0] = scale0 * ax + scale1 * bx;\n    dst[1] = scale0 * ay + scale1 * by;\n    dst[2] = scale0 * az + scale1 * bz;\n    dst[3] = scale0 * aw + scale1 * bw;\n    return dst;\n}\n/**\n * Compute the inverse of a quaternion\n *\n * @param q - quaternion to compute the inverse of\n * @returns A quaternion that is the result of a * b\n */\nfunction inverse$1(q, dst) {\n    dst = dst || new QuatType(4);\n    const a0 = q[0];\n    const a1 = q[1];\n    const a2 = q[2];\n    const a3 = q[3];\n    const dot = a0 * a0 + a1 * a1 + a2 * a2 + a3 * a3;\n    const invDot = dot ? 1 / dot : 0;\n    dst[0] = -a0 * invDot;\n    dst[1] = -a1 * invDot;\n    dst[2] = -a2 * invDot;\n    dst[3] = a3 * invDot;\n    return dst;\n}\n/**\n * Compute the conjugate of a quaternion\n * For quaternions with a magnitude of 1 (a unit quaternion)\n * this returns the same as the inverse but is faster to calculate.\n *\n * @param q - quaternion to compute the conjugate of.\n * @param dst - quaternion to hold result. If not passed in a new one is created.\n * @returns The conjugate of q\n */\nfunction conjugate(q, dst) {\n    dst = dst || new QuatType(4);\n    dst[0] = -q[0];\n    dst[1] = -q[1];\n    dst[2] = -q[2];\n    dst[3] = q[3];\n    return dst;\n}\n/**\n * Creates a quaternion from the given rotation matrix.\n *\n * The created quaternion is not normalized.\n *\n * @param m - rotation matrix\n * @param dst - quaternion to hold result. If not passed in a new one is created.\n * @returns the result\n */\nfunction fromMat(m, dst) {\n    dst = dst || new QuatType(4);\n    /*\n    0 1 2\n    3 4 5\n    6 7 8\n  \n    0 1 2\n    4 5 6\n    8 9 10\n     */\n    // Algorithm in Ken Shoemake's article in 1987 SIGGRAPH course notes\n    // article \"Quaternion Calculus and Fast Animation\".\n    const trace = m[0] + m[5] + m[10];\n    if (trace > 0.0) {\n        // |w| > 1/2, may as well choose w > 1/2\n        const root = Math.sqrt(trace + 1); // 2w\n        dst[3] = 0.5 * root;\n        const invRoot = 0.5 / root; // 1/(4w)\n        dst[0] = (m[6] - m[9]) * invRoot;\n        dst[1] = (m[8] - m[2]) * invRoot;\n        dst[2] = (m[1] - m[4]) * invRoot;\n    }\n    else {\n        // |w| <= 1/2\n        let i = 0;\n        if (m[5] > m[0]) {\n            i = 1;\n        }\n        if (m[10] > m[i * 4 + i]) {\n            i = 2;\n        }\n        const j = (i + 1) % 3;\n        const k = (i + 2) % 3;\n        const root = Math.sqrt(m[i * 4 + i] - m[j * 4 + j] - m[k * 4 + k] + 1.0);\n        dst[i] = 0.5 * root;\n        const invRoot = 0.5 / root;\n        dst[3] = (m[j * 4 + k] - m[k * 4 + j]) * invRoot;\n        dst[j] = (m[j * 4 + i] + m[i * 4 + j]) * invRoot;\n        dst[k] = (m[k * 4 + i] + m[i * 4 + k]) * invRoot;\n    }\n    return dst;\n}\n/**\n * Creates a quaternion from the given euler angle x, y, z using the provided intrinsic order for the conversion.\n *\n * @param xAngleInRadians - angle to rotate around X axis in radians.\n * @param yAngleInRadians - angle to rotate around Y axis in radians.\n * @param zAngleInRadians - angle to rotate around Z axis in radians.\n * @param order - order to apply euler angles\n * @param dst - quaternion to hold result. If not passed in a new one is created.\n * @returns A quaternion representing the same rotation as the euler angles applied in the given order\n */\nfunction fromEuler(xAngleInRadians, yAngleInRadians, zAngleInRadians, order, dst) {\n    dst = dst || new QuatType(4);\n    const xHalfAngle = xAngleInRadians * 0.5;\n    const yHalfAngle = yAngleInRadians * 0.5;\n    const zHalfAngle = zAngleInRadians * 0.5;\n    const sx = Math.sin(xHalfAngle);\n    const cx = Math.cos(xHalfAngle);\n    const sy = Math.sin(yHalfAngle);\n    const cy = Math.cos(yHalfAngle);\n    const sz = Math.sin(zHalfAngle);\n    const cz = Math.cos(zHalfAngle);\n    switch (order) {\n        case 'xyz':\n            dst[0] = sx * cy * cz + cx * sy * sz;\n            dst[1] = cx * sy * cz - sx * cy * sz;\n            dst[2] = cx * cy * sz + sx * sy * cz;\n            dst[3] = cx * cy * cz - sx * sy * sz;\n            break;\n        case 'xzy':\n            dst[0] = sx * cy * cz - cx * sy * sz;\n            dst[1] = cx * sy * cz - sx * cy * sz;\n            dst[2] = cx * cy * sz + sx * sy * cz;\n            dst[3] = cx * cy * cz + sx * sy * sz;\n            break;\n        case 'yxz':\n            dst[0] = sx * cy * cz + cx * sy * sz;\n            dst[1] = cx * sy * cz - sx * cy * sz;\n            dst[2] = cx * cy * sz - sx * sy * cz;\n            dst[3] = cx * cy * cz + sx * sy * sz;\n            break;\n        case 'yzx':\n            dst[0] = sx * cy * cz + cx * sy * sz;\n            dst[1] = cx * sy * cz + sx * cy * sz;\n            dst[2] = cx * cy * sz - sx * sy * cz;\n            dst[3] = cx * cy * cz - sx * sy * sz;\n            break;\n        case 'zxy':\n            dst[0] = sx * cy * cz - cx * sy * sz;\n            dst[1] = cx * sy * cz + sx * cy * sz;\n            dst[2] = cx * cy * sz + sx * sy * cz;\n            dst[3] = cx * cy * cz - sx * sy * sz;\n            break;\n        case 'zyx':\n            dst[0] = sx * cy * cz - cx * sy * sz;\n            dst[1] = cx * sy * cz + sx * cy * sz;\n            dst[2] = cx * cy * sz - sx * sy * cz;\n            dst[3] = cx * cy * cz + sx * sy * sz;\n            break;\n        default:\n            throw new Error(`Unknown rotation order: ${order}`);\n    }\n    return dst;\n}\n/**\n * Copies a quaternion. (same as {@link quat.clone})\n * Also see {@link quat.create} and {@link quat.set}\n * @param q - The quaternion.\n * @param dst - quaternion to hold result. If not passed in a new one is created.\n * @returns A quaternion that is a copy of q\n */\nfunction copy$1(q, dst) {\n    dst = dst || new QuatType(4);\n    dst[0] = q[0];\n    dst[1] = q[1];\n    dst[2] = q[2];\n    dst[3] = q[3];\n    return dst;\n}\n/**\n * Clones a quaternion. (same as {@link quat.copy})\n * Also see {@link quat.create} and {@link quat.set}\n * @param q - The quaternion.\n * @param dst - quaternion to hold result. If not passed in a new one is created.\n * @returns A copy of q.\n */\nconst clone$1 = copy$1;\n/**\n * Adds two quaternions; assumes a and b have the same dimension.\n * @param a - Operand quaternion.\n * @param b - Operand quaternion.\n * @param dst - quaternion to hold result. If not passed in a new one is created.\n * @returns A quaternion that is the sum of a and b.\n */\nfunction add$1(a, b, dst) {\n    dst = dst || new QuatType(4);\n    dst[0] = a[0] + b[0];\n    dst[1] = a[1] + b[1];\n    dst[2] = a[2] + b[2];\n    dst[3] = a[3] + b[3];\n    return dst;\n}\n/**\n * Subtracts two quaternions.\n * @param a - Operand quaternion.\n * @param b - Operand quaternion.\n * @param dst - quaternion to hold result. If not passed in a new one is created.\n * @returns A quaternion that is the difference of a and b.\n */\nfunction subtract$1(a, b, dst) {\n    dst = dst || new QuatType(4);\n    dst[0] = a[0] - b[0];\n    dst[1] = a[1] - b[1];\n    dst[2] = a[2] - b[2];\n    dst[3] = a[3] - b[3];\n    return dst;\n}\n/**\n * Subtracts two quaternions.\n * @param a - Operand quaternion.\n * @param b - Operand quaternion.\n * @param dst - quaternion to hold result. If not passed in a new one is created.\n * @returns A quaternion that is the difference of a and b.\n */\nconst sub$1 = subtract$1;\n/**\n * Multiplies a quaternion by a scalar.\n * @param v - The quaternion.\n * @param k - The scalar.\n * @param dst - quaternion to hold result. If not passed in a new one is created.\n * @returns The scaled quaternion.\n */\nfunction mulScalar$1(v, k, dst) {\n    dst = dst || new QuatType(4);\n    dst[0] = v[0] * k;\n    dst[1] = v[1] * k;\n    dst[2] = v[2] * k;\n    dst[3] = v[3] * k;\n    return dst;\n}\n/**\n * Multiplies a quaternion by a scalar. (same as mulScalar)\n * @param v - The quaternion.\n * @param k - The scalar.\n * @param dst - quaternion to hold result. If not passed in a new one is created.\n * @returns The scaled quaternion.\n */\nconst scale$1 = mulScalar$1;\n/**\n * Divides a vector by a scalar.\n * @param v - The vector.\n * @param k - The scalar.\n * @param dst - quaternion to hold result. If not passed in a new one is created.\n * @returns The scaled quaternion.\n */\nfunction divScalar$1(v, k, dst) {\n    dst = dst || new QuatType(4);\n    dst[0] = v[0] / k;\n    dst[1] = v[1] / k;\n    dst[2] = v[2] / k;\n    dst[3] = v[3] / k;\n    return dst;\n}\n/**\n * Computes the dot product of two quaternions\n * @param a - Operand quaternion.\n * @param b - Operand quaternion.\n * @returns dot product\n */\nfunction dot$1(a, b) {\n    return (a[0] * b[0]) + (a[1] * b[1]) + (a[2] * b[2]) + (a[3] * b[3]);\n}\n/**\n * Performs linear interpolation on two quaternions.\n * Given quaternions a and b and interpolation coefficient t, returns\n * a + t * (b - a).\n * @param a - Operand quaternion.\n * @param b - Operand quaternion.\n * @param t - Interpolation coefficient.\n * @param dst - quaternion to hold result. If not passed in a new one is created.\n * @returns The linear interpolated result.\n */\nfunction lerp$1(a, b, t, dst) {\n    dst = dst || new QuatType(4);\n    dst[0] = a[0] + t * (b[0] - a[0]);\n    dst[1] = a[1] + t * (b[1] - a[1]);\n    dst[2] = a[2] + t * (b[2] - a[2]);\n    dst[3] = a[3] + t * (b[3] - a[3]);\n    return dst;\n}\n/**\n * Computes the length of quaternion\n * @param v - quaternion.\n * @returns length of quaternion.\n */\nfunction length$1(v) {\n    const v0 = v[0];\n    const v1 = v[1];\n    const v2 = v[2];\n    const v3 = v[3];\n    return Math.sqrt(v0 * v0 + v1 * v1 + v2 * v2 + v3 * v3);\n}\n/**\n * Computes the length of quaternion (same as length)\n * @param v - quaternion.\n * @returns length of quaternion.\n */\nconst len$1 = length$1;\n/**\n * Computes the square of the length of quaternion\n * @param v - quaternion.\n * @returns square of the length of quaternion.\n */\nfunction lengthSq$1(v) {\n    const v0 = v[0];\n    const v1 = v[1];\n    const v2 = v[2];\n    const v3 = v[3];\n    return v0 * v0 + v1 * v1 + v2 * v2 + v3 * v3;\n}\n/**\n * Computes the square of the length of quaternion (same as lengthSq)\n * @param v - quaternion.\n * @returns square of the length of quaternion.\n */\nconst lenSq$1 = lengthSq$1;\n/**\n * Divides a quaternion by its Euclidean length and returns the quotient.\n * @param v - The quaternion.\n * @param dst - quaternion to hold result. If not passed in a new one is created.\n * @returns The normalized quaternion.\n */\nfunction normalize$1(v, dst) {\n    dst = dst || new QuatType(4);\n    const v0 = v[0];\n    const v1 = v[1];\n    const v2 = v[2];\n    const v3 = v[3];\n    const len = Math.sqrt(v0 * v0 + v1 * v1 + v2 * v2 + v3 * v3);\n    if (len > 0.00001) {\n        dst[0] = v0 / len;\n        dst[1] = v1 / len;\n        dst[2] = v2 / len;\n        dst[3] = v3 / len;\n    }\n    else {\n        dst[0] = 0;\n        dst[1] = 0;\n        dst[2] = 0;\n        dst[3] = 0;\n    }\n    return dst;\n}\n/**\n * Check if 2 quaternions are approximately equal\n * @param a - Operand quaternion.\n * @param b - Operand quaternion.\n * @returns true if quaternions are approximately equal\n */\nfunction equalsApproximately$1(a, b) {\n    return Math.abs(a[0] - b[0]) < EPSILON &&\n        Math.abs(a[1] - b[1]) < EPSILON &&\n        Math.abs(a[2] - b[2]) < EPSILON &&\n        Math.abs(a[3] - b[3]) < EPSILON;\n}\n/**\n * Check if 2 quaternions are exactly equal\n * @param a - Operand quaternion.\n * @param b - Operand quaternion.\n * @returns true if quaternions are exactly equal\n */\nfunction equals$1(a, b) {\n    return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3];\n}\n/**\n * Creates an identity quaternion\n * @param dst - quaternion to hold result. If not passed in a new one is created.\n * @returns an identity quaternion\n */\nfunction identity(dst) {\n    dst = dst || new QuatType(4);\n    dst[0] = 0;\n    dst[1] = 0;\n    dst[2] = 0;\n    dst[3] = 1;\n    return dst;\n}\nlet tempVec3;\nlet xUnitVec3;\nlet yUnitVec3;\n/**\n * Computes a quaternion to represent the shortest rotation from one vector to another.\n *\n * @param aUnit - the start vector\n * @param bUnit - the end vector\n * @param dst - quaternion to hold result. If not passed in a new one is created.\n * @returns the result\n */\nfunction rotationTo(aUnit, bUnit, dst) {\n    dst = dst || new QuatType(4);\n    tempVec3 = tempVec3 || create$3();\n    xUnitVec3 = xUnitVec3 || create$3(1, 0, 0);\n    yUnitVec3 = yUnitVec3 || create$3(0, 1, 0);\n    const dot = dot$2(aUnit, bUnit);\n    if (dot < -0.999999) {\n        cross(xUnitVec3, aUnit, tempVec3);\n        if (len$2(tempVec3) < 0.000001) {\n            cross(yUnitVec3, aUnit, tempVec3);\n        }\n        normalize$2(tempVec3, tempVec3);\n        fromAxisAngle(tempVec3, Math.PI, dst);\n        return dst;\n    }\n    else if (dot > 0.999999) {\n        dst[0] = 0;\n        dst[1] = 0;\n        dst[2] = 0;\n        dst[3] = 1;\n        return dst;\n    }\n    else {\n        cross(aUnit, bUnit, tempVec3);\n        dst[0] = tempVec3[0];\n        dst[1] = tempVec3[1];\n        dst[2] = tempVec3[2];\n        dst[3] = 1 + dot;\n        return normalize$1(dst, dst);\n    }\n}\nlet tempQuat1;\nlet tempQuat2;\n/**\n * Performs a spherical linear interpolation with two control points\n *\n * @param a - the first quaternion\n * @param b - the second quaternion\n * @param c - the third quaternion\n * @param d - the fourth quaternion\n * @param t - Interpolation coefficient 0 to 1\n * @returns result\n */\nfunction sqlerp(a, b, c, d, t, dst) {\n    dst = dst || new QuatType(4);\n    tempQuat1 = tempQuat1 || new QuatType(4);\n    tempQuat2 = tempQuat2 || new QuatType(4);\n    slerp(a, d, t, tempQuat1);\n    slerp(b, c, t, tempQuat2);\n    slerp(tempQuat1, tempQuat2, 2 * t * (1 - t), dst);\n    return dst;\n}\n\nvar quatImpl = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    create: create$1,\n    setDefaultType: setDefaultType$2,\n    fromValues: fromValues$1,\n    set: set$1,\n    fromAxisAngle: fromAxisAngle,\n    toAxisAngle: toAxisAngle,\n    angle: angle,\n    multiply: multiply$1,\n    mul: mul$1,\n    rotateX: rotateX,\n    rotateY: rotateY,\n    rotateZ: rotateZ,\n    slerp: slerp,\n    inverse: inverse$1,\n    conjugate: conjugate,\n    fromMat: fromMat,\n    fromEuler: fromEuler,\n    copy: copy$1,\n    clone: clone$1,\n    add: add$1,\n    subtract: subtract$1,\n    sub: sub$1,\n    mulScalar: mulScalar$1,\n    scale: scale$1,\n    divScalar: divScalar$1,\n    dot: dot$1,\n    lerp: lerp$1,\n    length: length$1,\n    len: len$1,\n    lengthSq: lengthSq$1,\n    lenSq: lenSq$1,\n    normalize: normalize$1,\n    equalsApproximately: equalsApproximately$1,\n    equals: equals$1,\n    identity: identity,\n    rotationTo: rotationTo,\n    sqlerp: sqlerp\n});\n\n/*\n * Copyright 2022 Gregg Tavares\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL\n * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n/**\n *\n * Vec4 math functions.\n *\n * Almost all functions take an optional `dst` argument. If it is not passed in the\n * functions will create a new `Vec4`. In other words you can do this\n *\n *     const v = vec4.cross(v1, v2);  // Creates a new Vec4 with the cross product of v1 x v2.\n *\n * or\n *\n *     const v = vec4.create();\n *     vec4.cross(v1, v2, v);  // Puts the cross product of v1 x v2 in v\n *\n * The first style is often easier but depending on where it's used it generates garbage where\n * as there is almost never allocation with the second style.\n *\n * It is always safe to pass any vector as the destination. So for example\n *\n *     vec4.cross(v1, v2, v1);  // Puts the cross product of v1 x v2 in v1\n *\n */\nlet VecType = Float32Array;\n/**\n * Sets the type this library creates for a Vec4\n * @param ctor - the constructor for the type. Either `Float32Array`, `Float64Array`, or `Array`\n * @returns previous constructor for Vec4\n */\nfunction setDefaultType$1(ctor) {\n    const oldType = VecType;\n    VecType = ctor;\n    return oldType;\n}\n/**\n * Creates a vec4; may be called with x, y, z to set initial values.\n * @param x - Initial x value.\n * @param y - Initial y value.\n * @param z - Initial z value.\n * @param w - Initial w value.\n * @returns the created vector\n */\nfunction create(x, y, z, w) {\n    const dst = new VecType(4);\n    if (x !== undefined) {\n        dst[0] = x;\n        if (y !== undefined) {\n            dst[1] = y;\n            if (z !== undefined) {\n                dst[2] = z;\n                if (w !== undefined) {\n                    dst[3] = w;\n                }\n            }\n        }\n    }\n    return dst;\n}\n\n/*\n * Copyright 2022 Gregg Tavares\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL\n * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n/**\n * Creates a vec4; may be called with x, y, z to set initial values. (same as create)\n * @param x - Initial x value.\n * @param y - Initial y value.\n * @param z - Initial z value.\n * @param z - Initial w value.\n * @returns the created vector\n */\nconst fromValues = create;\n/**\n * Sets the values of a Vec4\n * Also see {@link vec4.create} and {@link vec4.copy}\n *\n * @param x first value\n * @param y second value\n * @param z third value\n * @param w fourth value\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns A vector with its elements set.\n */\nfunction set(x, y, z, w, dst) {\n    dst = dst || new VecType(4);\n    dst[0] = x;\n    dst[1] = y;\n    dst[2] = z;\n    dst[3] = w;\n    return dst;\n}\n/**\n * Applies Math.ceil to each element of vector\n * @param v - Operand vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns A vector that is the ceil of each element of v.\n */\nfunction ceil(v, dst) {\n    dst = dst || new VecType(4);\n    dst[0] = Math.ceil(v[0]);\n    dst[1] = Math.ceil(v[1]);\n    dst[2] = Math.ceil(v[2]);\n    dst[3] = Math.ceil(v[3]);\n    return dst;\n}\n/**\n * Applies Math.floor to each element of vector\n * @param v - Operand vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns A vector that is the floor of each element of v.\n */\nfunction floor(v, dst) {\n    dst = dst || new VecType(4);\n    dst[0] = Math.floor(v[0]);\n    dst[1] = Math.floor(v[1]);\n    dst[2] = Math.floor(v[2]);\n    dst[3] = Math.floor(v[3]);\n    return dst;\n}\n/**\n * Applies Math.round to each element of vector\n * @param v - Operand vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns A vector that is the round of each element of v.\n */\nfunction round(v, dst) {\n    dst = dst || new VecType(4);\n    dst[0] = Math.round(v[0]);\n    dst[1] = Math.round(v[1]);\n    dst[2] = Math.round(v[2]);\n    dst[3] = Math.round(v[3]);\n    return dst;\n}\n/**\n * Clamp each element of vector between min and max\n * @param v - Operand vector.\n * @param max - Min value, default 0\n * @param min - Max value, default 1\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns A vector that the clamped value of each element of v.\n */\nfunction clamp(v, min = 0, max = 1, dst) {\n    dst = dst || new VecType(4);\n    dst[0] = Math.min(max, Math.max(min, v[0]));\n    dst[1] = Math.min(max, Math.max(min, v[1]));\n    dst[2] = Math.min(max, Math.max(min, v[2]));\n    dst[3] = Math.min(max, Math.max(min, v[3]));\n    return dst;\n}\n/**\n * Adds two vectors; assumes a and b have the same dimension.\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns A vector that is the sum of a and b.\n */\nfunction add(a, b, dst) {\n    dst = dst || new VecType(4);\n    dst[0] = a[0] + b[0];\n    dst[1] = a[1] + b[1];\n    dst[2] = a[2] + b[2];\n    dst[3] = a[3] + b[3];\n    return dst;\n}\n/**\n * Adds two vectors, scaling the 2nd; assumes a and b have the same dimension.\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @param scale - Amount to scale b\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns A vector that is the sum of a + b * scale.\n */\nfunction addScaled(a, b, scale, dst) {\n    dst = dst || new VecType(4);\n    dst[0] = a[0] + b[0] * scale;\n    dst[1] = a[1] + b[1] * scale;\n    dst[2] = a[2] + b[2] * scale;\n    dst[3] = a[3] + b[3] * scale;\n    return dst;\n}\n/**\n * Subtracts two vectors.\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns A vector that is the difference of a and b.\n */\nfunction subtract(a, b, dst) {\n    dst = dst || new VecType(4);\n    dst[0] = a[0] - b[0];\n    dst[1] = a[1] - b[1];\n    dst[2] = a[2] - b[2];\n    dst[3] = a[3] - b[3];\n    return dst;\n}\n/**\n * Subtracts two vectors.\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns A vector that is the difference of a and b.\n */\nconst sub = subtract;\n/**\n * Check if 2 vectors are approximately equal\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @returns true if vectors are approximately equal\n */\nfunction equalsApproximately(a, b) {\n    return Math.abs(a[0] - b[0]) < EPSILON &&\n        Math.abs(a[1] - b[1]) < EPSILON &&\n        Math.abs(a[2] - b[2]) < EPSILON &&\n        Math.abs(a[3] - b[3]) < EPSILON;\n}\n/**\n * Check if 2 vectors are exactly equal\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @returns true if vectors are exactly equal\n */\nfunction equals(a, b) {\n    return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3];\n}\n/**\n * Performs linear interpolation on two vectors.\n * Given vectors a and b and interpolation coefficient t, returns\n * a + t * (b - a).\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @param t - Interpolation coefficient.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns The linear interpolated result.\n */\nfunction lerp(a, b, t, dst) {\n    dst = dst || new VecType(4);\n    dst[0] = a[0] + t * (b[0] - a[0]);\n    dst[1] = a[1] + t * (b[1] - a[1]);\n    dst[2] = a[2] + t * (b[2] - a[2]);\n    dst[3] = a[3] + t * (b[3] - a[3]);\n    return dst;\n}\n/**\n * Performs linear interpolation on two vectors.\n * Given vectors a and b and interpolation coefficient vector t, returns\n * a + t * (b - a).\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @param t - Interpolation coefficients vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns the linear interpolated result.\n */\nfunction lerpV(a, b, t, dst) {\n    dst = dst || new VecType(4);\n    dst[0] = a[0] + t[0] * (b[0] - a[0]);\n    dst[1] = a[1] + t[1] * (b[1] - a[1]);\n    dst[2] = a[2] + t[2] * (b[2] - a[2]);\n    dst[3] = a[3] + t[3] * (b[3] - a[3]);\n    return dst;\n}\n/**\n * Return max values of two vectors.\n * Given vectors a and b returns\n * [max(a[0], b[0]), max(a[1], b[1]), max(a[2], b[2])].\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns The max components vector.\n */\nfunction max(a, b, dst) {\n    dst = dst || new VecType(4);\n    dst[0] = Math.max(a[0], b[0]);\n    dst[1] = Math.max(a[1], b[1]);\n    dst[2] = Math.max(a[2], b[2]);\n    dst[3] = Math.max(a[3], b[3]);\n    return dst;\n}\n/**\n * Return min values of two vectors.\n * Given vectors a and b returns\n * [min(a[0], b[0]), min(a[1], b[1]), min(a[2], b[2])].\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns The min components vector.\n */\nfunction min(a, b, dst) {\n    dst = dst || new VecType(4);\n    dst[0] = Math.min(a[0], b[0]);\n    dst[1] = Math.min(a[1], b[1]);\n    dst[2] = Math.min(a[2], b[2]);\n    dst[3] = Math.min(a[3], b[3]);\n    return dst;\n}\n/**\n * Multiplies a vector by a scalar.\n * @param v - The vector.\n * @param k - The scalar.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns The scaled vector.\n */\nfunction mulScalar(v, k, dst) {\n    dst = dst || new VecType(4);\n    dst[0] = v[0] * k;\n    dst[1] = v[1] * k;\n    dst[2] = v[2] * k;\n    dst[3] = v[3] * k;\n    return dst;\n}\n/**\n * Multiplies a vector by a scalar. (same as mulScalar)\n * @param v - The vector.\n * @param k - The scalar.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns The scaled vector.\n */\nconst scale = mulScalar;\n/**\n * Divides a vector by a scalar.\n * @param v - The vector.\n * @param k - The scalar.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns The scaled vector.\n */\nfunction divScalar(v, k, dst) {\n    dst = dst || new VecType(4);\n    dst[0] = v[0] / k;\n    dst[1] = v[1] / k;\n    dst[2] = v[2] / k;\n    dst[3] = v[3] / k;\n    return dst;\n}\n/**\n * Inverse a vector.\n * @param v - The vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns The inverted vector.\n */\nfunction inverse(v, dst) {\n    dst = dst || new VecType(4);\n    dst[0] = 1 / v[0];\n    dst[1] = 1 / v[1];\n    dst[2] = 1 / v[2];\n    dst[3] = 1 / v[3];\n    return dst;\n}\n/**\n * Invert a vector. (same as inverse)\n * @param v - The vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns The inverted vector.\n */\nconst invert = inverse;\n/**\n * Computes the dot product of two vectors\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @returns dot product\n */\nfunction dot(a, b) {\n    return (a[0] * b[0]) + (a[1] * b[1]) + (a[2] * b[2]) + (a[3] * b[3]);\n}\n/**\n * Computes the length of vector\n * @param v - vector.\n * @returns length of vector.\n */\nfunction length(v) {\n    const v0 = v[0];\n    const v1 = v[1];\n    const v2 = v[2];\n    const v3 = v[3];\n    return Math.sqrt(v0 * v0 + v1 * v1 + v2 * v2 + v3 * v3);\n}\n/**\n * Computes the length of vector (same as length)\n * @param v - vector.\n * @returns length of vector.\n */\nconst len = length;\n/**\n * Computes the square of the length of vector\n * @param v - vector.\n * @returns square of the length of vector.\n */\nfunction lengthSq(v) {\n    const v0 = v[0];\n    const v1 = v[1];\n    const v2 = v[2];\n    const v3 = v[3];\n    return v0 * v0 + v1 * v1 + v2 * v2 + v3 * v3;\n}\n/**\n * Computes the square of the length of vector (same as lengthSq)\n * @param v - vector.\n * @returns square of the length of vector.\n */\nconst lenSq = lengthSq;\n/**\n * Computes the distance between 2 points\n * @param a - vector.\n * @param b - vector.\n * @returns distance between a and b\n */\nfunction distance(a, b) {\n    const dx = a[0] - b[0];\n    const dy = a[1] - b[1];\n    const dz = a[2] - b[2];\n    const dw = a[3] - b[3];\n    return Math.sqrt(dx * dx + dy * dy + dz * dz + dw * dw);\n}\n/**\n * Computes the distance between 2 points (same as distance)\n * @param a - vector.\n * @param b - vector.\n * @returns distance between a and b\n */\nconst dist = distance;\n/**\n * Computes the square of the distance between 2 points\n * @param a - vector.\n * @param b - vector.\n * @returns square of the distance between a and b\n */\nfunction distanceSq(a, b) {\n    const dx = a[0] - b[0];\n    const dy = a[1] - b[1];\n    const dz = a[2] - b[2];\n    const dw = a[3] - b[3];\n    return dx * dx + dy * dy + dz * dz + dw * dw;\n}\n/**\n * Computes the square of the distance between 2 points (same as distanceSq)\n * @param a - vector.\n * @param b - vector.\n * @returns square of the distance between a and b\n */\nconst distSq = distanceSq;\n/**\n * Divides a vector by its Euclidean length and returns the quotient.\n * @param v - The vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns The normalized vector.\n */\nfunction normalize(v, dst) {\n    dst = dst || new VecType(4);\n    const v0 = v[0];\n    const v1 = v[1];\n    const v2 = v[2];\n    const v3 = v[3];\n    const len = Math.sqrt(v0 * v0 + v1 * v1 + v2 * v2 + v3 * v3);\n    if (len > 0.00001) {\n        dst[0] = v0 / len;\n        dst[1] = v1 / len;\n        dst[2] = v2 / len;\n        dst[3] = v3 / len;\n    }\n    else {\n        dst[0] = 0;\n        dst[1] = 0;\n        dst[2] = 0;\n        dst[3] = 0;\n    }\n    return dst;\n}\n/**\n * Negates a vector.\n * @param v - The vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns -v.\n */\nfunction negate(v, dst) {\n    dst = dst || new VecType(4);\n    dst[0] = -v[0];\n    dst[1] = -v[1];\n    dst[2] = -v[2];\n    dst[3] = -v[3];\n    return dst;\n}\n/**\n * Copies a vector. (same as {@link vec4.clone})\n * Also see {@link vec4.create} and {@link vec4.set}\n * @param v - The vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns A copy of v.\n */\nfunction copy(v, dst) {\n    dst = dst || new VecType(4);\n    dst[0] = v[0];\n    dst[1] = v[1];\n    dst[2] = v[2];\n    dst[3] = v[3];\n    return dst;\n}\n/**\n * Clones a vector. (same as {@link vec4.copy})\n * Also see {@link vec4.create} and {@link vec4.set}\n * @param v - The vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns A copy of v.\n */\nconst clone = copy;\n/**\n * Multiplies a vector by another vector (component-wise); assumes a and\n * b have the same length.\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns The vector of products of entries of a and b.\n */\nfunction multiply(a, b, dst) {\n    dst = dst || new VecType(4);\n    dst[0] = a[0] * b[0];\n    dst[1] = a[1] * b[1];\n    dst[2] = a[2] * b[2];\n    dst[3] = a[3] * b[3];\n    return dst;\n}\n/**\n * Multiplies a vector by another vector (component-wise); assumes a and\n * b have the same length. (same as mul)\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns The vector of products of entries of a and b.\n */\nconst mul = multiply;\n/**\n * Divides a vector by another vector (component-wise); assumes a and\n * b have the same length.\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns The vector of quotients of entries of a and b.\n */\nfunction divide(a, b, dst) {\n    dst = dst || new VecType(4);\n    dst[0] = a[0] / b[0];\n    dst[1] = a[1] / b[1];\n    dst[2] = a[2] / b[2];\n    dst[3] = a[3] / b[3];\n    return dst;\n}\n/**\n * Divides a vector by another vector (component-wise); assumes a and\n * b have the same length. (same as divide)\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns The vector of quotients of entries of a and b.\n */\nconst div = divide;\n/**\n * Zero's a vector\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns The zeroed vector.\n */\nfunction zero(dst) {\n    dst = dst || new VecType(4);\n    dst[0] = 0;\n    dst[1] = 0;\n    dst[2] = 0;\n    dst[3] = 0;\n    return dst;\n}\n/**\n * transform vec4 by 4x4 matrix\n * @param v - the vector\n * @param m - The matrix.\n * @param dst - optional vec4 to store result. If not passed a new one is created.\n * @returns the transformed vector\n */\nfunction transformMat4(v, m, dst) {\n    dst = dst || new VecType(4);\n    const x = v[0];\n    const y = v[1];\n    const z = v[2];\n    const w = v[3];\n    dst[0] = m[0] * x + m[4] * y + m[8] * z + m[12] * w;\n    dst[1] = m[1] * x + m[5] * y + m[9] * z + m[13] * w;\n    dst[2] = m[2] * x + m[6] * y + m[10] * z + m[14] * w;\n    dst[3] = m[3] * x + m[7] * y + m[11] * z + m[15] * w;\n    return dst;\n}\n\nvar vec4Impl = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    create: create,\n    setDefaultType: setDefaultType$1,\n    fromValues: fromValues,\n    set: set,\n    ceil: ceil,\n    floor: floor,\n    round: round,\n    clamp: clamp,\n    add: add,\n    addScaled: addScaled,\n    subtract: subtract,\n    sub: sub,\n    equalsApproximately: equalsApproximately,\n    equals: equals,\n    lerp: lerp,\n    lerpV: lerpV,\n    max: max,\n    min: min,\n    mulScalar: mulScalar,\n    scale: scale,\n    divScalar: divScalar,\n    inverse: inverse,\n    invert: invert,\n    dot: dot,\n    length: length,\n    len: len,\n    lengthSq: lengthSq,\n    lenSq: lenSq,\n    distance: distance,\n    dist: dist,\n    distanceSq: distanceSq,\n    distSq: distSq,\n    normalize: normalize,\n    negate: negate,\n    copy: copy,\n    clone: clone,\n    multiply: multiply,\n    mul: mul,\n    divide: divide,\n    div: div,\n    zero: zero,\n    transformMat4: transformMat4\n});\n\n/**\n * Sets the type this library creates for all types\n *\n * example:\n *\n * ```\n * setDefaultType(Float64Array);\n * ```\n *\n * @param ctor - the constructor for the type. Either `Float32Array`, `Float64Array`, or `Array`\n */\nfunction setDefaultType(ctor) {\n    setDefaultType$5(ctor);\n    setDefaultType$3(ctor);\n    setDefaultType$2(ctor);\n    setDefaultType$6(ctor);\n    setDefaultType$4(ctor);\n    setDefaultType$1(ctor);\n}\n\nexport { mat3Impl as mat3, mat4Impl as mat4, quatImpl as quat, setDefaultType, utils, vec2Impl as vec2, vec3Impl as vec3, vec4Impl as vec4 };\n//# sourceMappingURL=wgpu-matrix.module.js.map\n","import { mat4, vec3, mat3 } from 'wgpu-matrix';\n// for some reason this needs to be a bit different than the one in wgpu-matrix\nfunction getProjectionMatrix(znear, zfar, fovX, fovY) {\n    const tanHalfFovY = Math.tan(fovY / 2);\n    const tanHalfFovX = Math.tan(fovX / 2);\n    const top = tanHalfFovY * znear;\n    const bottom = -top;\n    const right = tanHalfFovX * znear;\n    const left = -right;\n    const P = mat4.create();\n    const z_sign = 1.0;\n    P[0] = (2.0 * znear) / (right - left);\n    P[5] = (2.0 * znear) / (top - bottom);\n    P[8] = (right + left) / (right - left);\n    P[9] = (top + bottom) / (top - bottom);\n    P[10] = z_sign * zfar / (zfar - znear);\n    P[11] = -(zfar * znear) / (zfar - znear);\n    P[14] = z_sign;\n    P[15] = 0.0;\n    return mat4.transpose(P);\n}\n// useful for coordinate flips\nfunction diagonal4x4(x, y, z, w) {\n    const m = mat4.create();\n    m[0] = x;\n    m[5] = y;\n    m[10] = z;\n    m[15] = w;\n    return m;\n}\n// A camera as used by the renderer. Interactivity is handled by InteractiveCamera.\nexport class Camera {\n    constructor(height, width, viewMatrix, perspective, focalX, focalY, scaleModifier) {\n        this.height = height;\n        this.width = width;\n        this.viewMatrix = viewMatrix;\n        this.perspective = perspective;\n        this.focalX = focalX;\n        this.focalY = focalY;\n        this.scaleModifier = scaleModifier;\n    }\n    static default() {\n        return new Camera(500, 500, mat4.lookAt([0, 0, 0], [0, 0, -1], [0, 1, 0]), mat4.perspective(Math.PI / 4, 1, 0.2, 100), 600, 600, 1);\n    }\n    // computes the depth of a point in camera space, for sorting\n    dotZ() {\n        const depthAxis = this.depthAxis();\n        return (v) => {\n            return vec3.dot(depthAxis, v);\n        };\n    }\n    // gets the camera position in world space, for evaluating the spherical harmonics\n    getPosition() {\n        const inverseViewMatrix = mat4.inverse(this.viewMatrix);\n        return mat4.getTranslation(inverseViewMatrix);\n    }\n    getProjMatrix() {\n        var flippedY = mat4.clone(this.perspective);\n        flippedY = mat4.mul(flippedY, diagonal4x4(1, -1, 1, 1));\n        return mat4.multiply(flippedY, this.viewMatrix);\n    }\n    // for camera interactions\n    translate(x, y, z) {\n        const viewInv = mat4.inverse(this.viewMatrix);\n        mat4.translate(viewInv, [x, y, z], viewInv);\n        mat4.inverse(viewInv, this.viewMatrix);\n    }\n    // for camera interactions\n    rotate(x, y, z) {\n        const viewInv = mat4.inverse(this.viewMatrix);\n        mat4.rotateX(viewInv, y, viewInv);\n        mat4.rotateY(viewInv, x, viewInv);\n        mat4.rotateZ(viewInv, z, viewInv);\n        mat4.inverse(viewInv, this.viewMatrix);\n    }\n    // the depth axis is the third column of the transposed view matrix\n    depthAxis() {\n        return mat4.getAxis(mat4.transpose(this.viewMatrix), 2);\n    }\n}\n// Adds interactivity to a camera. The camera is modified by the user's mouse and keyboard input.\nexport class InteractiveCamera {\n    constructor(camera, canvas) {\n        this.drag = false;\n        this.oldX = 0;\n        this.oldY = 0;\n        this.dRX = 0;\n        this.dRY = 0;\n        this.dRZ = 0;\n        this.dTX = 0;\n        this.dTY = 0;\n        this.dTZ = 0;\n        this.dirty = true;\n        this.camera = camera;\n        this.canvas = canvas;\n        this.createCallbacks();\n    }\n    static default(canvas) {\n        return new InteractiveCamera(Camera.default(), canvas);\n    }\n    createCallbacks() {\n        this.canvas.addEventListener('mousedown', (e) => {\n            this.drag = true;\n            this.oldX = e.pageX;\n            this.oldY = e.pageY;\n            this.setDirty();\n            e.preventDefault();\n        }, false);\n        this.canvas.addEventListener('mouseup', (e) => {\n            this.drag = false;\n        }, false);\n        this.canvas.addEventListener('mousemove', (e) => {\n            if (!this.drag)\n                return false;\n            this.dRX = (e.pageX - this.oldX) * 2 * Math.PI / this.canvas.width;\n            this.dRY = -(e.pageY - this.oldY) * 2 * Math.PI / this.canvas.height;\n            this.oldX = e.pageX;\n            this.oldY = e.pageY;\n            this.setDirty();\n            e.preventDefault();\n        }, false);\n        this.canvas.addEventListener('wheel', (e) => {\n            this.dTZ = e.deltaY * 0.1;\n            this.setDirty();\n            e.preventDefault();\n        }, false);\n        window.addEventListener('keydown', (e) => {\n            const keyMap = {\n                // translation\n                'w': () => { this.dTY -= 0.1; },\n                's': () => { this.dTY += 0.1; },\n                'a': () => { this.dTX -= 0.1; },\n                'd': () => { this.dTX += 0.1; },\n                'q': () => { this.dTZ += 0.1; },\n                'e': () => { this.dTZ -= 0.1; },\n                // rotation\n                'j': () => { this.dRX += 0.1; },\n                'l': () => { this.dRX -= 0.1; },\n                'i': () => { this.dRY += 0.1; },\n                'k': () => { this.dRY -= 0.1; },\n                'u': () => { this.dRZ += 0.1; },\n                'o': () => { this.dRZ -= 0.1; },\n            };\n            if (!keyMap[e.key]) {\n                return;\n            }\n            else {\n                keyMap[e.key]();\n                this.setDirty();\n                e.preventDefault();\n            }\n        }, false);\n    }\n    setNewCamera(newCamera) {\n        this.camera = newCamera;\n        this.setDirty();\n    }\n    setDirty() {\n        this.dirty = true;\n    }\n    setClean() {\n        this.dirty = false;\n    }\n    isDirty() {\n        return this.dirty;\n    }\n    getCamera() {\n        if (this.isDirty()) {\n            this.camera.translate(this.dTX, this.dTY, this.dTZ);\n            this.camera.rotate(this.dRX, this.dRY, this.dRZ);\n            this.dTX = this.dTY = this.dTZ = this.dRX = this.dRY = this.dRZ = 0;\n            this.setClean();\n        }\n        return this.camera;\n    }\n}\nfunction focal2fov(focal, pixels) {\n    return 2 * Math.atan(pixels / (2 * focal));\n}\nfunction worldToCamFromRT(R, t) {\n    const R_ = R;\n    const camToWorld = mat4.fromMat3(R_);\n    const minusT = vec3.mulScalar(t, -1);\n    mat4.translate(camToWorld, minusT, camToWorld);\n    return camToWorld;\n}\n// converting camera coordinate systems is always black magic :(\nfunction cameraFromJSON(rawCamera, canvasW, canvasH) {\n    const fovX = focal2fov(rawCamera.fx, rawCamera.width);\n    const fovY = focal2fov(rawCamera.fy, rawCamera.height);\n    const projectionMatrix = getProjectionMatrix(0.2, 100, fovX, fovY);\n    const R = mat3.create(...rawCamera.rotation.flat());\n    const T = rawCamera.position;\n    const viewMatrix = worldToCamFromRT(R, T);\n    return new Camera(canvasH, canvasW, viewMatrix, projectionMatrix, rawCamera.fx, rawCamera.fy, Math.max(canvasW / rawCamera.width, canvasH / rawCamera.height));\n}\n// A UI component that parses a JSON file containing a list of cameras and displays them as a list,\n// allowing the user to choose from presets.\nexport class CameraFileParser {\n    constructor(fileInput, listElement, canvas, cameraSetCallback) {\n        this.currentLineId = 0;\n        this.handleFileInputChange = (event) => {\n            var _a;\n            const file = (_a = this.fileInput.files) === null || _a === void 0 ? void 0 : _a[0];\n            if (file) {\n                const reader = new FileReader();\n                reader.onload = this.handleFileLoad;\n                reader.readAsText(file);\n            }\n        };\n        this.handleFileLoad = (event) => {\n            if (!event.target)\n                return;\n            const contents = event.target.result;\n            const jsonData = JSON.parse(contents);\n            this.currentLineId = 0;\n            this.listElement.innerHTML = '';\n            jsonData.forEach((cameraJSON) => {\n                this.currentLineId++;\n                const listItem = document.createElement('li');\n                const camera = cameraFromJSON(cameraJSON, this.canvas.width, this.canvas.height);\n                listItem.textContent = cameraJSON.img_name;\n                listItem.addEventListener('click', this.createCallbackForLine(camera));\n                this.listElement.appendChild(listItem);\n            });\n        };\n        this.createCallbackForLine = (camera) => {\n            return () => {\n                this.cameraSetCallback(camera);\n            };\n        };\n        this.fileInput = fileInput;\n        this.listElement = listElement;\n        this.canvas = canvas;\n        this.cameraSetCallback = cameraSetCallback;\n        this.fileInput.addEventListener('change', this.handleFileInputChange);\n    }\n}\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nexport class GpuContext {\n    constructor(gpu, adapter, device) {\n        this.gpu = gpu;\n        this.adapter = adapter;\n        this.device = device;\n    }\n    static create() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const gpu = navigator.gpu;\n            if (!gpu) {\n                return Promise.reject(\"WebGPU not supported on this browser! (navigator.gpu is null)\");\n            }\n            const adapter = yield gpu.requestAdapter();\n            if (!adapter) {\n                return Promise.reject(\"WebGPU not supported on this browser! (gpu.adapter is null)\");\n            }\n            const device = yield adapter.requestDevice({ label: \"GPUDevice\" });\n            return new GpuContext(gpu, adapter, device);\n        });\n    }\n    destroy() {\n        this.device.destroy();\n        this.adapter = null;\n        this.device = null;\n    }\n}\n","// Implements a bitonic argsort on the GPU.\n// It would be more efficient to use a radix sort, but this is simpler to implement.\nimport { GpuContext } from \"./gpu_context\";\nconst WGSIZE = 128;\nfunction bitonicSortShader(itemsPerThread) {\n    return `\n// Uniform buffer to store j and k\nstruct Uniforms {\n    j: u32,\n    k: u32,\n};\n\n@binding(0) @group(0) var<storage, read_write> data: array<vec4f>;\n@binding(1) @group(0) var<storage, read_write> indices: array<vec4<u32>>;\n@binding(2) @group(0) var<uniform> uniforms: Uniforms;\n\n@compute @workgroup_size(${WGSIZE})\nfn main(@builtin(global_invocation_id) global_id: vec3<u32>) {\n    let j = uniforms.j;\n    let k = uniforms.k;\n    \n    let max = (global_id.x + 1) * ${itemsPerThread};\n    for (var n = global_id.x * ${itemsPerThread}; n < max && (max ^ j) > max; n += 4) {\n       var datan = data[n / 4];\n       var indicesn = indices[n / 4];\n       var swap = false;\n       var dataixj = vec4f(0, 0, 0, 0);\n       var indicesixj = vec4<u32>(0, 0, 0, 0);\n       var lastIxjLoadedMajorIdx: u32 = 0;\n       for (var l: u32 = 0; l < 4; l++) {\n           let i = n + l;\n           let datai = datan[l];\n           let indicesi = indicesn[l];\n\n           let ixj = i ^ j;\n           if (ixj <= i) {\n               continue;\n           }\n\n           let ixjMajor = ixj / 4;\n           let ixjMinor = ixj % 4;\n           let writeToWorkgroupBlock = (ixjMajor == n / 4);\n           if (writeToWorkgroupBlock) {\n               dataixj = datan;\n               indicesixj = indicesn;\n               lastIxjLoadedMajorIdx = 0;\n           } else if (lastIxjLoadedMajorIdx != ixjMajor) {\n               if (lastIxjLoadedMajorIdx != 0) {\n                   data[lastIxjLoadedMajorIdx] = dataixj;\n                   indices[lastIxjLoadedMajorIdx] = indicesixj;\n               } \n               dataixj = data[ixjMajor];\n               indicesixj = indices[ixjMajor];\n               lastIxjLoadedMajorIdx = ixjMajor;\n           }\n\n           let swap_pos = ((i & k) == 0 && datai > dataixj[ixjMinor]);\n           let swap_neg = ((i & k) != 0 && datai < dataixj[ixjMinor]);\n\n           if (swap_pos || swap_neg) {\n               swap = true;\n               datan[l] = dataixj[ixjMinor];\n               dataixj[ixjMinor] = datai;\n               indicesn[l] = indicesixj[ixjMinor];\n               indicesixj[ixjMinor] = indicesi;\n               if (writeToWorkgroupBlock) {\n                   datan[ixjMinor] = datai;\n                   indicesn[ixjMinor] = indicesi;\n               }\n           }\n       }\n       if (swap) {\n           data[n / 4] = datan;\n           indices[n / 4] = indicesn;\n       }\n       if (lastIxjLoadedMajorIdx != 0) {\n          data[lastIxjLoadedMajorIdx] = dataixj;\n          indices[lastIxjLoadedMajorIdx] = indicesixj;\n       }\n    }\n}\n`;\n}\nexport class BitonicSorter {\n    constructor(context, nElements) {\n        if (Math.log2(nElements) % 1 != 0) {\n            throw new Error(\"nElements must be a power of 2\");\n        }\n        this.context = context;\n        this.nElements = nElements;\n        this.valuesBuffer = this.context.device.createBuffer({\n            size: this.nElements * 4,\n            usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST,\n            mappedAtCreation: false,\n            label: \"bitonicSorter.valuesBuffer\"\n        });\n        this.indicesBuffer = this.context.device.createBuffer({\n            size: this.nElements * 4,\n            usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST,\n            mappedAtCreation: false,\n            label: \"bitonicSorter.indicesBuffer\"\n        });\n        this.initialIndexBuffer = this.context.device.createBuffer({\n            size: this.nElements * 4,\n            usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC,\n            mappedAtCreation: true,\n            label: \"bitonicSorter.initialIndexBuffer\"\n        });\n        const initialIndices = new Uint32Array(this.initialIndexBuffer.getMappedRange());\n        for (let i = 0; i < this.nElements; i++) {\n            initialIndices[i] = i;\n        }\n        this.initialIndexBuffer.unmap();\n        this.numThreads = 8192;\n        const itemsPerThread = Math.ceil(this.nElements / this.numThreads);\n        this.pipeline = this.context.device.createComputePipeline({\n            compute: {\n                module: this.context.device.createShaderModule({\n                    code: bitonicSortShader(itemsPerThread),\n                }),\n                entryPoint: 'main',\n            },\n            layout: 'auto',\n        });\n        this.createUniforms();\n    }\n    createUniforms() {\n        const gpuBuffers = [];\n        const gpuBindGroups = [];\n        for (let k = 2; k <= this.nElements; k <<= 1) {\n            for (let j = k >> 1; j > 0; j = j >> 1) {\n                const bufferContent = new Uint32Array([j, k]);\n                const gpuBuffer = this.context.device.createBuffer({\n                    size: bufferContent.byteLength,\n                    usage: GPUBufferUsage.UNIFORM,\n                    mappedAtCreation: true,\n                    label: `bitonicSorter.uniformsBuffer.k=${k}.j=${j}`\n                });\n                new Uint32Array(gpuBuffer.getMappedRange()).set(bufferContent);\n                gpuBuffer.unmap();\n                const gpuBindGroup = this.context.device.createBindGroup({\n                    layout: this.pipeline.getBindGroupLayout(0),\n                    entries: [\n                        {\n                            binding: 0,\n                            resource: {\n                                buffer: this.valuesBuffer\n                            },\n                        },\n                        {\n                            binding: 1,\n                            resource: {\n                                buffer: this.indicesBuffer,\n                            },\n                        },\n                        {\n                            binding: 2,\n                            resource: {\n                                buffer: gpuBuffer\n                            },\n                        },\n                    ],\n                });\n                gpuBuffers.push(gpuBuffer);\n                gpuBindGroups.push(gpuBindGroup);\n            }\n        }\n        this.uniformBuffers = gpuBuffers;\n        this.bindGroups = gpuBindGroups;\n    }\n    destroy() {\n        this.valuesBuffer.destroy();\n        this.indicesBuffer.destroy();\n        this.initialIndexBuffer.destroy();\n        for (const uniformBuffer of this.uniformBuffers) {\n            uniformBuffer.destroy();\n        }\n    }\n    argsort(values) {\n        if (values.size != this.valuesBuffer.size) {\n            throw new Error(\"Input buffer size does not match the size of the sorter\");\n        }\n        // Copy the data to the GPU\n        const commandEncoder = this.context.device.createCommandEncoder();\n        // clear just in case\n        commandEncoder.clearBuffer(this.valuesBuffer);\n        // copy the values\n        commandEncoder.copyBufferToBuffer(values, 0, this.valuesBuffer, 0, values.size);\n        // write the initial indices\n        commandEncoder.copyBufferToBuffer(this.initialIndexBuffer, 0, this.indicesBuffer, 0, this.initialIndexBuffer.size);\n        // Sort by dispatching the compute shader for each uniform buffer\n        for (const uniformBindGroup of this.bindGroups) {\n            const passEncoder = commandEncoder.beginComputePass();\n            passEncoder.setPipeline(this.pipeline);\n            passEncoder.setBindGroup(0, uniformBindGroup);\n            passEncoder.dispatchWorkgroups(this.numThreads / WGSIZE);\n            passEncoder.end();\n        }\n        this.context.device.queue.submit([commandEncoder.finish()]);\n        return this.indicesBuffer;\n    }\n}\nexport function testBitonic() {\n    // Usage example\n    const values = new Float32Array(1 << 10);\n    for (let i = 0; i < values.length; i++) {\n        values[i] = Math.random();\n    }\n    // reference CPU argsort\n    const valuesWithIndices = [];\n    for (let i = 0; i < values.length; i++) {\n        valuesWithIndices.push([values[i], i]);\n    }\n    valuesWithIndices.sort((a, b) => a[0] - b[0]);\n    const cpuResult = new Uint32Array(values.length);\n    for (let i = 0; i < values.length; i++) {\n        cpuResult[i] = valuesWithIndices[i][1];\n    }\n    console.log(cpuResult);\n    // GPU argsort\n    GpuContext.create().then(context => {\n        const sorter = new BitonicSorter(context, values.length);\n        const valuesBuffer = context.device.createBuffer({\n            size: values.byteLength,\n            usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST,\n            mappedAtCreation: true,\n            label: \"testBitonic.valuesBuffer\"\n        });\n        new Float32Array(valuesBuffer.getMappedRange()).set(values);\n        valuesBuffer.unmap();\n        const argSortBuffer = sorter.argsort(valuesBuffer);\n        const readBuffer = context.device.createBuffer({\n            size: values.byteLength,\n            usage: GPUBufferUsage.MAP_READ | GPUBufferUsage.COPY_DST,\n            mappedAtCreation: false,\n            label: \"testBitonic.readBuffer\"\n        });\n        const commandEncoder = context.device.createCommandEncoder();\n        commandEncoder.copyBufferToBuffer(argSortBuffer, 0, readBuffer, 0, values.byteLength);\n        context.device.queue.submit([commandEncoder.finish()]);\n        readBuffer.mapAsync(GPUMapMode.READ).then(() => {\n            const result = new Uint32Array(readBuffer.getMappedRange());\n            console.log(result);\n            readBuffer.unmap();\n        });\n    });\n}\n","// The bitonic sort algorithm itself is implemented in bitonic.ts\n// but we need to do some extra work to sort the depth buffer:\n// 1. compute the depth of each vertex\n// 2. pad the depth buffer to the next power of 2\n// 3. sort the depth buffer\n// 4. copy the indices to the index buffer, replicating each index 6 times (since each quad has 6 vertices)\n//\n// This file implements steps 1, 2 and 4.\nimport { BitonicSorter } from './bitonic';\nimport { f32, mat4x4 } from './packing';\nfunction nextPowerOfTwo(x) {\n    return Math.pow(2, Math.ceil(Math.log2(x)));\n}\n// the depth of each vertex is computed, the excess space is padded with +inf\nfunction computeDepthShader(itemsPerThread, numQuadsUnpadded) {\n    return `\n@group(0) @binding(0) var<storage, read> vertices: array<vec3<f32>>;\n@group(0) @binding(1) var<storage, read_write> depths: array<f32>;\n@group(0) @binding(2) var<uniform> projMatrix: mat4x4<f32>;\n\n@compute @workgroup_size(64)\nfn main(@builtin(global_invocation_id) global_id: vec3<u32>) {\n    for (var i = global_id.x * ${itemsPerThread}; i < (global_id.x + 1) * ${itemsPerThread}; i++) {\n        //if (i >= arrayLength(&vertices)) {\n        if (i >= ${numQuadsUnpadded}) {\n            depths[i] = 1e20f; // pad with +inf\n        } else {\n            let pos = vertices[i];\n            let projPos = projMatrix * vec4<f32>(pos, 1.0);\n            depths[i] = projPos.z;\n        }\n    }\n}\n`;\n}\n// each quad index is repeated 6 times, once for each vertex\nfunction copyToIndexBufferShader(itemsPerThread, numQuadsUnpadded) {\n    return `\nstruct IndexVertex {\n    vec1: u32,\n    vec2: u32,\n    vec3: u32,\n    vec4: u32,\n    vec5: u32,\n    vec6: u32,\n};\n\n@group(0) @binding(0) var<storage, read> indices: array<u32>;\n@group(0) @binding(1) var<storage, read_write> indexBuffer: array<IndexVertex>;\n\nvar<private> vertex: IndexVertex;\n\n@compute @workgroup_size(64)\nfn main(@builtin(global_invocation_id) global_id: vec3<u32>) {\n    for (var i = global_id.x * ${itemsPerThread}; i < (global_id.x + 1) * ${itemsPerThread}; i++) {\n        if (i >= ${numQuadsUnpadded}) {\n            break;\n        }\n        let index = indices[i];\n\n        vertex.vec1 = index * 6 + 0;\n        vertex.vec2 = index * 6 + 1;\n        vertex.vec3 = index * 6 + 2;\n        vertex.vec4 = index * 6 + 3;\n        vertex.vec5 = index * 6 + 4;\n        vertex.vec6 = index * 6 + 5;\n        indexBuffer[i] = vertex;\n    }\n}\n`;\n}\nconst projMatrixLayout = new mat4x4(f32);\nexport class DepthSorter {\n    constructor(context, gaussians) {\n        this.context = context;\n        this.nUnpadded = gaussians.numGaussians;\n        this.nPadded = nextPowerOfTwo(this.nUnpadded);\n        this.numThreads = 2048;\n        // buffer for the vertex positions, set once\n        this.positionsBuffer = this.context.device.createBuffer({\n            size: gaussians.positionsArrayLayout.size,\n            usage: GPUBufferUsage.STORAGE,\n            mappedAtCreation: true,\n            label: \"depthSorter.positionsBuffer\"\n        });\n        new Uint8Array(this.positionsBuffer.getMappedRange()).set(new Uint8Array(gaussians.positionsBuffer));\n        this.positionsBuffer.unmap();\n        // buffer for the depth values, computed each time using uniforms, padded to next power of 2\n        this.depthBuffer = this.context.device.createBuffer({\n            size: this.nPadded * 4,\n            usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC,\n            label: \"depthSorter.depthBuffer\"\n        });\n        // buffer for the projection matrix, set at each frame\n        this.projMatrixBuffer = this.context.device.createBuffer({\n            size: projMatrixLayout.size,\n            usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,\n            label: \"depthSorter.projMatrixBuffer\"\n        });\n        // manually create the bind group layout because\n        // this.computeDepthPipeline.getBindGroupLayout(0) doesn't work for some reason\n        const computeDepthBindGroupLayout = this.context.device.createBindGroupLayout({\n            entries: [\n                {\n                    binding: 0,\n                    visibility: GPUShaderStage.COMPUTE,\n                    buffer: {\n                        type: 'read-only-storage',\n                    },\n                },\n                {\n                    binding: 1,\n                    visibility: GPUShaderStage.COMPUTE,\n                    buffer: {\n                        type: 'storage',\n                    },\n                },\n                {\n                    binding: 2,\n                    visibility: GPUShaderStage.COMPUTE,\n                    buffer: {\n                        type: 'uniform',\n                    },\n                },\n            ],\n        });\n        const computeDepthPipelineLayout = this.context.device.createPipelineLayout({\n            bindGroupLayouts: [computeDepthBindGroupLayout],\n        });\n        const paddedPerThread = Math.ceil(this.nPadded / this.numThreads);\n        this.computeDepthPipeline = this.context.device.createComputePipeline({\n            layout: computeDepthPipelineLayout,\n            compute: {\n                module: this.context.device.createShaderModule({\n                    code: computeDepthShader(paddedPerThread, this.nUnpadded),\n                }),\n                entryPoint: 'main',\n            },\n        });\n        this.computeDepthBindGroup = this.context.device.createBindGroup({\n            //layout: this.computeDepthPipeline.getBindGroupLayout(0), // this doesn't work for some reason\n            layout: computeDepthBindGroupLayout,\n            entries: [\n                {\n                    binding: 0,\n                    resource: {\n                        buffer: this.positionsBuffer,\n                    },\n                },\n                {\n                    binding: 1,\n                    resource: {\n                        buffer: this.depthBuffer,\n                    },\n                },\n                {\n                    binding: 2,\n                    resource: {\n                        buffer: this.projMatrixBuffer,\n                    },\n                },\n            ],\n        });\n        this.sorter = new BitonicSorter(this.context, this.nPadded);\n        // buffer for the resulting index buffer, per vertex, 6 * #nElements\n        this.indexBuffer = this.context.device.createBuffer({\n            size: this.nUnpadded * 6 * 4,\n            usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC,\n            label: \"depthSorter.indexBuffer\"\n        });\n        const unpaddedPerThread = Math.ceil(this.nUnpadded / this.numThreads);\n        this.copyToIndexBufferPipeline = this.context.device.createComputePipeline({\n            compute: {\n                module: this.context.device.createShaderModule({\n                    code: copyToIndexBufferShader(unpaddedPerThread, this.nUnpadded),\n                }),\n                entryPoint: 'main',\n            },\n            layout: 'auto',\n        });\n        this.copyToIndexBufferBindGroup = this.context.device.createBindGroup({\n            layout: this.copyToIndexBufferPipeline.getBindGroupLayout(0),\n            entries: [\n                {\n                    binding: 0,\n                    resource: {\n                        buffer: this.sorter.indicesBuffer,\n                    },\n                },\n                {\n                    binding: 1,\n                    resource: {\n                        buffer: this.indexBuffer,\n                    },\n                },\n            ],\n        });\n    }\n    destroy() {\n        this.positionsBuffer.destroy();\n        this.depthBuffer.destroy();\n        this.projMatrixBuffer.destroy();\n        this.indexBuffer.destroy();\n        this.sorter.destroy();\n    }\n    sort(projMatrix) {\n        const projMatrixCpuBuffer = new ArrayBuffer(projMatrixLayout.size);\n        projMatrixLayout.pack(0, projMatrix, new DataView(projMatrixCpuBuffer));\n        this.context.device.queue.writeBuffer(this.projMatrixBuffer, 0, projMatrixCpuBuffer, 0, projMatrixCpuBuffer.byteLength);\n        { // compute the depth of each vertex\n            const commandEncoder = this.context.device.createCommandEncoder();\n            const passEncoder = commandEncoder.beginComputePass();\n            passEncoder.setPipeline(this.computeDepthPipeline);\n            passEncoder.setBindGroup(0, this.computeDepthBindGroup);\n            passEncoder.dispatchWorkgroups(this.numThreads / 64);\n            passEncoder.end();\n            this.context.device.queue.submit([commandEncoder.finish()]);\n        }\n        // discard the result because we have already bound\n        // this.sorter.indicesBuffer to the copyToIndexBufferBindGroup\n        this.sorter.argsort(this.depthBuffer);\n        { // copy the indices to the index buffer\n            const commandEncoder = this.context.device.createCommandEncoder();\n            const passEncoder = commandEncoder.beginComputePass();\n            passEncoder.setPipeline(this.copyToIndexBufferPipeline);\n            passEncoder.setBindGroup(0, this.copyToIndexBufferBindGroup);\n            passEncoder.dispatchWorkgroups(this.numThreads / 64);\n            passEncoder.end();\n            this.context.device.queue.submit([commandEncoder.finish()]);\n        }\n        return this.indexBuffer;\n    }\n}\n","// This file contains the main rendering code. Unlike the official implementation,\n// instead of using compute shaders and iterating through (possibly) all gaussians,\n// we instead use a vertex shader to turn each gaussian into a quad facing the camera\n// and then use the fragment shader to paint the gaussian on the quad.\n// If we draw the quads in order of depth, with well chosen blending settings we can\n// get the same color accumulation rule as in the original paper.\n// This approach is faster than the original implementation on webGPU but still substantially\n// slow compared to the CUDA impl. The main bottleneck is the sorting of the quads by depth,\n// which is done on the CPU but could presumably be replaced by a compute shader sort.\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { f32, Struct, vec3, mat4x4 } from './packing';\nimport { getShaderCode } from './shaders';\nimport { GpuContext } from './gpu_context';\nimport { DepthSorter } from './depth_sorter';\nconst uniformLayout = new Struct([\n    ['viewMatrix', new mat4x4(f32)],\n    ['projMatrix', new mat4x4(f32)],\n    ['cameraPosition', new vec3(f32)],\n    ['tanHalfFovX', f32],\n    ['tanHalfFovY', f32],\n    ['focalX', f32],\n    ['focalY', f32],\n    ['scaleModifier', f32],\n]);\nfunction mat4toArrayOfArrays(m) {\n    return [\n        [m[0], m[1], m[2], m[3]],\n        [m[4], m[5], m[6], m[7]],\n        [m[8], m[9], m[10], m[11]],\n        [m[12], m[13], m[14], m[15]],\n    ];\n}\nexport class Renderer {\n    static requestContext(gaussians) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const gpu = navigator.gpu;\n            if (!gpu) {\n                return Promise.reject(\"WebGPU not supported on this browser! (navigator.gpu is null)\");\n            }\n            const adapter = yield gpu.requestAdapter();\n            if (!adapter) {\n                return Promise.reject(\"WebGPU not supported on this browser! (gpu.adapter is null)\");\n            }\n            // for good measure, we request 1.5 times the amount of memory we need\n            const byteLength = gaussians.gaussiansBuffer.byteLength;\n            const device = yield adapter.requestDevice({\n                requiredLimits: {\n                    maxStorageBufferBindingSize: 1.5 * byteLength,\n                    maxBufferSize: 1.5 * byteLength,\n                }\n            });\n            return new GpuContext(gpu, adapter, device);\n        });\n    }\n    // destroy the renderer and return a promise that resolves when it's done (after the next frame)\n    destroy() {\n        return __awaiter(this, void 0, void 0, function* () {\n            return new Promise((resolve, reject) => {\n                this.destroyCallback = resolve;\n            });\n        });\n    }\n    constructor(canvas, interactiveCamera, gaussians, context, fpsCounter) {\n        this.destroyCallback = null;\n        this.canvas = canvas;\n        this.interactiveCamera = interactiveCamera;\n        this.context = context;\n        const contextGpu = canvas.getContext(\"webgpu\");\n        if (!contextGpu) {\n            throw new Error(\"WebGPU context not found!\");\n        }\n        this.contextGpu = contextGpu;\n        this.fpsCounter = fpsCounter;\n        this.lastDraw = performance.now();\n        this.numGaussians = gaussians.numGaussians;\n        const presentationFormat = \"rgba16float\";\n        this.contextGpu.configure({\n            device: this.context.device,\n            format: presentationFormat,\n            alphaMode: 'premultiplied',\n        });\n        this.pointDataBuffer = this.context.device.createBuffer({\n            size: gaussians.gaussianArrayLayout.size,\n            usage: GPUBufferUsage.STORAGE,\n            mappedAtCreation: true,\n            label: \"renderer.pointDataBuffer\",\n        });\n        new Uint8Array(this.pointDataBuffer.getMappedRange()).set(new Uint8Array(gaussians.gaussiansBuffer));\n        this.pointDataBuffer.unmap();\n        // Create a GPU buffer for the uniform data.\n        this.uniformBuffer = this.context.device.createBuffer({\n            size: uniformLayout.size,\n            usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,\n            label: \"renderer.uniformBuffer\",\n        });\n        const shaderCode = getShaderCode(canvas, gaussians.sphericalHarmonicsDegree, gaussians.nShCoeffs);\n        const shaderModule = this.context.device.createShaderModule({ code: shaderCode });\n        this.drawPipeline = this.context.device.createRenderPipeline({\n            layout: \"auto\",\n            vertex: {\n                module: shaderModule,\n                entryPoint: \"vs_points\",\n            },\n            fragment: {\n                module: shaderModule,\n                entryPoint: \"fs_main\",\n                targets: [\n                    {\n                        format: presentationFormat,\n                        // with one-minus-dst alpha we can set the src to src.alpha * src.color and\n                        // we get that color_new = src.color * src.alpha + dst.color * (1 - src.alpha)\n                        // which is the same as the accumulation rule in the paper\n                        blend: {\n                            color: {\n                                srcFactor: \"one-minus-dst-alpha\",\n                                dstFactor: \"one\",\n                                operation: \"add\",\n                            },\n                            alpha: {\n                                srcFactor: \"one-minus-dst-alpha\",\n                                dstFactor: \"one\",\n                                operation: \"add\",\n                            },\n                        }\n                    },\n                ],\n            },\n            primitive: {\n                topology: \"triangle-list\",\n                stripIndexFormat: undefined,\n                cullMode: undefined,\n            },\n        });\n        this.uniformsBindGroup = this.context.device.createBindGroup({\n            layout: this.drawPipeline.getBindGroupLayout(0),\n            entries: [{\n                    binding: 0,\n                    resource: {\n                        buffer: this.uniformBuffer,\n                    },\n                }],\n        });\n        this.pointDataBindGroup = this.context.device.createBindGroup({\n            layout: this.drawPipeline.getBindGroupLayout(1),\n            entries: [{\n                    binding: 1,\n                    resource: {\n                        buffer: this.pointDataBuffer,\n                    },\n                }],\n        });\n        this.depthSorter = new DepthSorter(this.context, gaussians);\n        this.drawIndexBuffer = this.context.device.createBuffer({\n            size: 6 * 4 * gaussians.numGaussians,\n            usage: GPUBufferUsage.INDEX | GPUBufferUsage.COPY_DST,\n            mappedAtCreation: false,\n            label: \"renderer.drawIndexBuffer\",\n        });\n        // start the animation loop\n        requestAnimationFrame(() => this.animate(true));\n    }\n    destroyImpl() {\n        if (this.destroyCallback === null) {\n            throw new Error(\"destroyImpl called without destroyCallback set!\");\n        }\n        this.uniformBuffer.destroy();\n        this.pointDataBuffer.destroy();\n        this.drawIndexBuffer.destroy();\n        this.depthSorter.destroy();\n        this.context.destroy();\n        this.destroyCallback();\n    }\n    draw(nextFrameCallback) {\n        const commandEncoder = this.context.device.createCommandEncoder();\n        // sort the draw order\n        const indexBufferSrc = this.depthSorter.sort(this.depthSortMatrix);\n        // copy the draw order to the draw index buffer\n        commandEncoder.copyBufferToBuffer(indexBufferSrc, 0, this.drawIndexBuffer, 0, 6 * 4 * this.depthSorter.nUnpadded);\n        const textureView = this.contextGpu.getCurrentTexture().createView();\n        const renderPassDescriptor = {\n            colorAttachments: [{\n                    view: textureView,\n                    clearValue: { r: 0, g: 0, b: 0, a: 0 },\n                    storeOp: \"store\",\n                    loadOp: \"clear\",\n                }],\n        };\n        const passEncoder = commandEncoder.beginRenderPass(renderPassDescriptor);\n        passEncoder.setPipeline(this.drawPipeline);\n        passEncoder.setBindGroup(0, this.uniformsBindGroup);\n        passEncoder.setBindGroup(1, this.pointDataBindGroup);\n        passEncoder.setIndexBuffer(this.drawIndexBuffer, \"uint32\");\n        passEncoder.drawIndexed(this.numGaussians * 6, 1, 0, 0, 0);\n        passEncoder.end();\n        this.context.device.queue.submit([commandEncoder.finish()]);\n        // fps counter\n        const now = performance.now();\n        const fps = 1000 / (now - this.lastDraw);\n        this.lastDraw = now;\n        this.fpsCounter.innerText = 'FPS: ' + fps.toFixed(2);\n        this.fpsCounter.style.display = 'block';\n        requestAnimationFrame(nextFrameCallback);\n    }\n    animate(forceDraw) {\n        if (this.destroyCallback !== null) {\n            this.destroyImpl();\n            return;\n        }\n        if (!this.interactiveCamera.isDirty() && !forceDraw) {\n            requestAnimationFrame(() => this.animate());\n            return;\n        }\n        const camera = this.interactiveCamera.getCamera();\n        const position = camera.getPosition();\n        const tanHalfFovX = 0.5 * this.canvas.width / camera.focalX;\n        const tanHalfFovY = 0.5 * this.canvas.height / camera.focalY;\n        this.depthSortMatrix = mat4toArrayOfArrays(camera.viewMatrix);\n        let uniformsMatrixBuffer = new ArrayBuffer(this.uniformBuffer.size);\n        let uniforms = {\n            viewMatrix: mat4toArrayOfArrays(camera.viewMatrix),\n            projMatrix: mat4toArrayOfArrays(camera.getProjMatrix()),\n            cameraPosition: Array.from(position),\n            tanHalfFovX: tanHalfFovX,\n            tanHalfFovY: tanHalfFovY,\n            focalX: camera.focalX,\n            focalY: camera.focalY,\n            scaleModifier: camera.scaleModifier,\n        };\n        uniformLayout.pack(0, uniforms, new DataView(uniformsMatrixBuffer));\n        this.context.device.queue.writeBuffer(this.uniformBuffer, 0, uniformsMatrixBuffer, 0, uniformsMatrixBuffer.byteLength);\n        this.draw(() => this.animate());\n    }\n}\n","const shDeg3Code = `\n    // spherical harmonic coefficients\n    const SH_C0 = 0.28209479177387814f;\n    const SH_C1 = 0.4886025119029199f;\n    const SH_C2 = array(\n        1.0925484305920792f,\n        -1.0925484305920792f,\n        0.31539156525252005f,\n        -1.0925484305920792f,\n        0.5462742152960396f\n    );\n    const SH_C3 = array(\n        -0.5900435899266435f,\n        2.890611442640554f,\n        -0.4570457994644658f,\n        0.3731763325901154f,\n        -0.4570457994644658f,\n        1.445305721320277f,\n        -0.5900435899266435f\n    );\n\n    fn compute_color_from_sh(position: vec3<f32>, sh: array<vec3<f32>, 16>) -> vec3<f32> {\n        let dir = normalize(position - uniforms.camera_position);\n        var result = SH_C0 * sh[0];\n\n        // if deg > 0\n        let x = dir.x;\n        let y = dir.y;\n        let z = dir.z;\n\n        result = result + SH_C1 * (-y * sh[1] + z * sh[2] - x * sh[3]);\n\n        let xx = x * x;\n        let yy = y * y;\n        let zz = z * z;\n        let xy = x * y;\n        let xz = x * z;\n        let yz = y * z;\n\n        // if (sh_degree > 1) {\n        result = result +\n            SH_C2[0] * xy * sh[4] +\n            SH_C2[1] * yz * sh[5] +\n            SH_C2[2] * (2. * zz - xx - yy) * sh[6] +\n            SH_C2[3] * xz * sh[7] +\n            SH_C2[4] * (xx - yy) * sh[8];\n        \n        // if (sh_degree > 2) {\n        result = result +\n            SH_C3[0] * y * (3. * xx - yy) * sh[9] +\n            SH_C3[1] * xy * z * sh[10] +\n            SH_C3[2] * y * (4. * zz - xx - yy) * sh[11] +\n            SH_C3[3] * z * (2. * zz - 3. * xx - 3. * yy) * sh[12] +\n            SH_C3[4] * x * (4. * zz - xx - yy) * sh[13] +\n            SH_C3[5] * z * (xx - yy) * sh[14] +\n            SH_C3[6] * x * (xx - 3. * yy) * sh[15];\n\n        // unconditional\n        result = result + 0.5;\n\n        return max(result, vec3<f32>(0.));\n    }\n`;\nconst shDeg2Code = `\n    // spherical harmonic coefficients\n    const SH_C0 = 0.28209479177387814f;\n    const SH_C1 = 0.4886025119029199f;\n    const SH_C2 = array(\n        1.0925484305920792f,\n        -1.0925484305920792f,\n        0.31539156525252005f,\n        -1.0925484305920792f,\n        0.5462742152960396f\n    );\n\n    fn compute_color_from_sh(position: vec3<f32>, sh: array<vec3<f32>, 9>) -> vec3<f32> {\n        let dir = normalize(position - uniforms.camera_position);\n        var result = SH_C0 * sh[0];\n\n        // if deg > 0\n        let x = dir.x;\n        let y = dir.y;\n        let z = dir.z;\n\n        result = result + SH_C1 * (-y * sh[1] + z * sh[2] - x * sh[3]);\n\n        let xx = x * x;\n        let yy = y * y;\n        let zz = z * z;\n        let xy = x * y;\n        let xz = x * z;\n        let yz = y * z;\n\n        // if (sh_degree > 1) {\n        result = result +\n            SH_C2[0] * xy * sh[4] +\n            SH_C2[1] * yz * sh[5] +\n            SH_C2[2] * (2. * zz - xx - yy) * sh[6] +\n            SH_C2[3] * xz * sh[7] +\n            SH_C2[4] * (xx - yy) * sh[8];\n        \n        // unconditional\n        result = result + 0.5;\n\n        return max(result, vec3<f32>(0.));\n    }\n`;\nconst shDeg1Code = `\n    // spherical harmonic coefficients\n    const SH_C0 = 0.28209479177387814f;\n    const SH_C1 = 0.4886025119029199f;\n\n    fn compute_color_from_sh(position: vec3<f32>, sh: array<vec3<f32>, 4>) -> vec3<f32> {\n        let dir = normalize(position - uniforms.camera_position);\n        var result = SH_C0 * sh[0];\n\n        // if deg > 0\n        let x = dir.x;\n        let y = dir.y;\n        let z = dir.z;\n\n        result = result + SH_C1 * (-y * sh[1] + z * sh[2] - x * sh[3]);\n\n        // unconditional\n        result = result + 0.5;\n\n        return max(result, vec3<f32>(0.));\n    }\n`;\nexport function getShaderCode(canvas, shDegree, nShCoeffs) {\n    const shComputeCode = {\n        1: shDeg1Code,\n        2: shDeg2Code,\n        3: shDeg3Code,\n    }[shDegree];\n    const shaderCode = `\n// for some reason passing these as uniform is broken\nconst canvas_height = ${canvas.height};\nconst canvas_width = ${canvas.width};\nconst sh_degree = ${shDegree};\nconst n_sh_coeffs = ${nShCoeffs};\n\nstruct PointInput {\n    @location(0) position: vec3<f32>,\n    @location(1) log_scale: vec3<f32>,\n    @location(2) rot: vec4<f32>,\n    @location(3) opacity_logit: f32,\n    sh: array<vec3<f32>, n_sh_coeffs>,\n};\n\nstruct PointOutput {\n    @builtin(position) position: vec4<f32>,\n    @location(0) color: vec3<f32>,\n    @location(1) uv: vec2<f32>,\n    @location(2) conic_and_opacity: vec4<f32>,\n};\n\nstruct Uniforms {\n    viewMatrix: mat4x4<f32>,\n    projMatrix: mat4x4<f32>,\n    camera_position: vec3<f32>,\n    tan_fovx: f32,\n    tan_fovy: f32,\n    focal_x: f32,\n    focal_y: f32,\n    scale_modifier: f32,\n};\n\n${shComputeCode}\n\nfn sigmoid(x: f32) -> f32 {\n    if (x >= 0.) {\n        return 1. / (1. + exp(-x));\n    } else {\n        let z = exp(x);\n        return z / (1. + z);\n    }\n}\n\nfn compute_cov3d(log_scale: vec3<f32>, rot: vec4<f32>) -> array<f32, 6> {\n    let modifier = uniforms.scale_modifier;\n    let S = mat3x3<f32>(\n        exp(log_scale.x) * modifier, 0., 0.,\n        0., exp(log_scale.y) * modifier, 0.,\n        0., 0., exp(log_scale.z) * modifier,\n    );\n\n    let r = rot.x;\n    let x = rot.y;\n    let y = rot.z;\n    let z = rot.w;\n\n    let R = mat3x3<f32>(\n        1. - 2. * (y * y + z * z), 2. * (x * y - r * z), 2. * (x * z + r * y),\n        2. * (x * y + r * z), 1. - 2. * (x * x + z * z), 2. * (y * z - r * x),\n        2. * (x * z - r * y), 2. * (y * z + r * x), 1. - 2. * (x * x + y * y),\n    );\n\n    let M = S * R;\n    let Sigma = transpose(M) * M;\n\n    return array<f32, 6>(\n        Sigma[0][0],\n        Sigma[0][1],\n        Sigma[0][2],\n        Sigma[1][1],\n        Sigma[1][2],\n        Sigma[2][2],\n    );\n} \n\nfn ndc2pix(v: f32, size: u32) -> f32 {\n    return ((v + 1.0) * f32(size) - 1.0) * 0.5;\n}\n\nfn compute_cov2d(position: vec3<f32>, log_scale: vec3<f32>, rot: vec4<f32>) -> vec3<f32> {\n    let cov3d = compute_cov3d(log_scale, rot);\n\n    var t = uniforms.viewMatrix * vec4<f32>(position, 1.0);\n\n    let limx = 1.3 * uniforms.tan_fovx;\n    let limy = 1.3 * uniforms.tan_fovy;\n    let txtz = t.x / t.z;\n    let tytz = t.y / t.z;\n\n    t.x = min(limx, max(-limx, txtz)) * t.z;\n    t.y = min(limy, max(-limy, tytz)) * t.z;\n\n    let J = mat4x4(\n        uniforms.focal_x / t.z, 0., -(uniforms.focal_x * t.x) / (t.z * t.z), 0.,\n        0., uniforms.focal_y / t.z, -(uniforms.focal_y * t.y) / (t.z * t.z), 0.,\n        0., 0., 0., 0.,\n        0., 0., 0., 0.,\n    );\n\n    let W = transpose(uniforms.viewMatrix);\n\n    let T = W * J;\n\n    let Vrk = mat4x4(\n        cov3d[0], cov3d[1], cov3d[2], 0.,\n        cov3d[1], cov3d[3], cov3d[4], 0.,\n        cov3d[2], cov3d[4], cov3d[5], 0.,\n        0., 0., 0., 0.,\n    );\n\n    var cov = transpose(T) * transpose(Vrk) * T;\n\n    // Apply low-pass filter: every Gaussian should be at least\n    // one pixel wide/high. Discard 3rd row and column.\n    cov[0][0] += 0.3;\n    cov[1][1] += 0.3;\n\n    return vec3<f32>(cov[0][0], cov[0][1], cov[1][1]);\n}\n\n\n@binding(0) @group(0) var<uniform> uniforms: Uniforms;\n@binding(1) @group(1) var<storage, read> points: array<PointInput>;\n\nconst quadVertices = array<vec2<f32>, 6>(\n    vec2<f32>(-1.0, -1.0),\n    vec2<f32>(-1.0, 1.0),\n    vec2<f32>(1.0, -1.0),\n    vec2<f32>(1.0, 1.0),\n    vec2<f32>(-1.0, 1.0),\n    vec2<f32>(1.0, -1.0),\n);\n\n@vertex\nfn vs_points(@builtin(vertex_index) vertex_index: u32) -> PointOutput {\n    var output: PointOutput;\n    let pointIndex = vertex_index / 6u;\n    let quadIndex = vertex_index % 6u;\n    let quadOffset = quadVertices[quadIndex];\n    let point = points[pointIndex];\n\n    let cov2d = compute_cov2d(point.position, point.log_scale, point.rot);\n    let det = cov2d.x * cov2d.z - cov2d.y * cov2d.y;\n    let det_inv = 1.0 / det;\n    let conic = vec3<f32>(cov2d.z * det_inv, -cov2d.y * det_inv, cov2d.x * det_inv);\n    let mid = 0.5 * (cov2d.x + cov2d.z);\n    let lambda_1 = mid + sqrt(max(0.1, mid * mid - det));\n    let lambda_2 = mid - sqrt(max(0.1, mid * mid - det));\n    let radius_px = ceil(3. * sqrt(max(lambda_1, lambda_2)));\n    let radius_ndc = vec2<f32>(\n    radius_px / (canvas_height),\n    radius_px / (canvas_width),\n    );\n    output.conic_and_opacity = vec4<f32>(conic, sigmoid(point.opacity_logit));\n\n    var projPosition = uniforms.projMatrix * vec4<f32>(point.position, 1.0);\n    projPosition = projPosition / projPosition.w;\n    output.position = vec4<f32>(projPosition.xy + 2 * radius_ndc * quadOffset, projPosition.zw);\n    output.color = compute_color_from_sh(point.position, point.sh);\n    output.uv = radius_px * quadOffset;\n\n    return output;\n}\n\n@fragment\nfn fs_main(input: PointOutput) -> @location(0) vec4<f32> {\n    // we want the distance from the gaussian to the fragment while uv\n    // is the reverse\n    let d = -input.uv;\n    let conic = input.conic_and_opacity.xyz;\n    let power = -0.5 * (conic.x * d.x * d.x + conic.z * d.y * d.y) + conic.y * d.x * d.y;\n    let opacity = input.conic_and_opacity.w;\n\n    if (power > 0.0) {\n    discard;\n    }\n\n    let alpha = min(0.99, opacity * exp(power));\n\n    return vec4<f32>(input.color * alpha, alpha);\n}\n`;\n    return shaderCode;\n}\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { loadFileAsArrayBuffer, PackedGaussians } from './ply';\nimport { CameraFileParser, InteractiveCamera } from './camera';\nimport { Renderer } from './renderer';\nif (!navigator.gpu) {\n    alert(\"WebGPU not supported on this browser! (navigator.gpu is null)\");\n}\n// grab the DOM elements\nconst canvas = document.getElementById(\"canvas-webgpu\");\nconst loadingPopup = document.getElementById('loading-popup');\nconst fpsCounter = document.getElementById('fps-counter');\nconst cameraFileInput = document.getElementById('cameraButton');\nconst cameraList = document.getElementById('cameraList');\nconst plyFileInput = document.getElementById('plyButton');\n// create the camera and renderer globals\nlet interactiveCamera = InteractiveCamera.default(canvas);\nvar currentRenderer;\n// swap the renderer when the ply file changes\nfunction handlePlyChange(event) {\n    const file = event.target.files[0];\n    function onFileLoad(arrayBuffer) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (currentRenderer) {\n                yield currentRenderer.destroy();\n            }\n            const gaussians = new PackedGaussians(arrayBuffer);\n            try {\n                const context = yield Renderer.requestContext(gaussians);\n                const renderer = new Renderer(canvas, interactiveCamera, gaussians, context, fpsCounter);\n                currentRenderer = renderer; // bind to the global scope\n                loadingPopup.style.display = 'none'; // hide loading popup\n            }\n            catch (error) {\n                loadingPopup.style.display = 'none'; // hide loading popup\n                alert(error);\n            }\n        });\n    }\n    if (file) {\n        loadingPopup.style.display = 'block'; // show loading popup\n        loadFileAsArrayBuffer(file)\n            .then(onFileLoad);\n    }\n}\n// loads the default ply file (bundled with the source) at startup, useful for dev\nfunction loadDefaultPly() {\n    return __awaiter(this, void 0, void 0, function* () {\n        const url = \"pc_short.ply\";\n        loadingPopup.style.display = 'block'; // show loading popup\n        const content = yield fetch(url);\n        const arrayBuffer = yield content.arrayBuffer();\n        const gaussians = new PackedGaussians(arrayBuffer);\n        const context = yield Renderer.requestContext(gaussians);\n        const renderer = new Renderer(canvas, interactiveCamera, gaussians, context, fpsCounter);\n        currentRenderer = renderer; // bind to the global scope\n        loadingPopup.style.display = 'none'; // hide loading popup\n    });\n}\n// DEV: uncomment this line to load the default ply file at startup\n//loadDefaultPly();\n// add event listeners\nplyFileInput.addEventListener('change', handlePlyChange);\nnew CameraFileParser(cameraFileInput, cameraList, canvas, (camera) => interactiveCamera.setNewCamera(camera));\n"],"names":["roundUp","n","multiple","Math","ceil","PackingError","Error","constructor","message","super","this","name","PackingType","size","alignment","pack","offset","value","view","setInt32","unpack","content","getInt32","setUint32","getUint32","f32","setFloat32","getFloat32","VectorType","baseType","nValues","values","Array","isArray","length","i","e","newOffset","push","vec2","vec3","vec4","Struct","members","max","map","_name","type","_","expectedKeys","_type","actualKeys","Object","keys","every","key","includes","startingOffset","StaticArray","nElements","stride","MatrixType","nRows","nColumns","vecType","startOffset","j","outerValues","innerValues","mat4x4","decodeHeader","plyArrayBuffer","decoder","TextDecoder","headerOffset","headerText","headerChunk","Uint8Array","decode","headerLines","split","vertexCount","propertyTypes","line","trim","startsWith","vertexCountMatch","match","parseInt","propertyMatch","propertyType","vertexByteOffset","indexOf","DataView","readRawVertex","vertexData","rawVertex","property","Float32Array","BYTES_PER_ELEMENT","getUint8","nShCoeffs","sphericalHarmonicsDegree","arrangeVertex","shFeatureOrder","shCoeffs","coeff","coeffName","position","x","y","z","logScale","scale_0","scale_1","scale_2","rotQuat","rot_0","rot_1","rot_2","rot_3","opacityLogit","opacity","arrayBuffer","numGaussians","nRestCoeffs","propertyName","nCoeffsPerColor","sqrt","console","log","rgb","gaussianLayout","gaussianArrayLayout","positionsLayout","positionsArrayLayout","gaussiansBuffer","ArrayBuffer","gaussianWriteView","positionsBuffer","positionsWriteView","readOffset","gaussianWriteOffset","positionWriteOffset","newReadOffset","EPSILON","VecType$2","create$5","dst","undefined","MatType$1","ctorMap","Map","Float64Array","fill","newMat3","get","copy$4","m","clone$4","identity$2","inverse$4","m00","m01","m02","m10","m11","m12","m20","m21","m22","b01","b11","b21","invDet","invert$3","multiply$4","a","b","a00","a01","a02","a10","a11","a12","a20","a21","a22","b00","b02","b10","b12","b20","b22","mul$4","mat3Impl","freeze","__proto__","setDefaultType","ctor","oldType","create","v0","v1","v2","v3","v4","v5","v6","v7","v8","set","fromMat4","m4","fromQuat","q","w","x2","y2","z2","xx","yx","yy","zx","zy","zz","wx","wy","wz","negate","copy","clone","equalsApproximately","abs","equals","identity","transpose","t","inverse","determinant","invert","multiply","mul","setTranslation","v","getTranslation","getAxis","axis","off","setAxis","getScaling","xy","translation","translate","rotation","angleInRadians","c","cos","s","sin","rotate","scaling","scale","uniformScaling","uniformScale","VecType$1","create$3","fromValues$2","subtract$2","sub$2","mulScalar$2","k","scale$3","inverse$3","invert$2","cross","t1","t2","dot$2","length$2","len$2","lengthSq$2","lenSq$2","distance$1","dx","dy","dz","dist$1","distanceSq$1","distSq$1","normalize$2","len","copy$3","clone$3","multiply$3","mul$3","divide$1","div$1","vec3Impl","fromValues","floor","round","clamp","min","add","addScaled","angle","ax","ay","az","bx","by","bz","mag","cosine","acos","subtract","sub","lerp","lerpV","mulScalar","divScalar","dot","lengthSq","lenSq","distance","dist","distanceSq","distSq","normalize","divide","div","random","PI","zScale","zero","transformMat4","transformMat4Upper3x3","transformMat3","transformQuat","qx","qy","qz","w2","uvX","uvY","uvZ","xz","yz","MatType","copy$2","clone$2","identity$1","inverse$2","m03","m13","m23","m30","m31","m32","m33","tmp0","tmp1","tmp2","tmp3","tmp4","tmp5","tmp6","tmp7","tmp8","tmp9","tmp10","tmp11","tmp12","tmp13","tmp14","tmp15","tmp16","tmp17","tmp18","tmp19","tmp20","tmp21","tmp22","tmp23","t0","t3","d","invert$1","multiply$2","a03","a13","a23","a30","a31","a32","a33","b03","b13","b23","b30","b31","b32","b33","mul$2","xAxis","yAxis","zAxis","axisRotation","oneMinusCosine","axisRotate","r00","r01","r02","r10","r11","r12","r20","r21","r22","mat4Impl","v9","v10","v11","v12","v13","v14","v15","fromMat3","m3","perspective","fieldOfViewYInRadians","aspect","zNear","zFar","f","tan","Infinity","rangeInv","ortho","left","right","bottom","top","near","far","frustum","aim","target","up","cameraAim","eye","lookAt","rotationX","rotateX","rotationY","rotateY","rotationZ","rotateZ","Camera","height","width","viewMatrix","focalX","focalY","scaleModifier","dotZ","depthAxis","getPosition","inverseViewMatrix","getProjMatrix","flippedY","diagonal4x4","viewInv","InteractiveCamera","camera","canvas","drag","oldX","oldY","dRX","dRY","dRZ","dTX","dTY","dTZ","dirty","createCallbacks","default","addEventListener","pageX","pageY","setDirty","preventDefault","deltaY","window","keyMap","setNewCamera","newCamera","setClean","isDirty","getCamera","focal2fov","focal","pixels","atan","gpu","adapter","device","thisArg","_arguments","generator","navigator","Promise","reject","requestAdapter","requestDevice","label","P","resolve","fulfilled","step","next","rejected","result","done","then","apply","destroy","bitonicSortShader","itemsPerThread","BitonicSorter","context","log2","valuesBuffer","createBuffer","usage","GPUBufferUsage","STORAGE","COPY_SRC","COPY_DST","mappedAtCreation","indicesBuffer","initialIndexBuffer","initialIndices","Uint32Array","getMappedRange","unmap","numThreads","pipeline","createComputePipeline","compute","module","createShaderModule","code","entryPoint","layout","createUniforms","gpuBuffers","gpuBindGroups","bufferContent","gpuBuffer","byteLength","UNIFORM","gpuBindGroup","createBindGroup","getBindGroupLayout","entries","binding","resource","buffer","uniformBuffers","bindGroups","uniformBuffer","argsort","commandEncoder","createCommandEncoder","clearBuffer","copyBufferToBuffer","uniformBindGroup","passEncoder","beginComputePass","setPipeline","setBindGroup","dispatchWorkgroups","end","queue","submit","finish","copyToIndexBufferShader","numQuadsUnpadded","projMatrixLayout","DepthSorter","gaussians","nUnpadded","nPadded","pow","depthBuffer","projMatrixBuffer","computeDepthBindGroupLayout","createBindGroupLayout","visibility","GPUShaderStage","COMPUTE","computeDepthPipelineLayout","createPipelineLayout","bindGroupLayouts","paddedPerThread","computeDepthPipeline","computeDepthBindGroup","sorter","indexBuffer","unpaddedPerThread","copyToIndexBufferPipeline","copyToIndexBufferBindGroup","sort","projMatrix","projMatrixCpuBuffer","writeBuffer","uniformLayout","mat4toArrayOfArrays","requestContext","requiredLimits","maxStorageBufferBindingSize","maxBufferSize","destroyCallback","interactiveCamera","fpsCounter","contextGpu","getContext","lastDraw","performance","now","presentationFormat","configure","format","alphaMode","pointDataBuffer","shaderCode","shDegree","shComputeCode","getShaderCode","shaderModule","drawPipeline","createRenderPipeline","vertex","fragment","targets","blend","color","srcFactor","dstFactor","operation","alpha","primitive","topology","stripIndexFormat","cullMode","uniformsBindGroup","pointDataBindGroup","depthSorter","drawIndexBuffer","INDEX","requestAnimationFrame","animate","destroyImpl","draw","nextFrameCallback","indexBufferSrc","depthSortMatrix","renderPassDescriptor","colorAttachments","getCurrentTexture","createView","clearValue","r","g","storeOp","loadOp","beginRenderPass","setIndexBuffer","drawIndexed","fps","innerText","toFixed","style","display","forceDraw","tanHalfFovX","tanHalfFovY","uniformsMatrixBuffer","uniforms","cameraPosition","from","alert","document","getElementById","loadingPopup","cameraFileInput","cameraList","plyFileInput","currentRenderer","event","file","files","reader","FileReader","onload","onerror","error","readAsArrayBuffer","loadFileAsArrayBuffer","renderer","fileInput","listElement","cameraSetCallback","currentLineId","handleFileInputChange","_a","handleFileLoad","readAsText","contents","jsonData","JSON","parse","innerHTML","forEach","cameraJSON","listItem","createElement","rawCamera","canvasW","canvasH","projectionMatrix","znear","zfar","fovX","fovY","z_sign","getProjectionMatrix","fx","fy","R","R_","camToWorld","minusT","worldToCamFromRT","flat","cameraFromJSON","textContent","img_name","createCallbackForLine","appendChild"],"sourceRoot":""}