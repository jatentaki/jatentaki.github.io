(()=>{"use strict";function t(t,e){return Math.ceil(t/e)*e}class e extends Error{constructor(t){super(t),this.name="PackingError"}}class n{constructor(t,e){this.size=t,this.alignment=e}}new class extends n{constructor(){super(4,4)}pack(t,n,i){if("number"!=typeof n)throw new e(`Expected number, got ${n}`);return i.setInt32(t,n,!0),t+this.size}unpack(t,e){const n=e.getInt32(t,!0);return[t+this.size,n]}},new class extends n{constructor(){super(4,4)}pack(t,n,i){if("number"!=typeof n)throw new e(`Expected number, got ${n}`);return i.setUint32(t,n,!0),t+this.size}unpack(t,e){const n=e.getUint32(t,!0);return[t+this.size,n]}};const i=new class extends n{constructor(){super(4,4)}pack(t,n,i){if("number"!=typeof n)throw new e(`Expected number, got ${n}`);return i.setFloat32(t,n,!0),t+this.size}unpack(t,e){const n=e.getFloat32(t,!0);return[t+this.size,n]}};class r extends n{constructor(t,e,n){super(t.size*e,n),this.baseType=t,this.nValues=e}pack(t,n,i){if(!Array.isArray(n))throw new e(`Expected array, got ${n}`);if(n.length!==this.nValues)throw new e(`Expected ${this.nValues} values, got ${n.length}`);for(;t%this.alignment!=0;)t++;for(let r=0;r<n.length;r++)try{t=this.baseType.pack(t,n[r],i)}catch(t){throw t instanceof e?new e(`Error packing value ${r}: ${t.message}`):t}return t}unpack(t,e){const n=[];for(;t%this.alignment!=0;)t++;for(let i=0;i<this.nValues;i++){let[i,r]=this.baseType.unpack(t,e);t=i,n.push(r)}return[t,n]}}class s extends r{constructor(t){super(t,2,8)}}class o extends r{constructor(t){super(t,3,16)}}class a extends r{constructor(t){super(t,4,16)}}class c extends n{constructor(e){const n=Math.max(...e.map((([t,e])=>e.alignment)));let i=0;for(const[t,n]of e){for(;i%n.alignment!=0;)i++;i+=n.size}super(t(i,n),n),this.members=e}pack(t,n,i){const r=this.members.map((([t,e])=>t)),s=Object.keys(n);if(r.length!==s.length)throw new e(`Expected values for ${r}, got ${s}`);if(!r.every((t=>s.includes(t))))throw new e(`Expected values for ${r}, got ${s}`);const o=t;for(;t%this.alignment!=0;)t++;for(const[r,s]of this.members){const o=n[r];try{t=s.pack(t,o,i)}catch(t){throw t instanceof e?new e(`Error packing value ${r}: ${t.message}`):t}}return t+(this.size-(t-o))}unpack(t,e){const n={},i=t;for(;t%this.alignment!=0;)t++;for(const[i,r]of this.members){let[s,o]=r.unpack(t,e);t=s,n[i]=o}return[t+=this.size-(t-i),n]}}class u extends n{constructor(e,n){const i=e.alignment;super(n*t(e.size,e.alignment),i),this.type=e,this.nElements=n,this.stride=t(e.size,e.alignment)}pack(t,n,i){if(!Array.isArray(n))throw new e(`Expected array, got ${n}`);if(n.length!==this.nElements)throw new e(`Expected ${this.nElements} values, got ${n.length}`);for(;t%this.alignment!=0;)t++;for(let r=0;r<n.length;r++){try{t=this.type.pack(t,n[r],i)}catch(t){throw t instanceof e?new e(`Error packing value ${r}: ${t.message}`):t}t+=this.stride-this.type.size}return t}unpack(t,e){const n=[];for(;t%this.alignment!=0;)t++;for(let i=0;i<this.nElements;i++){let[i,r]=this.type.unpack(t,e);t=i,n.push(r),t+=this.stride-this.type.size}return[t,n]}}class f extends n{constructor(t,e,n){var i;if(2===e)i=new s(t);else if(3===e)i=new o(t);else{if(4!==e)throw new Error(`Invalid number of rows: ${e}`);i=new a(t)}super(new u(i,n).size,i.alignment),this.baseType=t,this.nRows=e,this.nColumns=n}pack(t,n,i){if(!Array.isArray(n))throw new e(`Expected array, got ${n}`);if(n.length!==this.nColumns)throw new e(`Expected ${this.nColumns} columns, got ${n.length}`);for(;t%this.alignment!=0;)t++;const r=t;for(let r=0;r<n.length;r++){if(!Array.isArray(n[r]))throw new e(`Expected array, got ${n[r]}`);for(let s=0;s<n[r].length;s++)try{t=this.baseType.pack(t,n[r][s],i)}catch(t){throw t instanceof e?new e(`Error packing value ${r},${s}: ${t.message}`):t}}return r+this.size}unpack(t,e){for(;t%this.alignment!=0;)t++;const n=t,i=[];for(let n=0;n<this.nColumns;n++){const n=[];for(let i=0;i<this.nRows;i++){let[i,r]=this.baseType.unpack(t,e);t=i,n.push(r)}i.push(n)}return[t+=this.size-(t-n),i]}}class h extends f{constructor(t){super(t,4,4)}}class l{static decodeHeader(t){const e=new TextDecoder;let n=0,i="";for(;;){const r=new Uint8Array(t,n,50);if(i+=e.decode(r),n+=50,i.includes("end_header"))break}const r=i.split("\n");let s=0,o={};for(let t=0;t<r.length;t++){const e=r[t].trim();if(e.startsWith("element vertex")){const t=e.match(/\d+/);t&&(s=parseInt(t[0]))}else if(e.startsWith("property")){const t=e.match(/(\w+)\s+(\w+)\s+(\w+)/);if(t){const e=t[2];o[t[3]]=e}}else if("end_header"===e)break}const a=i.indexOf("end_header")+10+1;return[s,o,new DataView(t,a)]}readRawVertex(t,e,n){let i={};for(const r in n){const s=n[r];"float"===s?(i[r]=e.getFloat32(t,!0),t+=Float32Array.BYTES_PER_ELEMENT):"uchar"===s&&(i[r]=e.getUint8(t)/255,t+=Uint8Array.BYTES_PER_ELEMENT)}return[t,i]}get nShCoeffs(){if(0===this.sphericalHarmonicsDegree)return 1;if(1===this.sphericalHarmonicsDegree)return 4;if(2===this.sphericalHarmonicsDegree)return 9;if(3===this.sphericalHarmonicsDegree)return 16;throw new Error(`Unsupported SH degree: ${this.sphericalHarmonicsDegree}`)}arrangeVertex(t,e){const n=[];for(let i=0;i<this.nShCoeffs;++i){const r=[];for(let n=0;n<3;++n){const s=e[3*i+n];r.push(t[s])}n.push(r)}return{position:[t.x,t.y,t.z],logScale:[t.scale_0,t.scale_1,t.scale_2],rotQuat:[t.rot_0,t.rot_1,t.rot_2,t.rot_3],opacityLogit:t.opacity,shCoeffs:n}}constructor(t){const[e,n,r]=l.decodeHeader(t);this.numGaussians=e;var s=0;for(const t in n)t.startsWith("f_rest_")&&(s+=1);const f=s/3;this.sphericalHarmonicsDegree=Math.sqrt(f+1)-1,console.log("Detected degree",this.sphericalHarmonicsDegree,"with ",f,"coefficients per color");const h=[];for(let t=0;t<3;++t)h.push(`f_dc_${t}`);for(let t=0;t<f;++t)for(let e=0;e<3;++e)h.push(`f_rest_${e*f+t}`);this.gaussianLayout=new c([["position",new o(i)],["logScale",new o(i)],["rotQuat",new a(i)],["opacityLogit",i],["shCoeffs",new u(new o(i),this.nShCoeffs)]]),this.gaussianArrayLayout=new u(this.gaussianLayout,e),this.positionsLayout=new o(i),this.positionsArrayLayout=new u(this.positionsLayout,e),this.gaussiansBuffer=new ArrayBuffer(this.gaussianArrayLayout.size);const d=new DataView(this.gaussiansBuffer);this.positionsBuffer=new ArrayBuffer(this.positionsArrayLayout.size);const p=new DataView(this.positionsBuffer);var m=0,v=0,g=0;for(let t=0;t<e;t++){const[t,e]=this.readRawVertex(m,r,n);m=t,v=this.gaussianLayout.pack(v,this.arrangeVertex(e,h),d),g=this.positionsLayout.pack(g,[e.x,e.y,e.z],p)}}}let d=1e-6,p=Float32Array;function m(t=0,e=0){const n=new p(2);return void 0!==t&&(n[0]=t,void 0!==e&&(n[1]=e)),n}let v=Float32Array;const g=new Map([[Float32Array,()=>new Float32Array(12)],[Float64Array,()=>new Float64Array(12)],[Array,()=>new Array(12).fill(0)]]);let y=g.get(Float32Array);function x(t,e){return(e=e||y())[0]=t[0],e[1]=t[1],e[2]=t[2],e[4]=t[4],e[5]=t[5],e[6]=t[6],e[8]=t[8],e[9]=t[9],e[10]=t[10],e}const w=x;function b(t){return(t=t||y())[0]=1,t[1]=0,t[2]=0,t[4]=0,t[5]=1,t[6]=0,t[8]=0,t[9]=0,t[10]=1,t}function _(t,e){e=e||y();const n=t[0],i=t[1],r=t[2],s=t[4],o=t[5],a=t[6],c=t[8],u=t[9],f=t[10],h=f*o-a*u,l=-f*s+a*c,d=u*s-o*c,p=1/(n*h+i*l+r*d);return e[0]=h*p,e[1]=(-f*i+r*u)*p,e[2]=(a*i-r*o)*p,e[4]=l*p,e[5]=(f*n-r*c)*p,e[6]=(-a*n+r*s)*p,e[8]=d*p,e[9]=(-u*n+i*c)*p,e[10]=(o*n-i*s)*p,e}const M=_;function B(t,e,n){n=n||y();const i=t[0],r=t[1],s=t[2],o=t[4],a=t[5],c=t[6],u=t[8],f=t[9],h=t[10],l=e[0],d=e[1],p=e[2],m=e[4],v=e[5],g=e[6],x=e[8],w=e[9],b=e[10];return n[0]=i*l+o*d+u*p,n[1]=r*l+a*d+f*p,n[2]=s*l+c*d+h*p,n[4]=i*m+o*v+u*g,n[5]=r*m+a*v+f*g,n[6]=s*m+c*v+h*g,n[8]=i*x+o*w+u*b,n[9]=r*x+a*w+f*b,n[10]=s*x+c*w+h*b,n}const z=B;var S=Object.freeze({__proto__:null,setDefaultType:function(t){const e=v;return v=t,y=g.get(t),e},create:function(t,e,n,i,r,s,o,a,c){const u=y();return u[3]=0,u[7]=0,u[11]=0,void 0!==t&&(u[0]=t,void 0!==e&&(u[1]=e,void 0!==n&&(u[2]=n,void 0!==i&&(u[4]=i,void 0!==r&&(u[5]=r,void 0!==s&&(u[6]=s,void 0!==o&&(u[8]=o,void 0!==a&&(u[9]=a,void 0!==c&&(u[10]=c))))))))),u},set:function(t,e,n,i,r,s,o,a,c,u){return(u=u||y())[0]=t,u[1]=e,u[2]=n,u[3]=0,u[4]=i,u[5]=r,u[6]=s,u[7]=0,u[8]=o,u[9]=a,u[10]=c,u[11]=0,u},fromMat4:function(t,e){return(e=e||y())[0]=t[0],e[1]=t[1],e[2]=t[2],e[3]=0,e[4]=t[4],e[5]=t[5],e[6]=t[6],e[7]=0,e[8]=t[8],e[9]=t[9],e[10]=t[10],e[11]=0,e},fromQuat:function(t,e){e=e||y();const n=t[0],i=t[1],r=t[2],s=t[3],o=n+n,a=i+i,c=r+r,u=n*o,f=i*o,h=i*a,l=r*o,d=r*a,p=r*c,m=s*o,v=s*a,g=s*c;return e[0]=1-h-p,e[1]=f+g,e[2]=l-v,e[3]=0,e[4]=f-g,e[5]=1-u-p,e[6]=d+m,e[7]=0,e[8]=l+v,e[9]=d-m,e[10]=1-u-h,e[11]=0,e},negate:function(t,e){return(e=e||y())[0]=-t[0],e[1]=-t[1],e[2]=-t[2],e[4]=-t[4],e[5]=-t[5],e[6]=-t[6],e[8]=-t[8],e[9]=-t[9],e[10]=-t[10],e},copy:x,clone:w,equalsApproximately:function(t,e){return Math.abs(t[0]-e[0])<d&&Math.abs(t[1]-e[1])<d&&Math.abs(t[2]-e[2])<d&&Math.abs(t[4]-e[4])<d&&Math.abs(t[5]-e[5])<d&&Math.abs(t[6]-e[6])<d&&Math.abs(t[8]-e[8])<d&&Math.abs(t[9]-e[9])<d&&Math.abs(t[10]-e[10])<d},equals:function(t,e){return t[0]===e[0]&&t[1]===e[1]&&t[2]===e[2]&&t[4]===e[4]&&t[5]===e[5]&&t[6]===e[6]&&t[8]===e[8]&&t[9]===e[9]&&t[10]===e[10]},identity:b,transpose:function(t,e){if((e=e||y())===t){let n;return n=t[1],t[1]=t[4],t[4]=n,n=t[2],t[2]=t[8],t[8]=n,n=t[6],t[6]=t[9],t[9]=n,e}const n=t[0],i=t[1],r=t[2],s=t[4],o=t[5],a=t[6],c=t[8],u=t[9],f=t[10];return e[0]=n,e[1]=s,e[2]=c,e[4]=i,e[5]=o,e[6]=u,e[8]=r,e[9]=a,e[10]=f,e},inverse:_,determinant:function(t){const e=t[0],n=t[1],i=t[2],r=t[4],s=t[5],o=t[6],a=t[8],c=t[9],u=t[10];return e*(s*u-c*o)-r*(n*u-c*i)+a*(n*o-s*i)},invert:M,multiply:B,mul:z,setTranslation:function(t,e,n){return t!==(n=n||b())&&(n[0]=t[0],n[1]=t[1],n[2]=t[2],n[4]=t[4],n[5]=t[5],n[6]=t[6]),n[8]=e[0],n[9]=e[1],n[10]=1,n},getTranslation:function(t,e){return(e=e||m())[0]=t[8],e[1]=t[9],e},getAxis:function(t,e,n){const i=4*e;return(n=n||m())[0]=t[i+0],n[1]=t[i+1],n},setAxis:function(t,e,n,i){i!==t&&(i=x(t,i));const r=4*n;return i[r+0]=e[0],i[r+1]=e[1],i},getScaling:function(t,e){e=e||m();const n=t[0],i=t[1],r=t[4],s=t[5];return e[0]=Math.sqrt(n*n+i*i),e[1]=Math.sqrt(r*r+s*s),e},translation:function(t,e){return(e=e||y())[0]=1,e[1]=0,e[2]=0,e[4]=0,e[5]=1,e[6]=0,e[8]=t[0],e[9]=t[1],e[10]=1,e},translate:function(t,e,n){n=n||y();const i=e[0],r=e[1],s=t[0],o=t[1],a=t[2],c=t[4],u=t[5],f=t[6],h=t[8],l=t[9],d=t[10];return t!==n&&(n[0]=s,n[1]=o,n[2]=a,n[4]=c,n[5]=u,n[6]=f),n[8]=s*i+c*r+h,n[9]=o*i+u*r+l,n[10]=a*i+f*r+d,n},rotation:function(t,e){e=e||y();const n=Math.cos(t),i=Math.sin(t);return e[0]=n,e[1]=i,e[2]=0,e[4]=-i,e[5]=n,e[6]=0,e[8]=0,e[9]=0,e[10]=1,e},rotate:function(t,e,n){n=n||y();const i=t[0],r=t[1],s=t[2],o=t[4],a=t[5],c=t[6],u=Math.cos(e),f=Math.sin(e);return n[0]=u*i+f*o,n[1]=u*r+f*a,n[2]=u*s+f*c,n[4]=u*o-f*i,n[5]=u*a-f*r,n[6]=u*c-f*s,t!==n&&(n[8]=t[8],n[9]=t[9],n[10]=t[10]),n},scaling:function(t,e){return(e=e||y())[0]=t[0],e[1]=0,e[2]=0,e[4]=0,e[5]=t[1],e[6]=0,e[8]=0,e[9]=0,e[10]=1,e},scale:function(t,e,n){n=n||y();const i=e[0],r=e[1];return n[0]=i*t[0],n[1]=i*t[1],n[2]=i*t[2],n[4]=r*t[4],n[5]=r*t[5],n[6]=r*t[6],t!==n&&(n[8]=t[8],n[9]=t[9],n[10]=t[10]),n},uniformScaling:function(t,e){return(e=e||y())[0]=t,e[1]=0,e[2]=0,e[4]=0,e[5]=t,e[6]=0,e[8]=0,e[9]=0,e[10]=1,e},uniformScale:function(t,e,n){return(n=n||y())[0]=e*t[0],n[1]=e*t[1],n[2]=e*t[2],n[4]=e*t[4],n[5]=e*t[5],n[6]=e*t[6],t!==n&&(n[8]=t[8],n[9]=t[9],n[10]=t[10]),n}});let P=Float32Array;function C(t,e,n){const i=new P(3);return void 0!==t&&(i[0]=t,void 0!==e&&(i[1]=e,void 0!==n&&(i[2]=n))),i}const U=C;function A(t,e,n){return(n=n||new P(3))[0]=t[0]-e[0],n[1]=t[1]-e[1],n[2]=t[2]-e[2],n}const E=A;function k(t,e,n){return(n=n||new P(3))[0]=t[0]*e,n[1]=t[1]*e,n[2]=t[2]*e,n}const G=k;function T(t,e){return(e=e||new P(3))[0]=1/t[0],e[1]=1/t[1],e[2]=1/t[2],e}const I=T;function D(t,e,n){n=n||new P(3);const i=t[2]*e[0]-t[0]*e[2],r=t[0]*e[1]-t[1]*e[0];return n[0]=t[1]*e[2]-t[2]*e[1],n[1]=i,n[2]=r,n}function q(t,e){return t[0]*e[0]+t[1]*e[1]+t[2]*e[2]}function H(t){const e=t[0],n=t[1],i=t[2];return Math.sqrt(e*e+n*n+i*i)}const R=H;function L(t){const e=t[0],n=t[1],i=t[2];return e*e+n*n+i*i}const $=L;function j(t,e){const n=t[0]-e[0],i=t[1]-e[1],r=t[2]-e[2];return Math.sqrt(n*n+i*i+r*r)}const F=j;function Y(t,e){const n=t[0]-e[0],i=t[1]-e[1],r=t[2]-e[2];return n*n+i*i+r*r}const O=Y;function X(t,e){e=e||new P(3);const n=t[0],i=t[1],r=t[2],s=Math.sqrt(n*n+i*i+r*r);return s>1e-5?(e[0]=n/s,e[1]=i/s,e[2]=r/s):(e[0]=0,e[1]=0,e[2]=0),e}function V(t,e){return(e=e||new P(3))[0]=t[0],e[1]=t[1],e[2]=t[2],e}const W=V;function Z(t,e,n){return(n=n||new P(3))[0]=t[0]*e[0],n[1]=t[1]*e[1],n[2]=t[2]*e[2],n}const N=Z;function Q(t,e,n){return(n=n||new P(3))[0]=t[0]/e[0],n[1]=t[1]/e[1],n[2]=t[2]/e[2],n}const J=Q;var K=Object.freeze({__proto__:null,create:C,setDefaultType:function(t){const e=P;return P=t,e},fromValues:U,set:function(t,e,n,i){return(i=i||new P(3))[0]=t,i[1]=e,i[2]=n,i},ceil:function(t,e){return(e=e||new P(3))[0]=Math.ceil(t[0]),e[1]=Math.ceil(t[1]),e[2]=Math.ceil(t[2]),e},floor:function(t,e){return(e=e||new P(3))[0]=Math.floor(t[0]),e[1]=Math.floor(t[1]),e[2]=Math.floor(t[2]),e},round:function(t,e){return(e=e||new P(3))[0]=Math.round(t[0]),e[1]=Math.round(t[1]),e[2]=Math.round(t[2]),e},clamp:function(t,e=0,n=1,i){return(i=i||new P(3))[0]=Math.min(n,Math.max(e,t[0])),i[1]=Math.min(n,Math.max(e,t[1])),i[2]=Math.min(n,Math.max(e,t[2])),i},add:function(t,e,n){return(n=n||new P(3))[0]=t[0]+e[0],n[1]=t[1]+e[1],n[2]=t[2]+e[2],n},addScaled:function(t,e,n,i){return(i=i||new P(3))[0]=t[0]+e[0]*n,i[1]=t[1]+e[1]*n,i[2]=t[2]+e[2]*n,i},angle:function(t,e){const n=t[0],i=t[1],r=t[2],s=t[0],o=t[1],a=t[2],c=Math.sqrt(n*n+i*i+r*r)*Math.sqrt(s*s+o*o+a*a),u=c&&q(t,e)/c;return Math.acos(u)},subtract:A,sub:E,equalsApproximately:function(t,e){return Math.abs(t[0]-e[0])<d&&Math.abs(t[1]-e[1])<d&&Math.abs(t[2]-e[2])<d},equals:function(t,e){return t[0]===e[0]&&t[1]===e[1]&&t[2]===e[2]},lerp:function(t,e,n,i){return(i=i||new P(3))[0]=t[0]+n*(e[0]-t[0]),i[1]=t[1]+n*(e[1]-t[1]),i[2]=t[2]+n*(e[2]-t[2]),i},lerpV:function(t,e,n,i){return(i=i||new P(3))[0]=t[0]+n[0]*(e[0]-t[0]),i[1]=t[1]+n[1]*(e[1]-t[1]),i[2]=t[2]+n[2]*(e[2]-t[2]),i},max:function(t,e,n){return(n=n||new P(3))[0]=Math.max(t[0],e[0]),n[1]=Math.max(t[1],e[1]),n[2]=Math.max(t[2],e[2]),n},min:function(t,e,n){return(n=n||new P(3))[0]=Math.min(t[0],e[0]),n[1]=Math.min(t[1],e[1]),n[2]=Math.min(t[2],e[2]),n},mulScalar:k,scale:G,divScalar:function(t,e,n){return(n=n||new P(3))[0]=t[0]/e,n[1]=t[1]/e,n[2]=t[2]/e,n},inverse:T,invert:I,cross:D,dot:q,length:H,len:R,lengthSq:L,lenSq:$,distance:j,dist:F,distanceSq:Y,distSq:O,normalize:X,negate:function(t,e){return(e=e||new P(3))[0]=-t[0],e[1]=-t[1],e[2]=-t[2],e},copy:V,clone:W,multiply:Z,mul:N,divide:Q,div:J,random:function(t=1,e){e=e||new P(3);const n=2*Math.random()*Math.PI,i=2*Math.random()-1,r=Math.sqrt(1-i*i)*t;return e[0]=Math.cos(n)*r,e[1]=Math.sin(n)*r,e[2]=i*t,e},zero:function(t){return(t=t||new P(3))[0]=0,t[1]=0,t[2]=0,t},transformMat4:function(t,e,n){n=n||new P(3);const i=t[0],r=t[1],s=t[2],o=e[3]*i+e[7]*r+e[11]*s+e[15]||1;return n[0]=(e[0]*i+e[4]*r+e[8]*s+e[12])/o,n[1]=(e[1]*i+e[5]*r+e[9]*s+e[13])/o,n[2]=(e[2]*i+e[6]*r+e[10]*s+e[14])/o,n},transformMat4Upper3x3:function(t,e,n){n=n||new P(3);const i=t[0],r=t[1],s=t[2];return n[0]=i*e[0]+r*e[4]+s*e[8],n[1]=i*e[1]+r*e[5]+s*e[9],n[2]=i*e[2]+r*e[6]+s*e[10],n},transformMat3:function(t,e,n){n=n||new P(3);const i=t[0],r=t[1],s=t[2];return n[0]=i*e[0]+r*e[4]+s*e[8],n[1]=i*e[1]+r*e[5]+s*e[9],n[2]=i*e[2]+r*e[6]+s*e[10],n},transformQuat:function(t,e,n){n=n||new P(3);const i=e[0],r=e[1],s=e[2],o=2*e[3],a=t[0],c=t[1],u=t[2],f=r*u-s*c,h=s*a-i*u,l=i*c-r*a;return n[0]=a+f*o+2*(r*l-s*h),n[1]=c+h*o+2*(s*f-i*l),n[2]=u+l*o+2*(i*h-r*f),n},getTranslation:function(t,e){return(e=e||new P(3))[0]=t[12],e[1]=t[13],e[2]=t[14],e},getAxis:function(t,e,n){const i=4*e;return(n=n||new P(3))[0]=t[i+0],n[1]=t[i+1],n[2]=t[i+2],n},getScaling:function(t,e){e=e||new P(3);const n=t[0],i=t[1],r=t[2],s=t[4],o=t[5],a=t[6],c=t[8],u=t[9],f=t[10];return e[0]=Math.sqrt(n*n+i*i+r*r),e[1]=Math.sqrt(s*s+o*o+a*a),e[2]=Math.sqrt(c*c+u*u+f*f),e}});let tt=Float32Array;function et(t,e){return(e=e||new tt(16))[0]=t[0],e[1]=t[1],e[2]=t[2],e[3]=t[3],e[4]=t[4],e[5]=t[5],e[6]=t[6],e[7]=t[7],e[8]=t[8],e[9]=t[9],e[10]=t[10],e[11]=t[11],e[12]=t[12],e[13]=t[13],e[14]=t[14],e[15]=t[15],e}const nt=et;function it(t){return(t=t||new tt(16))[0]=1,t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=1,t[6]=0,t[7]=0,t[8]=0,t[9]=0,t[10]=1,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,t}function rt(t,e){e=e||new tt(16);const n=t[0],i=t[1],r=t[2],s=t[3],o=t[4],a=t[5],c=t[6],u=t[7],f=t[8],h=t[9],l=t[10],d=t[11],p=t[12],m=t[13],v=t[14],g=t[15],y=l*g,x=v*d,w=c*g,b=v*u,_=c*d,M=l*u,B=r*g,z=v*s,S=r*d,P=l*s,C=r*u,U=c*s,A=f*m,E=p*h,k=o*m,G=p*a,T=o*h,I=f*a,D=n*m,q=p*i,H=n*h,R=f*i,L=n*a,$=o*i,j=y*a+b*h+_*m-(x*a+w*h+M*m),F=x*i+B*h+P*m-(y*i+z*h+S*m),Y=w*i+z*a+C*m-(b*i+B*a+U*m),O=M*i+S*a+U*h-(_*i+P*a+C*h),X=1/(n*j+o*F+f*Y+p*O);return e[0]=X*j,e[1]=X*F,e[2]=X*Y,e[3]=X*O,e[4]=X*(x*o+w*f+M*p-(y*o+b*f+_*p)),e[5]=X*(y*n+z*f+S*p-(x*n+B*f+P*p)),e[6]=X*(b*n+B*o+U*p-(w*n+z*o+C*p)),e[7]=X*(_*n+P*o+C*f-(M*n+S*o+U*f)),e[8]=X*(A*u+G*d+T*g-(E*u+k*d+I*g)),e[9]=X*(E*s+D*d+R*g-(A*s+q*d+H*g)),e[10]=X*(k*s+q*u+L*g-(G*s+D*u+$*g)),e[11]=X*(I*s+H*u+$*d-(T*s+R*u+L*d)),e[12]=X*(k*l+I*v+E*c-(T*v+A*c+G*l)),e[13]=X*(H*v+A*r+q*l-(D*l+R*v+E*r)),e[14]=X*(D*c+$*v+G*r-(L*v+k*r+q*c)),e[15]=X*(L*l+T*r+R*c-(H*c+$*l+I*r)),e}const st=rt;function ot(t,e,n){n=n||new tt(16);const i=t[0],r=t[1],s=t[2],o=t[3],a=t[4],c=t[5],u=t[6],f=t[7],h=t[8],l=t[9],d=t[10],p=t[11],m=t[12],v=t[13],g=t[14],y=t[15],x=e[0],w=e[1],b=e[2],_=e[3],M=e[4],B=e[5],z=e[6],S=e[7],P=e[8],C=e[9],U=e[10],A=e[11],E=e[12],k=e[13],G=e[14],T=e[15];return n[0]=i*x+a*w+h*b+m*_,n[1]=r*x+c*w+l*b+v*_,n[2]=s*x+u*w+d*b+g*_,n[3]=o*x+f*w+p*b+y*_,n[4]=i*M+a*B+h*z+m*S,n[5]=r*M+c*B+l*z+v*S,n[6]=s*M+u*B+d*z+g*S,n[7]=o*M+f*B+p*z+y*S,n[8]=i*P+a*C+h*U+m*A,n[9]=r*P+c*C+l*U+v*A,n[10]=s*P+u*C+d*U+g*A,n[11]=o*P+f*C+p*U+y*A,n[12]=i*E+a*k+h*G+m*T,n[13]=r*E+c*k+l*G+v*T,n[14]=s*E+u*k+d*G+g*T,n[15]=o*E+f*k+p*G+y*T,n}const at=ot;let ct,ut,ft;function ht(t,e,n){n=n||new tt(16);let i=t[0],r=t[1],s=t[2];const o=Math.sqrt(i*i+r*r+s*s);i/=o,r/=o,s/=o;const a=i*i,c=r*r,u=s*s,f=Math.cos(e),h=Math.sin(e),l=1-f;return n[0]=a+(1-a)*f,n[1]=i*r*l+s*h,n[2]=i*s*l-r*h,n[3]=0,n[4]=i*r*l-s*h,n[5]=c+(1-c)*f,n[6]=r*s*l+i*h,n[7]=0,n[8]=i*s*l+r*h,n[9]=r*s*l-i*h,n[10]=u+(1-u)*f,n[11]=0,n[12]=0,n[13]=0,n[14]=0,n[15]=1,n}const lt=ht;function dt(t,e,n,i){i=i||new tt(16);let r=e[0],s=e[1],o=e[2];const a=Math.sqrt(r*r+s*s+o*o);r/=a,s/=a,o/=a;const c=r*r,u=s*s,f=o*o,h=Math.cos(n),l=Math.sin(n),d=1-h,p=c+(1-c)*h,m=r*s*d+o*l,v=r*o*d-s*l,g=r*s*d-o*l,y=u+(1-u)*h,x=s*o*d+r*l,w=r*o*d+s*l,b=s*o*d-r*l,_=f+(1-f)*h,M=t[0],B=t[1],z=t[2],S=t[3],P=t[4],C=t[5],U=t[6],A=t[7],E=t[8],k=t[9],G=t[10],T=t[11];return i[0]=p*M+m*P+v*E,i[1]=p*B+m*C+v*k,i[2]=p*z+m*U+v*G,i[3]=p*S+m*A+v*T,i[4]=g*M+y*P+x*E,i[5]=g*B+y*C+x*k,i[6]=g*z+y*U+x*G,i[7]=g*S+y*A+x*T,i[8]=w*M+b*P+_*E,i[9]=w*B+b*C+_*k,i[10]=w*z+b*U+_*G,i[11]=w*S+b*A+_*T,t!==i&&(i[12]=t[12],i[13]=t[13],i[14]=t[14],i[15]=t[15]),i}const pt=dt;var mt=Object.freeze({__proto__:null,setDefaultType:function(t){const e=tt;return tt=t,e},create:function(t,e,n,i,r,s,o,a,c,u,f,h,l,d,p,m){const v=new tt(16);return void 0!==t&&(v[0]=t,void 0!==e&&(v[1]=e,void 0!==n&&(v[2]=n,void 0!==i&&(v[3]=i,void 0!==r&&(v[4]=r,void 0!==s&&(v[5]=s,void 0!==o&&(v[6]=o,void 0!==a&&(v[7]=a,void 0!==c&&(v[8]=c,void 0!==u&&(v[9]=u,void 0!==f&&(v[10]=f,void 0!==h&&(v[11]=h,void 0!==l&&(v[12]=l,void 0!==d&&(v[13]=d,void 0!==p&&(v[14]=p,void 0!==m&&(v[15]=m)))))))))))))))),v},set:function(t,e,n,i,r,s,o,a,c,u,f,h,l,d,p,m,v){return(v=v||new tt(16))[0]=t,v[1]=e,v[2]=n,v[3]=i,v[4]=r,v[5]=s,v[6]=o,v[7]=a,v[8]=c,v[9]=u,v[10]=f,v[11]=h,v[12]=l,v[13]=d,v[14]=p,v[15]=m,v},fromMat3:function(t,e){return(e=e||new tt(16))[0]=t[0],e[1]=t[1],e[2]=t[2],e[3]=0,e[4]=t[4],e[5]=t[5],e[6]=t[6],e[7]=0,e[8]=t[8],e[9]=t[9],e[10]=t[10],e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,e},fromQuat:function(t,e){e=e||new tt(16);const n=t[0],i=t[1],r=t[2],s=t[3],o=n+n,a=i+i,c=r+r,u=n*o,f=i*o,h=i*a,l=r*o,d=r*a,p=r*c,m=s*o,v=s*a,g=s*c;return e[0]=1-h-p,e[1]=f+g,e[2]=l-v,e[3]=0,e[4]=f-g,e[5]=1-u-p,e[6]=d+m,e[7]=0,e[8]=l+v,e[9]=d-m,e[10]=1-u-h,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,e},negate:function(t,e){return(e=e||new tt(16))[0]=-t[0],e[1]=-t[1],e[2]=-t[2],e[3]=-t[3],e[4]=-t[4],e[5]=-t[5],e[6]=-t[6],e[7]=-t[7],e[8]=-t[8],e[9]=-t[9],e[10]=-t[10],e[11]=-t[11],e[12]=-t[12],e[13]=-t[13],e[14]=-t[14],e[15]=-t[15],e},copy:et,clone:nt,equalsApproximately:function(t,e){return Math.abs(t[0]-e[0])<d&&Math.abs(t[1]-e[1])<d&&Math.abs(t[2]-e[2])<d&&Math.abs(t[3]-e[3])<d&&Math.abs(t[4]-e[4])<d&&Math.abs(t[5]-e[5])<d&&Math.abs(t[6]-e[6])<d&&Math.abs(t[7]-e[7])<d&&Math.abs(t[8]-e[8])<d&&Math.abs(t[9]-e[9])<d&&Math.abs(t[10]-e[10])<d&&Math.abs(t[11]-e[11])<d&&Math.abs(t[12]-e[12])<d&&Math.abs(t[13]-e[13])<d&&Math.abs(t[14]-e[14])<d&&Math.abs(t[15]-e[15])<d},equals:function(t,e){return t[0]===e[0]&&t[1]===e[1]&&t[2]===e[2]&&t[3]===e[3]&&t[4]===e[4]&&t[5]===e[5]&&t[6]===e[6]&&t[7]===e[7]&&t[8]===e[8]&&t[9]===e[9]&&t[10]===e[10]&&t[11]===e[11]&&t[12]===e[12]&&t[13]===e[13]&&t[14]===e[14]&&t[15]===e[15]},identity:it,transpose:function(t,e){if((e=e||new tt(16))===t){let n;return n=t[1],t[1]=t[4],t[4]=n,n=t[2],t[2]=t[8],t[8]=n,n=t[3],t[3]=t[12],t[12]=n,n=t[6],t[6]=t[9],t[9]=n,n=t[7],t[7]=t[13],t[13]=n,n=t[11],t[11]=t[14],t[14]=n,e}const n=t[0],i=t[1],r=t[2],s=t[3],o=t[4],a=t[5],c=t[6],u=t[7],f=t[8],h=t[9],l=t[10],d=t[11],p=t[12],m=t[13],v=t[14],g=t[15];return e[0]=n,e[1]=o,e[2]=f,e[3]=p,e[4]=i,e[5]=a,e[6]=h,e[7]=m,e[8]=r,e[9]=c,e[10]=l,e[11]=v,e[12]=s,e[13]=u,e[14]=d,e[15]=g,e},inverse:rt,determinant:function(t){const e=t[0],n=t[1],i=t[2],r=t[3],s=t[4],o=t[5],a=t[6],c=t[7],u=t[8],f=t[9],h=t[10],l=t[11],d=t[12],p=t[13],m=t[14],v=t[15],g=h*v,y=m*l,x=a*v,w=m*c,b=a*l,_=h*c,M=i*v,B=m*r,z=i*l,S=h*r,P=i*c,C=a*r;return e*(g*o+w*f+b*p-(y*o+x*f+_*p))+s*(y*n+M*f+S*p-(g*n+B*f+z*p))+u*(x*n+B*o+P*p-(w*n+M*o+C*p))+d*(_*n+z*o+C*f-(b*n+S*o+P*f))},invert:st,multiply:ot,mul:at,setTranslation:function(t,e,n){return t!==(n=n||it())&&(n[0]=t[0],n[1]=t[1],n[2]=t[2],n[3]=t[3],n[4]=t[4],n[5]=t[5],n[6]=t[6],n[7]=t[7],n[8]=t[8],n[9]=t[9],n[10]=t[10],n[11]=t[11]),n[12]=e[0],n[13]=e[1],n[14]=e[2],n[15]=1,n},getTranslation:function(t,e){return(e=e||C())[0]=t[12],e[1]=t[13],e[2]=t[14],e},getAxis:function(t,e,n){const i=4*e;return(n=n||C())[0]=t[i+0],n[1]=t[i+1],n[2]=t[i+2],n},setAxis:function(t,e,n,i){i!==t&&(i=et(t,i));const r=4*n;return i[r+0]=e[0],i[r+1]=e[1],i[r+2]=e[2],i},getScaling:function(t,e){e=e||C();const n=t[0],i=t[1],r=t[2],s=t[4],o=t[5],a=t[6],c=t[8],u=t[9],f=t[10];return e[0]=Math.sqrt(n*n+i*i+r*r),e[1]=Math.sqrt(s*s+o*o+a*a),e[2]=Math.sqrt(c*c+u*u+f*f),e},perspective:function(t,e,n,i,r){r=r||new tt(16);const s=Math.tan(.5*Math.PI-.5*t);if(r[0]=s/e,r[1]=0,r[2]=0,r[3]=0,r[4]=0,r[5]=s,r[6]=0,r[7]=0,r[8]=0,r[9]=0,r[11]=-1,r[12]=0,r[13]=0,r[15]=0,i===1/0)r[10]=-1,r[14]=-n;else{const t=1/(n-i);r[10]=i*t,r[14]=i*n*t}return r},ortho:function(t,e,n,i,r,s,o){return(o=o||new tt(16))[0]=2/(e-t),o[1]=0,o[2]=0,o[3]=0,o[4]=0,o[5]=2/(i-n),o[6]=0,o[7]=0,o[8]=0,o[9]=0,o[10]=1/(r-s),o[11]=0,o[12]=(e+t)/(t-e),o[13]=(i+n)/(n-i),o[14]=r/(r-s),o[15]=1,o},frustum:function(t,e,n,i,r,s,o){const a=e-t,c=i-n,u=r-s;return(o=o||new tt(16))[0]=2*r/a,o[1]=0,o[2]=0,o[3]=0,o[4]=0,o[5]=2*r/c,o[6]=0,o[7]=0,o[8]=(t+e)/a,o[9]=(i+n)/c,o[10]=s/u,o[11]=-1,o[12]=0,o[13]=0,o[14]=r*s/u,o[15]=0,o},aim:function(t,e,n,i){return i=i||new tt(16),ct=ct||C(),ut=ut||C(),ft=ft||C(),X(A(e,t,ft),ft),X(D(n,ft,ct),ct),X(D(ft,ct,ut),ut),i[0]=ct[0],i[1]=ct[1],i[2]=ct[2],i[3]=0,i[4]=ut[0],i[5]=ut[1],i[6]=ut[2],i[7]=0,i[8]=ft[0],i[9]=ft[1],i[10]=ft[2],i[11]=0,i[12]=t[0],i[13]=t[1],i[14]=t[2],i[15]=1,i},cameraAim:function(t,e,n,i){return i=i||new tt(16),ct=ct||C(),ut=ut||C(),ft=ft||C(),X(A(t,e,ft),ft),X(D(n,ft,ct),ct),X(D(ft,ct,ut),ut),i[0]=ct[0],i[1]=ct[1],i[2]=ct[2],i[3]=0,i[4]=ut[0],i[5]=ut[1],i[6]=ut[2],i[7]=0,i[8]=ft[0],i[9]=ft[1],i[10]=ft[2],i[11]=0,i[12]=t[0],i[13]=t[1],i[14]=t[2],i[15]=1,i},lookAt:function(t,e,n,i){return i=i||new tt(16),ct=ct||C(),ut=ut||C(),ft=ft||C(),X(A(t,e,ft),ft),X(D(n,ft,ct),ct),X(D(ft,ct,ut),ut),i[0]=ct[0],i[1]=ut[0],i[2]=ft[0],i[3]=0,i[4]=ct[1],i[5]=ut[1],i[6]=ft[1],i[7]=0,i[8]=ct[2],i[9]=ut[2],i[10]=ft[2],i[11]=0,i[12]=-(ct[0]*t[0]+ct[1]*t[1]+ct[2]*t[2]),i[13]=-(ut[0]*t[0]+ut[1]*t[1]+ut[2]*t[2]),i[14]=-(ft[0]*t[0]+ft[1]*t[1]+ft[2]*t[2]),i[15]=1,i},translation:function(t,e){return(e=e||new tt(16))[0]=1,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=1,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[10]=1,e[11]=0,e[12]=t[0],e[13]=t[1],e[14]=t[2],e[15]=1,e},translate:function(t,e,n){n=n||new tt(16);const i=e[0],r=e[1],s=e[2],o=t[0],a=t[1],c=t[2],u=t[3],f=t[4],h=t[5],l=t[6],d=t[7],p=t[8],m=t[9],v=t[10],g=t[11],y=t[12],x=t[13],w=t[14],b=t[15];return t!==n&&(n[0]=o,n[1]=a,n[2]=c,n[3]=u,n[4]=f,n[5]=h,n[6]=l,n[7]=d,n[8]=p,n[9]=m,n[10]=v,n[11]=g),n[12]=o*i+f*r+p*s+y,n[13]=a*i+h*r+m*s+x,n[14]=c*i+l*r+v*s+w,n[15]=u*i+d*r+g*s+b,n},rotationX:function(t,e){e=e||new tt(16);const n=Math.cos(t),i=Math.sin(t);return e[0]=1,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=n,e[6]=i,e[7]=0,e[8]=0,e[9]=-i,e[10]=n,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,e},rotateX:function(t,e,n){n=n||new tt(16);const i=t[4],r=t[5],s=t[6],o=t[7],a=t[8],c=t[9],u=t[10],f=t[11],h=Math.cos(e),l=Math.sin(e);return n[4]=h*i+l*a,n[5]=h*r+l*c,n[6]=h*s+l*u,n[7]=h*o+l*f,n[8]=h*a-l*i,n[9]=h*c-l*r,n[10]=h*u-l*s,n[11]=h*f-l*o,t!==n&&(n[0]=t[0],n[1]=t[1],n[2]=t[2],n[3]=t[3],n[12]=t[12],n[13]=t[13],n[14]=t[14],n[15]=t[15]),n},rotationY:function(t,e){e=e||new tt(16);const n=Math.cos(t),i=Math.sin(t);return e[0]=n,e[1]=0,e[2]=-i,e[3]=0,e[4]=0,e[5]=1,e[6]=0,e[7]=0,e[8]=i,e[9]=0,e[10]=n,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,e},rotateY:function(t,e,n){n=n||new tt(16);const i=t[0],r=t[1],s=t[2],o=t[3],a=t[8],c=t[9],u=t[10],f=t[11],h=Math.cos(e),l=Math.sin(e);return n[0]=h*i-l*a,n[1]=h*r-l*c,n[2]=h*s-l*u,n[3]=h*o-l*f,n[8]=h*a+l*i,n[9]=h*c+l*r,n[10]=h*u+l*s,n[11]=h*f+l*o,t!==n&&(n[4]=t[4],n[5]=t[5],n[6]=t[6],n[7]=t[7],n[12]=t[12],n[13]=t[13],n[14]=t[14],n[15]=t[15]),n},rotationZ:function(t,e){e=e||new tt(16);const n=Math.cos(t),i=Math.sin(t);return e[0]=n,e[1]=i,e[2]=0,e[3]=0,e[4]=-i,e[5]=n,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[10]=1,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,e},rotateZ:function(t,e,n){n=n||new tt(16);const i=t[0],r=t[1],s=t[2],o=t[3],a=t[4],c=t[5],u=t[6],f=t[7],h=Math.cos(e),l=Math.sin(e);return n[0]=h*i+l*a,n[1]=h*r+l*c,n[2]=h*s+l*u,n[3]=h*o+l*f,n[4]=h*a-l*i,n[5]=h*c-l*r,n[6]=h*u-l*s,n[7]=h*f-l*o,t!==n&&(n[8]=t[8],n[9]=t[9],n[10]=t[10],n[11]=t[11],n[12]=t[12],n[13]=t[13],n[14]=t[14],n[15]=t[15]),n},axisRotation:ht,rotation:lt,axisRotate:dt,rotate:pt,scaling:function(t,e){return(e=e||new tt(16))[0]=t[0],e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=t[1],e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[10]=t[2],e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,e},scale:function(t,e,n){n=n||new tt(16);const i=e[0],r=e[1],s=e[2];return n[0]=i*t[0],n[1]=i*t[1],n[2]=i*t[2],n[3]=i*t[3],n[4]=r*t[4],n[5]=r*t[5],n[6]=r*t[6],n[7]=r*t[7],n[8]=s*t[8],n[9]=s*t[9],n[10]=s*t[10],n[11]=s*t[11],t!==n&&(n[12]=t[12],n[13]=t[13],n[14]=t[14],n[15]=t[15]),n},uniformScaling:function(t,e){return(e=e||new tt(16))[0]=t,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=t,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[10]=t,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,e},uniformScale:function(t,e,n){return(n=n||new tt(16))[0]=e*t[0],n[1]=e*t[1],n[2]=e*t[2],n[3]=e*t[3],n[4]=e*t[4],n[5]=e*t[5],n[6]=e*t[6],n[7]=e*t[7],n[8]=e*t[8],n[9]=e*t[9],n[10]=e*t[10],n[11]=e*t[11],t!==n&&(n[12]=t[12],n[13]=t[13],n[14]=t[14],n[15]=t[15]),n}});Float32Array,Float32Array;class vt{constructor(t,e,n,i,r,s,o){this.height=t,this.width=e,this.viewMatrix=n,this.perspective=i,this.focalX=r,this.focalY=s,this.scaleModifier=o}static default(){return new vt(500,500,mt.lookAt([0,0,0],[0,0,-1],[0,1,0]),mt.perspective(Math.PI/4,1,.2,100),600,600,1)}dotZ(){const t=this.depthAxis();return e=>K.dot(t,e)}getPosition(){const t=mt.inverse(this.viewMatrix);return mt.getTranslation(t)}getProjMatrix(){var t=mt.clone(this.perspective);return t=mt.mul(t,function(t,e,n,i){const r=mt.create();return r[0]=1,r[5]=-1,r[10]=1,r[15]=1,r}()),mt.multiply(t,this.viewMatrix)}translate(t,e,n){const i=mt.inverse(this.viewMatrix);mt.translate(i,[t,e,n],i),mt.inverse(i,this.viewMatrix)}rotate(t,e,n){const i=mt.inverse(this.viewMatrix);mt.rotateX(i,e,i),mt.rotateY(i,t,i),mt.rotateZ(i,n,i),mt.inverse(i,this.viewMatrix)}depthAxis(){return mt.getAxis(mt.transpose(this.viewMatrix),2)}}class gt{constructor(t,e){this.drag=!1,this.oldX=0,this.oldY=0,this.dRX=0,this.dRY=0,this.dRZ=0,this.dTX=0,this.dTY=0,this.dTZ=0,this.dirty=!0,this.camera=t,this.canvas=e,this.createCallbacks()}static default(t){return new gt(vt.default(),t)}createCallbacks(){this.canvas.addEventListener("mousedown",(t=>{this.drag=!0,this.oldX=t.pageX,this.oldY=t.pageY,this.setDirty(),t.preventDefault()}),!1),this.canvas.addEventListener("mouseup",(t=>{this.drag=!1}),!1),this.canvas.addEventListener("mousemove",(t=>{if(!this.drag)return!1;this.dRX=2*(t.pageX-this.oldX)*Math.PI/this.canvas.width,this.dRY=2*-(t.pageY-this.oldY)*Math.PI/this.canvas.height,this.oldX=t.pageX,this.oldY=t.pageY,this.setDirty(),t.preventDefault()}),!1),this.canvas.addEventListener("wheel",(t=>{this.dTZ=.1*t.deltaY,this.setDirty(),t.preventDefault()}),!1),window.addEventListener("keydown",(t=>{const e={w:()=>{this.dTY-=.1},s:()=>{this.dTY+=.1},a:()=>{this.dTX-=.1},d:()=>{this.dTX+=.1},q:()=>{this.dTZ+=.1},e:()=>{this.dTZ-=.1},j:()=>{this.dRX+=.1},l:()=>{this.dRX-=.1},i:()=>{this.dRY+=.1},k:()=>{this.dRY-=.1},u:()=>{this.dRZ+=.1},o:()=>{this.dRZ-=.1}};e[t.key]&&(e[t.key](),this.setDirty(),t.preventDefault())}),!1)}setNewCamera(t){this.camera=t,this.setDirty()}setDirty(){this.dirty=!0}setClean(){this.dirty=!1}isDirty(){return this.dirty}getCamera(){return this.isDirty()&&(this.camera.translate(this.dTX,this.dTY,this.dTZ),this.camera.rotate(this.dRX,this.dRY,this.dRZ),this.dTX=this.dTY=this.dTZ=this.dRX=this.dRY=this.dRZ=0,this.setClean()),this.camera}}function yt(t,e){return 2*Math.atan(e/(2*t))}class xt{constructor(t,e,n){this.gpu=t,this.adapter=e,this.device=n}static create(){return t=this,e=void 0,i=function*(){const t=navigator.gpu;if(!t)return Promise.reject("WebGPU not supported on this browser! (navigator.gpu is null)");const e=yield t.requestAdapter();if(!e)return Promise.reject("WebGPU not supported on this browser! (gpu.adapter is null)");const n=yield e.requestDevice({label:"GPUDevice"});return new xt(t,e,n)},new((n=void 0)||(n=Promise))((function(r,s){function o(t){try{c(i.next(t))}catch(t){s(t)}}function a(t){try{c(i.throw(t))}catch(t){s(t)}}function c(t){var e;t.done?r(t.value):(e=t.value,e instanceof n?e:new n((function(t){t(e)}))).then(o,a)}c((i=i.apply(t,e||[])).next())}));var t,e,n,i}destroy(){this.device.destroy(),this.adapter=null,this.device=null}}function wt(t){return`\nstruct Data {\n    values: array<f32>,\n};\n\nstruct Indices {\n    values: array<u32>,\n};\n\n// Uniform buffer to store j and k\nstruct Uniforms {\n    j: u32,\n    k: u32,\n};\n\n@binding(0) @group(0) var<storage, read_write> data: Data;\n@binding(1) @group(0) var<storage, read_write> indices: Indices;\n@binding(2) @group(0) var<uniform> uniforms: Uniforms;\n\n@compute @workgroup_size(1)\nfn main(@builtin(global_invocation_id) global_id: vec3<u32>) {\n    let j = uniforms.j;\n    let k = uniforms.k;\n    \n    for (var i = global_id.x * ${t}; i < (global_id.x + 1) * ${t}; i++) {\n        let ixj = i ^ j;\n\n        if (ixj <= i) {\n            continue;\n        }\n\n        let swap_pos = ((i & k) == 0 && data.values[i] > data.values[ixj]);\n        let swap_neg = ((i & k) != 0 && data.values[i] < data.values[ixj]);\n\n        if (swap_pos || swap_neg) {\n            let tempV = data.values[i];\n            data.values[i] = data.values[ixj];\n            data.values[ixj] = tempV;\n\n            let tempI = indices.values[i];\n            indices.values[i] = indices.values[ixj];\n            indices.values[ixj] = tempI;\n        }\n    }\n}\n`}class bt{constructor(t,e){if(Math.log2(e)%1!=0)throw new Error("nElements must be a power of 2");this.context=t,this.nElements=e,this.valuesBuffer=this.context.device.createBuffer({size:4*this.nElements,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC|GPUBufferUsage.COPY_DST,mappedAtCreation:!1,label:"bitonicSorter.valuesBuffer"}),this.indicesBuffer=this.context.device.createBuffer({size:4*this.nElements,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC|GPUBufferUsage.COPY_DST,mappedAtCreation:!1,label:"bitonicSorter.indicesBuffer"}),this.initialIndexBuffer=this.context.device.createBuffer({size:4*this.nElements,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC,mappedAtCreation:!0,label:"bitonicSorter.initialIndexBuffer"});const n=new Uint32Array(this.initialIndexBuffer.getMappedRange());for(let t=0;t<this.nElements;t++)n[t]=t;this.initialIndexBuffer.unmap(),this.numThreads=2048;const i=Math.ceil(this.nElements/this.numThreads);this.pipeline=this.context.device.createComputePipeline({compute:{module:this.context.device.createShaderModule({code:wt(i)}),entryPoint:"main"},layout:"auto"}),this.createUniforms()}createUniforms(){const t=[],e=[];for(let n=2;n<=this.nElements;n<<=1)for(let i=n>>1;i>0;i>>=1){const r=new Uint32Array([i,n]),s=this.context.device.createBuffer({size:r.byteLength,usage:GPUBufferUsage.UNIFORM,mappedAtCreation:!0,label:`bitonicSorter.uniformsBuffer.k=${n}.j=${i}`});new Uint32Array(s.getMappedRange()).set(r),s.unmap();const o=this.context.device.createBindGroup({layout:this.pipeline.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:this.valuesBuffer}},{binding:1,resource:{buffer:this.indicesBuffer}},{binding:2,resource:{buffer:s}}]});t.push(s),e.push(o)}this.uniformBuffers=t,this.bindGroups=e}destroy(){this.valuesBuffer.destroy(),this.indicesBuffer.destroy(),this.initialIndexBuffer.destroy();for(const t of this.uniformBuffers)t.destroy()}argsort(t){if(t.size!=this.valuesBuffer.size)throw new Error("Input buffer size does not match the size of the sorter");const e=this.context.device.createCommandEncoder();e.clearBuffer(this.valuesBuffer),e.copyBufferToBuffer(t,0,this.valuesBuffer,0,t.size),e.copyBufferToBuffer(this.initialIndexBuffer,0,this.indicesBuffer,0,this.initialIndexBuffer.size);for(const t of this.bindGroups){const n=e.beginComputePass();n.setPipeline(this.pipeline),n.setBindGroup(0,t),n.dispatchWorkgroups(this.numThreads),n.end()}return this.context.device.queue.submit([e.finish()]),this.indicesBuffer}}function _t(t,e){return`\n@group(0) @binding(0) var<storage, read> indices: array<u32>;\n@group(0) @binding(1) var<storage, read_write> indexBuffer: array<u32>;\n\n@compute @workgroup_size(1)\nfn main(@builtin(global_invocation_id) global_id: vec3<u32>) {\n    for (var i = global_id.x * ${t}; i < (global_id.x + 1) * ${t}; i++) {\n        if (i >= ${e}) {\n            break;\n        }\n        let index = indices[i];\n\n        for (var vertex = 0u; vertex < 6; vertex++) {\n            indexBuffer[i * 6 + vertex] = index * 6 + vertex;\n        }\n    }\n}\n`}const Mt=new h(i);class Bt{constructor(t,e){var n;this.context=t,this.nUnpadded=e.numGaussians,this.nPadded=(n=this.nUnpadded,Math.pow(2,Math.ceil(Math.log2(n)))),this.numThreads=2048,this.positionsBuffer=this.context.device.createBuffer({size:e.positionsArrayLayout.size,usage:GPUBufferUsage.STORAGE,mappedAtCreation:!0,label:"depthSorter.positionsBuffer"}),new Uint8Array(this.positionsBuffer.getMappedRange()).set(new Uint8Array(e.positionsBuffer)),this.positionsBuffer.unmap(),this.depthBuffer=this.context.device.createBuffer({size:4*this.nPadded,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC,label:"depthSorter.depthBuffer"}),this.projMatrixBuffer=this.context.device.createBuffer({size:Mt.size,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST,label:"depthSorter.projMatrixBuffer"});const i=this.context.device.createBindGroupLayout({entries:[{binding:0,visibility:GPUShaderStage.COMPUTE,buffer:{type:"read-only-storage"}},{binding:1,visibility:GPUShaderStage.COMPUTE,buffer:{type:"storage"}},{binding:2,visibility:GPUShaderStage.COMPUTE,buffer:{type:"uniform"}}]}),r=this.context.device.createPipelineLayout({bindGroupLayouts:[i]}),s=Math.ceil(this.nPadded/this.numThreads);var o,a;this.computeDepthPipeline=this.context.device.createComputePipeline({layout:r,compute:{module:this.context.device.createShaderModule({code:(o=s,a=this.nUnpadded,`\n@group(0) @binding(0) var<storage, read> vertices: array<vec3<f32>>;\n@group(0) @binding(1) var<storage, read_write> depths: array<f32>;\n@group(0) @binding(2) var<uniform> projMatrix: mat4x4<f32>;\n\n@compute @workgroup_size(1)\nfn main(@builtin(global_invocation_id) global_id: vec3<u32>) {\n    for (var i = global_id.x * ${o}; i < (global_id.x + 1) * ${o}; i++) {\n        //if (i >= arrayLength(&vertices)) {\n        if (i >= ${a}) {\n            depths[i] = 1e20f; // pad with +inf\n        } else {\n            let pos = vertices[i];\n            let projPos = projMatrix * vec4<f32>(pos, 1.0);\n            depths[i] = projPos.z;\n        }\n    }\n}\n`)}),entryPoint:"main"}}),this.computeDepthBindGroup=this.context.device.createBindGroup({layout:i,entries:[{binding:0,resource:{buffer:this.positionsBuffer}},{binding:1,resource:{buffer:this.depthBuffer}},{binding:2,resource:{buffer:this.projMatrixBuffer}}]}),this.sorter=new bt(this.context,this.nPadded),this.indexBuffer=this.context.device.createBuffer({size:6*this.nUnpadded*4,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC,label:"depthSorter.indexBuffer"});const c=Math.ceil(this.nUnpadded/this.numThreads);this.copyToIndexBufferPipeline=this.context.device.createComputePipeline({compute:{module:this.context.device.createShaderModule({code:_t(c,this.nUnpadded)}),entryPoint:"main"},layout:"auto"}),this.copyToIndexBufferBindGroup=this.context.device.createBindGroup({layout:this.copyToIndexBufferPipeline.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:this.sorter.indicesBuffer}},{binding:1,resource:{buffer:this.indexBuffer}}]})}destroy(){this.positionsBuffer.destroy(),this.depthBuffer.destroy(),this.projMatrixBuffer.destroy(),this.indexBuffer.destroy(),this.sorter.destroy()}sort(t){const e=new ArrayBuffer(Mt.size);Mt.pack(0,t,new DataView(e)),this.context.device.queue.writeBuffer(this.projMatrixBuffer,0,e,0,e.byteLength);{const t=this.context.device.createCommandEncoder(),e=t.beginComputePass();e.setPipeline(this.computeDepthPipeline),e.setBindGroup(0,this.computeDepthBindGroup),e.dispatchWorkgroups(this.numThreads),e.end(),this.context.device.queue.submit([t.finish()])}this.sorter.argsort(this.depthBuffer);{const t=this.context.device.createCommandEncoder(),e=t.beginComputePass();e.setPipeline(this.copyToIndexBufferPipeline),e.setBindGroup(0,this.copyToIndexBufferBindGroup),e.dispatchWorkgroups(this.numThreads),e.end(),this.context.device.queue.submit([t.finish()])}return this.indexBuffer}}var zt=function(t,e,n,i){return new(n||(n=Promise))((function(r,s){function o(t){try{c(i.next(t))}catch(t){s(t)}}function a(t){try{c(i.throw(t))}catch(t){s(t)}}function c(t){var e;t.done?r(t.value):(e=t.value,e instanceof n?e:new n((function(t){t(e)}))).then(o,a)}c((i=i.apply(t,e||[])).next())}))};const St=new c([["viewMatrix",new h(i)],["projMatrix",new h(i)],["cameraPosition",new o(i)],["tanHalfFovX",i],["tanHalfFovY",i],["focalX",i],["focalY",i],["scaleModifier",i]]);function Pt(t){return[[t[0],t[1],t[2],t[3]],[t[4],t[5],t[6],t[7]],[t[8],t[9],t[10],t[11]],[t[12],t[13],t[14],t[15]]]}class Ct{static requestContext(t){return zt(this,void 0,void 0,(function*(){const e=navigator.gpu;if(!e)return Promise.reject("WebGPU not supported on this browser! (navigator.gpu is null)");const n=yield e.requestAdapter();if(!n)return Promise.reject("WebGPU not supported on this browser! (gpu.adapter is null)");const i=t.gaussiansBuffer.byteLength,r=yield n.requestDevice({requiredLimits:{maxStorageBufferBindingSize:1.5*i,maxBufferSize:1.5*i}});return new xt(e,n,r)}))}destroy(){return zt(this,void 0,void 0,(function*(){return new Promise(((t,e)=>{this.destroyCallback=t}))}))}constructor(t,e,n,i,r){this.destroyCallback=null,this.canvas=t,this.interactiveCamera=e,this.context=i;const s=t.getContext("webgpu");if(!s)throw new Error("WebGPU context not found!");this.contextGpu=s,this.fpsCounter=r,this.lastDraw=performance.now(),this.numGaussians=n.numGaussians;const o="rgba16float";this.contextGpu.configure({device:this.context.device,format:o,alphaMode:"premultiplied"}),this.pointDataBuffer=this.context.device.createBuffer({size:n.gaussianArrayLayout.size,usage:GPUBufferUsage.STORAGE,mappedAtCreation:!0,label:"renderer.pointDataBuffer"}),new Uint8Array(this.pointDataBuffer.getMappedRange()).set(new Uint8Array(n.gaussiansBuffer)),this.pointDataBuffer.unmap(),this.uniformBuffer=this.context.device.createBuffer({size:St.size,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST,label:"renderer.uniformBuffer"});const a=function(t,e,n){const i={1:"\n    // spherical harmonic coefficients\n    const SH_C0 = 0.28209479177387814f;\n    const SH_C1 = 0.4886025119029199f;\n\n    fn compute_color_from_sh(position: vec3<f32>, sh: array<vec3<f32>, 4>) -> vec3<f32> {\n        let dir = normalize(position - uniforms.camera_position);\n        var result = SH_C0 * sh[0];\n\n        // if deg > 0\n        let x = dir.x;\n        let y = dir.y;\n        let z = dir.z;\n\n        result = result + SH_C1 * (-y * sh[1] + z * sh[2] - x * sh[3]);\n\n        // unconditional\n        result = result + 0.5;\n\n        return max(result, vec3<f32>(0.));\n    }\n",2:"\n    // spherical harmonic coefficients\n    const SH_C0 = 0.28209479177387814f;\n    const SH_C1 = 0.4886025119029199f;\n    const SH_C2 = array(\n        1.0925484305920792f,\n        -1.0925484305920792f,\n        0.31539156525252005f,\n        -1.0925484305920792f,\n        0.5462742152960396f\n    );\n\n    fn compute_color_from_sh(position: vec3<f32>, sh: array<vec3<f32>, 9>) -> vec3<f32> {\n        let dir = normalize(position - uniforms.camera_position);\n        var result = SH_C0 * sh[0];\n\n        // if deg > 0\n        let x = dir.x;\n        let y = dir.y;\n        let z = dir.z;\n\n        result = result + SH_C1 * (-y * sh[1] + z * sh[2] - x * sh[3]);\n\n        let xx = x * x;\n        let yy = y * y;\n        let zz = z * z;\n        let xy = x * y;\n        let xz = x * z;\n        let yz = y * z;\n\n        // if (sh_degree > 1) {\n        result = result +\n            SH_C2[0] * xy * sh[4] +\n            SH_C2[1] * yz * sh[5] +\n            SH_C2[2] * (2. * zz - xx - yy) * sh[6] +\n            SH_C2[3] * xz * sh[7] +\n            SH_C2[4] * (xx - yy) * sh[8];\n        \n        // unconditional\n        result = result + 0.5;\n\n        return max(result, vec3<f32>(0.));\n    }\n",3:"\n    // spherical harmonic coefficients\n    const SH_C0 = 0.28209479177387814f;\n    const SH_C1 = 0.4886025119029199f;\n    const SH_C2 = array(\n        1.0925484305920792f,\n        -1.0925484305920792f,\n        0.31539156525252005f,\n        -1.0925484305920792f,\n        0.5462742152960396f\n    );\n    const SH_C3 = array(\n        -0.5900435899266435f,\n        2.890611442640554f,\n        -0.4570457994644658f,\n        0.3731763325901154f,\n        -0.4570457994644658f,\n        1.445305721320277f,\n        -0.5900435899266435f\n    );\n\n    fn compute_color_from_sh(position: vec3<f32>, sh: array<vec3<f32>, 16>) -> vec3<f32> {\n        let dir = normalize(position - uniforms.camera_position);\n        var result = SH_C0 * sh[0];\n\n        // if deg > 0\n        let x = dir.x;\n        let y = dir.y;\n        let z = dir.z;\n\n        result = result + SH_C1 * (-y * sh[1] + z * sh[2] - x * sh[3]);\n\n        let xx = x * x;\n        let yy = y * y;\n        let zz = z * z;\n        let xy = x * y;\n        let xz = x * z;\n        let yz = y * z;\n\n        // if (sh_degree > 1) {\n        result = result +\n            SH_C2[0] * xy * sh[4] +\n            SH_C2[1] * yz * sh[5] +\n            SH_C2[2] * (2. * zz - xx - yy) * sh[6] +\n            SH_C2[3] * xz * sh[7] +\n            SH_C2[4] * (xx - yy) * sh[8];\n        \n        // We disable the 3rd degree for now because of a bug causing the entire render\n        // to be black. This appears to be a webGPU issue. If uncomment SH_C3[0...3] it works,\n        // if you uncomment SH_C3[4...6] it works, if you uncomment the whole and divide by 10\n        // it's black.\n\n        // if (sh_degree > 2) {\n        //result = result +\n        //    SH_C3[0] * y * (3. * xx - yy) * sh[9] +\n        //    SH_C3[1] * xy * z * sh[10] +\n        //    SH_C3[2] * y * (4. * zz - xx - yy) * sh[11] +\n        //    SH_C3[3] * z * (2. * zz - 3. * xx - 3. * yy) * sh[12] +\n        //    SH_C3[4] * x * (4. * zz - xx - yy) * sh[13] +\n        //    SH_C3[5] * z * (xx - yy) * sh[14] +\n        //    SH_C3[6] * x * (xx - 3. * yy) * sh[15];\n\n        // unconditional\n        result = result + 0.5;\n\n        return max(result, vec3<f32>(0.));\n    }\n"}[e];return`\n// for some reason passing these as uniform is broken\nconst canvas_height = ${t.height};\nconst canvas_width = ${t.width};\nconst sh_degree = ${e};\nconst n_sh_coeffs = ${n};\n\nstruct PointInput {\n    @location(0) position: vec3<f32>,\n    @location(1) log_scale: vec3<f32>,\n    @location(2) rot: vec4<f32>,\n    @location(3) opacity_logit: f32,\n    sh: array<vec3<f32>, n_sh_coeffs>,\n};\n\nstruct PointOutput {\n    @builtin(position) position: vec4<f32>,\n    @location(0) color: vec3<f32>,\n    @location(1) uv: vec2<f32>,\n    @location(2) conic_and_opacity: vec4<f32>,\n};\n\nstruct Uniforms {\n    viewMatrix: mat4x4<f32>,\n    projMatrix: mat4x4<f32>,\n    camera_position: vec3<f32>,\n    tan_fovx: f32,\n    tan_fovy: f32,\n    focal_x: f32,\n    focal_y: f32,\n    scale_modifier: f32,\n};\n\n${i}\n\nfn sigmoid(x: f32) -> f32 {\n    if (x >= 0.) {\n        return 1. / (1. + exp(-x));\n    } else {\n        let z = exp(x);\n        return z / (1. + z);\n    }\n}\n\nfn compute_cov3d(log_scale: vec3<f32>, rot: vec4<f32>) -> array<f32, 6> {\n    let modifier = uniforms.scale_modifier;\n    let S = mat3x3<f32>(\n        exp(log_scale.x) * modifier, 0., 0.,\n        0., exp(log_scale.y) * modifier, 0.,\n        0., 0., exp(log_scale.z) * modifier,\n    );\n\n    let r = rot.x;\n    let x = rot.y;\n    let y = rot.z;\n    let z = rot.w;\n\n    let R = mat3x3<f32>(\n        1. - 2. * (y * y + z * z), 2. * (x * y - r * z), 2. * (x * z + r * y),\n        2. * (x * y + r * z), 1. - 2. * (x * x + z * z), 2. * (y * z - r * x),\n        2. * (x * z - r * y), 2. * (y * z + r * x), 1. - 2. * (x * x + y * y),\n    );\n\n    let M = S * R;\n    let Sigma = transpose(M) * M;\n\n    return array<f32, 6>(\n        Sigma[0][0],\n        Sigma[0][1],\n        Sigma[0][2],\n        Sigma[1][1],\n        Sigma[1][2],\n        Sigma[2][2],\n    );\n} \n\nfn ndc2pix(v: f32, size: u32) -> f32 {\n    return ((v + 1.0) * f32(size) - 1.0) * 0.5;\n}\n\nfn compute_cov2d(position: vec3<f32>, log_scale: vec3<f32>, rot: vec4<f32>) -> vec3<f32> {\n    let cov3d = compute_cov3d(log_scale, rot);\n\n    var t = uniforms.viewMatrix * vec4<f32>(position, 1.0);\n\n    let limx = 1.3 * uniforms.tan_fovx;\n    let limy = 1.3 * uniforms.tan_fovy;\n    let txtz = t.x / t.z;\n    let tytz = t.y / t.z;\n\n    t.x = min(limx, max(-limx, txtz)) * t.z;\n    t.y = min(limy, max(-limy, tytz)) * t.z;\n\n    let J = mat4x4(\n        uniforms.focal_x / t.z, 0., -(uniforms.focal_x * t.x) / (t.z * t.z), 0.,\n        0., uniforms.focal_y / t.z, -(uniforms.focal_y * t.y) / (t.z * t.z), 0.,\n        0., 0., 0., 0.,\n        0., 0., 0., 0.,\n    );\n\n    let W = transpose(uniforms.viewMatrix);\n\n    let T = W * J;\n\n    let Vrk = mat4x4(\n        cov3d[0], cov3d[1], cov3d[2], 0.,\n        cov3d[1], cov3d[3], cov3d[4], 0.,\n        cov3d[2], cov3d[4], cov3d[5], 0.,\n        0., 0., 0., 0.,\n    );\n\n    var cov = transpose(T) * transpose(Vrk) * T;\n\n    // Apply low-pass filter: every Gaussian should be at least\n    // one pixel wide/high. Discard 3rd row and column.\n    cov[0][0] += 0.3;\n    cov[1][1] += 0.3;\n\n    return vec3<f32>(cov[0][0], cov[0][1], cov[1][1]);\n}\n\n\n@binding(0) @group(0) var<uniform> uniforms: Uniforms;\n@binding(1) @group(1) var<storage, read> points: array<PointInput>;\n\nconst quadVertices = array<vec2<f32>, 6>(\n    vec2<f32>(-1.0, -1.0),\n    vec2<f32>(-1.0, 1.0),\n    vec2<f32>(1.0, -1.0),\n    vec2<f32>(1.0, 1.0),\n    vec2<f32>(-1.0, 1.0),\n    vec2<f32>(1.0, -1.0),\n);\n\n@vertex\nfn vs_points(@builtin(vertex_index) vertex_index: u32) -> PointOutput {\n    var output: PointOutput;\n    let pointIndex = vertex_index / 6u;\n    let quadIndex = vertex_index % 6u;\n    let quadOffset = quadVertices[quadIndex];\n    let point = points[pointIndex];\n\n    let cov2d = compute_cov2d(point.position, point.log_scale, point.rot);\n    let det = cov2d.x * cov2d.z - cov2d.y * cov2d.y;\n    let det_inv = 1.0 / det;\n    let conic = vec3<f32>(cov2d.z * det_inv, -cov2d.y * det_inv, cov2d.x * det_inv);\n    let mid = 0.5 * (cov2d.x + cov2d.z);\n    let lambda_1 = mid + sqrt(max(0.1, mid * mid - det));\n    let lambda_2 = mid - sqrt(max(0.1, mid * mid - det));\n    let radius_px = ceil(3. * sqrt(max(lambda_1, lambda_2)));\n    let radius_ndc = vec2<f32>(\n    radius_px / (canvas_height),\n    radius_px / (canvas_width),\n    );\n    output.conic_and_opacity = vec4<f32>(conic, sigmoid(point.opacity_logit));\n\n    var projPosition = uniforms.projMatrix * vec4<f32>(point.position, 1.0);\n    projPosition = projPosition / projPosition.w;\n    output.position = vec4<f32>(projPosition.xy + 2 * radius_ndc * quadOffset, projPosition.zw);\n    output.color = compute_color_from_sh(uniforms.camera_position, point.sh);\n    output.uv = radius_px * quadOffset;\n\n    return output;\n}\n\n@fragment\nfn fs_main(input: PointOutput) -> @location(0) vec4<f32> {\n    // we want the distance from the gaussian to the fragment while uv\n    // is the reverse\n    let d = -input.uv;\n    let conic = input.conic_and_opacity.xyz;\n    let power = -0.5 * (conic.x * d.x * d.x + conic.z * d.y * d.y) + conic.y * d.x * d.y;\n    let opacity = input.conic_and_opacity.w;\n\n    if (power > 0.0) {\n    discard;\n    }\n\n    let alpha = min(0.99, opacity * exp(power));\n\n    return vec4<f32>(input.color * alpha, alpha);\n}\n`}(t,n.sphericalHarmonicsDegree,n.nShCoeffs),c=this.context.device.createShaderModule({code:a});this.drawPipeline=this.context.device.createRenderPipeline({layout:"auto",vertex:{module:c,entryPoint:"vs_points"},fragment:{module:c,entryPoint:"fs_main",targets:[{format:o,blend:{color:{srcFactor:"one-minus-dst-alpha",dstFactor:"one",operation:"add"},alpha:{srcFactor:"one-minus-dst-alpha",dstFactor:"one",operation:"add"}}}]},primitive:{topology:"triangle-list",stripIndexFormat:void 0,cullMode:void 0}}),this.uniformsBindGroup=this.context.device.createBindGroup({layout:this.drawPipeline.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:this.uniformBuffer}}]}),this.pointDataBindGroup=this.context.device.createBindGroup({layout:this.drawPipeline.getBindGroupLayout(1),entries:[{binding:1,resource:{buffer:this.pointDataBuffer}}]}),this.depthSorter=new Bt(this.context,n),this.drawIndexBuffer=this.context.device.createBuffer({size:24*n.numGaussians,usage:GPUBufferUsage.INDEX|GPUBufferUsage.COPY_DST,mappedAtCreation:!1,label:"renderer.drawIndexBuffer"}),requestAnimationFrame((()=>this.animate(!0)))}destroyImpl(){if(null===this.destroyCallback)throw new Error("destroyImpl called without destroyCallback set!");this.uniformBuffer.destroy(),this.pointDataBuffer.destroy(),this.drawIndexBuffer.destroy(),this.depthSorter.destroy(),this.context.destroy(),this.destroyCallback()}draw(t){const e=this.context.device.createCommandEncoder(),n=this.depthSorter.sort(this.depthSortMatrix);e.copyBufferToBuffer(n,0,this.drawIndexBuffer,0,24*this.depthSorter.nUnpadded);const i={colorAttachments:[{view:this.contextGpu.getCurrentTexture().createView(),clearValue:{r:0,g:0,b:0,a:0},storeOp:"store",loadOp:"clear"}]},r=e.beginRenderPass(i);r.setPipeline(this.drawPipeline),r.setBindGroup(0,this.uniformsBindGroup),r.setBindGroup(1,this.pointDataBindGroup),r.setIndexBuffer(this.drawIndexBuffer,"uint32"),r.drawIndexed(6*this.numGaussians,1,0,0,0),r.end(),this.context.device.queue.submit([e.finish()]);const s=performance.now(),o=1e3/(s-this.lastDraw);this.lastDraw=s,this.fpsCounter.innerText="FPS: "+o.toFixed(2),this.fpsCounter.style.display="block",requestAnimationFrame(t)}animate(t){if(null!==this.destroyCallback)return void this.destroyImpl();if(!this.interactiveCamera.isDirty()&&!t)return void requestAnimationFrame((()=>this.animate()));const e=this.interactiveCamera.getCamera(),n=e.getPosition(),i=.5*this.canvas.width/e.focalX,r=.5*this.canvas.height/e.focalY;this.depthSortMatrix=Pt(e.viewMatrix);let s=new ArrayBuffer(this.uniformBuffer.size),o={viewMatrix:Pt(e.viewMatrix),projMatrix:Pt(e.getProjMatrix()),cameraPosition:Array.from(n),tanHalfFovX:i,tanHalfFovY:r,focalX:e.focalX,focalY:e.focalY,scaleModifier:e.scaleModifier};St.pack(0,o,new DataView(s)),this.context.device.queue.writeBuffer(this.uniformBuffer,0,s,0,s.byteLength),this.draw((()=>this.animate()))}}navigator.gpu||alert("WebGPU not supported on this browser! (navigator.gpu is null)");const Ut=document.getElementById("canvas-webgpu"),At=document.getElementById("loading-popup"),Et=document.getElementById("fps-counter"),kt=document.getElementById("cameraButton"),Gt=document.getElementById("cameraList"),Tt=document.getElementById("plyButton");let It=gt.default(Ut);var Dt;Tt.addEventListener("change",(function(t){const e=t.target.files[0];e&&(At.style.display="block",function(t){return new Promise(((e,n)=>{const i=new FileReader;i.onload=t=>{t.target&&t.target.result?"string"!=typeof t.target.result?e(t.target.result):n("Got a text file instead of a binary one"):n("Failed to load file")},i.onerror=t=>{t.target?n(t.target.error):n("Failed to load file")},i.readAsArrayBuffer(t)}))}(e).then((function(t){return e=this,n=void 0,r=function*(){Dt&&(yield Dt.destroy());const e=new l(t);try{const t=yield Ct.requestContext(e),n=new Ct(Ut,It,e,t,Et);Dt=n,At.style.display="none"}catch(t){At.style.display="none",alert(t)}},new((i=void 0)||(i=Promise))((function(t,s){function o(t){try{c(r.next(t))}catch(t){s(t)}}function a(t){try{c(r.throw(t))}catch(t){s(t)}}function c(e){var n;e.done?t(e.value):(n=e.value,n instanceof i?n:new i((function(t){t(n)}))).then(o,a)}c((r=r.apply(e,n||[])).next())}));var e,n,i,r})))})),new class{constructor(t,e,n,i){this.currentLineId=0,this.handleFileInputChange=t=>{var e;const n=null===(e=this.fileInput.files)||void 0===e?void 0:e[0];if(n){const t=new FileReader;t.onload=this.handleFileLoad,t.readAsText(n)}},this.handleFileLoad=t=>{if(!t.target)return;const e=t.target.result,n=JSON.parse(e);this.currentLineId=0,this.listElement.innerHTML="",n.forEach((t=>{this.currentLineId++;const e=document.createElement("li"),n=function(t,e,n){const i=function(t,e,n,i){const r=Math.tan(i/2)*t,s=-r,o=Math.tan(n/2)*t,a=-o,c=mt.create();return c[0]=.4/(o-a),c[5]=.4/(r-s),c[8]=(o+a)/(o-a),c[9]=(r+s)/(r-s),c[10]=100/99.8,c[11]=-20/99.8,c[14]=1,c[15]=0,mt.transpose(c)}(.2,0,yt(t.fx,t.width),yt(t.fy,t.height)),r=function(t,e){const n=t,i=mt.fromMat3(n),r=K.mulScalar(e,-1);return mt.translate(i,r,i),i}(S.create(...t.rotation.flat()),t.position);return new vt(n,e,r,i,t.fx,t.fy,Math.max(e/t.width,n/t.height))}(t,this.canvas.width,this.canvas.height);e.textContent=t.img_name,e.addEventListener("click",this.createCallbackForLine(n)),this.listElement.appendChild(e)}))},this.createCallbackForLine=t=>()=>{this.cameraSetCallback(t)},this.fileInput=t,this.listElement=e,this.canvas=n,this.cameraSetCallback=i,this.fileInput.addEventListener("change",this.handleFileInputChange)}}(kt,Gt,Ut,(t=>It.setNewCamera(t)))})();
//# sourceMappingURL=main.js.map