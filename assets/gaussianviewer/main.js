(()=>{"use strict";function t(t,e){return Math.ceil(t/e)*e}class e extends Error{constructor(t){super(t),this.name="PackingError"}}class n{constructor(t,e){this.size=t,this.alignment=e}}new class extends n{constructor(){super(4,4)}pack(t,n,i){if("number"!=typeof n)throw new e(`Expected number, got ${n}`);return i.setInt32(t,n,!0),t+this.size}unpack(t,e){const n=e.getInt32(t,!0);return[t+this.size,n]}},new class extends n{constructor(){super(4,4)}pack(t,n,i){if("number"!=typeof n)throw new e(`Expected number, got ${n}`);return i.setUint32(t,n,!0),t+this.size}unpack(t,e){const n=e.getUint32(t,!0);return[t+this.size,n]}};const i=new class extends n{constructor(){super(4,4)}pack(t,n,i){if("number"!=typeof n)throw new e(`Expected number, got ${n}`);return i.setFloat32(t,n,!0),t+this.size}unpack(t,e){const n=e.getFloat32(t,!0);return[t+this.size,n]}};class r extends n{constructor(t,e,n){super(t.size*e,n),this.baseType=t,this.nValues=e}pack(t,n,i){if(!Array.isArray(n))throw new e(`Expected array, got ${n}`);if(n.length!==this.nValues)throw new e(`Expected ${this.nValues} values, got ${n.length}`);for(;t%this.alignment!=0;)t++;for(let r=0;r<n.length;r++)try{t=this.baseType.pack(t,n[r],i)}catch(t){throw t instanceof e?new e(`Error packing value ${r}: ${t.message}`):t}return t}unpack(t,e){const n=[];for(;t%this.alignment!=0;)t++;for(let i=0;i<this.nValues;i++){let[i,r]=this.baseType.unpack(t,e);t=i,n.push(r)}return[t,n]}}class s extends r{constructor(t){super(t,2,8)}}class o extends r{constructor(t){super(t,3,16)}}class a extends r{constructor(t){super(t,4,16)}}class c extends n{constructor(e){const n=Math.max(...e.map((([t,e])=>e.alignment)));let i=0;for(const[t,n]of e){for(;i%n.alignment!=0;)i++;i+=n.size}super(t(i,n),n),this.members=e}pack(t,n,i){const r=this.members.map((([t,e])=>t)),s=Object.keys(n);if(r.length!==s.length)throw new e(`Expected values for ${r}, got ${s}`);if(!r.every((t=>s.includes(t))))throw new e(`Expected values for ${r}, got ${s}`);const o=t;for(;t%this.alignment!=0;)t++;for(const[r,s]of this.members){const o=n[r];try{t=s.pack(t,o,i)}catch(t){throw t instanceof e?new e(`Error packing value ${r}: ${t.message}`):t}}return t+(this.size-(t-o))}unpack(t,e){const n={},i=t;for(;t%this.alignment!=0;)t++;for(const[i,r]of this.members){let[s,o]=r.unpack(t,e);t=s,n[i]=o}return[t+=this.size-(t-i),n]}}class u extends n{constructor(e,n){const i=e.alignment;super(n*t(e.size,e.alignment),i),this.type=e,this.nElements=n,this.stride=t(e.size,e.alignment)}pack(t,n,i){if(!Array.isArray(n))throw new e(`Expected array, got ${n}`);if(n.length!==this.nElements)throw new e(`Expected ${this.nElements} values, got ${n.length}`);for(;t%this.alignment!=0;)t++;for(let r=0;r<n.length;r++){try{t=this.type.pack(t,n[r],i)}catch(t){throw t instanceof e?new e(`Error packing value ${r}: ${t.message}`):t}t+=this.stride-this.type.size}return t}unpack(t,e){const n=[];for(;t%this.alignment!=0;)t++;for(let i=0;i<this.nElements;i++){let[i,r]=this.type.unpack(t,e);t=i,n.push(r),t+=this.stride-this.type.size}return[t,n]}}class f extends n{constructor(t,e,n){var i;if(2===e)i=new s(t);else if(3===e)i=new o(t);else{if(4!==e)throw new Error(`Invalid number of rows: ${e}`);i=new a(t)}super(new u(i,n).size,i.alignment),this.baseType=t,this.nRows=e,this.nColumns=n}pack(t,n,i){if(!Array.isArray(n))throw new e(`Expected array, got ${n}`);if(n.length!==this.nColumns)throw new e(`Expected ${this.nColumns} columns, got ${n.length}`);for(;t%this.alignment!=0;)t++;const r=t;for(let r=0;r<n.length;r++){if(!Array.isArray(n[r]))throw new e(`Expected array, got ${n[r]}`);for(let s=0;s<n[r].length;s++)try{t=this.baseType.pack(t,n[r][s],i)}catch(t){throw t instanceof e?new e(`Error packing value ${r},${s}: ${t.message}`):t}}return r+this.size}unpack(t,e){for(;t%this.alignment!=0;)t++;const n=t,i=[];for(let n=0;n<this.nColumns;n++){const n=[];for(let i=0;i<this.nRows;i++){let[i,r]=this.baseType.unpack(t,e);t=i,n.push(r)}i.push(n)}return[t+=this.size-(t-n),i]}}class d extends f{constructor(t){super(t,4,4)}}class l{static decodeHeader(t){const e=new TextDecoder;let n=0,i="";for(;;){const r=new Uint8Array(t,n,50);if(i+=e.decode(r),n+=50,i.includes("end_header"))break}const r=i.split("\n");let s=0,o={};for(let t=0;t<r.length;t++){const e=r[t].trim();if(e.startsWith("element vertex")){const t=e.match(/\d+/);t&&(s=parseInt(t[0]))}else if(e.startsWith("property")){const t=e.match(/(\w+)\s+(\w+)\s+(\w+)/);if(t){const e=t[2];o[t[3]]=e}}else if("end_header"===e)break}const a=i.indexOf("end_header")+10+1;return[s,o,new DataView(t,a)]}readRawVertex(t,e,n){let i={};for(const r in n){const s=n[r];"float"===s?(i[r]=e.getFloat32(t,!0),t+=Float32Array.BYTES_PER_ELEMENT):"uchar"===s&&(i[r]=e.getUint8(t)/255,t+=Uint8Array.BYTES_PER_ELEMENT)}return[t,i]}get nShCoeffs(){if(0===this.sphericalHarmonicsDegree)return 1;if(1===this.sphericalHarmonicsDegree)return 4;if(2===this.sphericalHarmonicsDegree)return 9;if(3===this.sphericalHarmonicsDegree)return 16;throw new Error(`Unsupported SH degree: ${this.sphericalHarmonicsDegree}`)}arrangeVertex(t,e){const n=[];for(let i=0;i<this.nShCoeffs;++i){const r=[];for(let n=0;n<3;++n){const s=e[3*i+n];r.push(t[s])}n.push(r)}return{position:[t.x,t.y,t.z],logScale:[t.scale_0,t.scale_1,t.scale_2],rotQuat:[t.rot_0,t.rot_1,t.rot_2,t.rot_3],opacityLogit:t.opacity,shCoeffs:n}}constructor(t){const[e,n,r]=l.decodeHeader(t);this.numGaussians=e;var s=0;for(const t in n)t.startsWith("f_rest_")&&(s+=1);const f=s/3;this.sphericalHarmonicsDegree=Math.sqrt(f+1)-1,console.log("Detected degree",this.sphericalHarmonicsDegree,"with ",f,"coefficients per color");const d=[];for(let t=0;t<3;++t)d.push(`f_dc_${t}`);for(let t=0;t<f;++t)for(let e=0;e<3;++e)d.push(`f_rest_${e*f+t}`);this.gaussianLayout=new c([["position",new o(i)],["logScale",new o(i)],["rotQuat",new a(i)],["opacityLogit",i],["shCoeffs",new u(new o(i),this.nShCoeffs)]]),this.gaussianArrayLayout=new u(this.gaussianLayout,e),this.positionsLayout=new o(i),this.positionsArrayLayout=new u(this.positionsLayout,e),this.gaussiansBuffer=new ArrayBuffer(this.gaussianArrayLayout.size);const h=new DataView(this.gaussiansBuffer);this.positionsBuffer=new ArrayBuffer(this.positionsArrayLayout.size);const p=new DataView(this.positionsBuffer);var x=0,m=0,v=0;for(let t=0;t<e;t++){const[t,e]=this.readRawVertex(x,r,n);x=t,m=this.gaussianLayout.pack(m,this.arrangeVertex(e,d),h),v=this.positionsLayout.pack(v,[e.x,e.y,e.z],p)}}}let h=1e-6,p=Float32Array;function x(t=0,e=0){const n=new p(2);return void 0!==t&&(n[0]=t,void 0!==e&&(n[1]=e)),n}let m=Float32Array;const v=new Map([[Float32Array,()=>new Float32Array(12)],[Float64Array,()=>new Float64Array(12)],[Array,()=>new Array(12).fill(0)]]);let g=v.get(Float32Array);function y(t,e){return(e=e||g())[0]=t[0],e[1]=t[1],e[2]=t[2],e[4]=t[4],e[5]=t[5],e[6]=t[6],e[8]=t[8],e[9]=t[9],e[10]=t[10],e}const w=y;function M(t){return(t=t||g())[0]=1,t[1]=0,t[2]=0,t[4]=0,t[5]=1,t[6]=0,t[8]=0,t[9]=0,t[10]=1,t}function _(t,e){e=e||g();const n=t[0],i=t[1],r=t[2],s=t[4],o=t[5],a=t[6],c=t[8],u=t[9],f=t[10],d=f*o-a*u,l=-f*s+a*c,h=u*s-o*c,p=1/(n*d+i*l+r*h);return e[0]=d*p,e[1]=(-f*i+r*u)*p,e[2]=(a*i-r*o)*p,e[4]=l*p,e[5]=(f*n-r*c)*p,e[6]=(-a*n+r*s)*p,e[8]=h*p,e[9]=(-u*n+i*c)*p,e[10]=(o*n-i*s)*p,e}const b=_;function B(t,e,n){n=n||g();const i=t[0],r=t[1],s=t[2],o=t[4],a=t[5],c=t[6],u=t[8],f=t[9],d=t[10],l=e[0],h=e[1],p=e[2],x=e[4],m=e[5],v=e[6],y=e[8],w=e[9],M=e[10];return n[0]=i*l+o*h+u*p,n[1]=r*l+a*h+f*p,n[2]=s*l+c*h+d*p,n[4]=i*x+o*m+u*v,n[5]=r*x+a*m+f*v,n[6]=s*x+c*m+d*v,n[8]=i*y+o*w+u*M,n[9]=r*y+a*w+f*M,n[10]=s*y+c*w+d*M,n}const z=B;var P=Object.freeze({__proto__:null,setDefaultType:function(t){const e=m;return m=t,g=v.get(t),e},create:function(t,e,n,i,r,s,o,a,c){const u=g();return u[3]=0,u[7]=0,u[11]=0,void 0!==t&&(u[0]=t,void 0!==e&&(u[1]=e,void 0!==n&&(u[2]=n,void 0!==i&&(u[4]=i,void 0!==r&&(u[5]=r,void 0!==s&&(u[6]=s,void 0!==o&&(u[8]=o,void 0!==a&&(u[9]=a,void 0!==c&&(u[10]=c))))))))),u},set:function(t,e,n,i,r,s,o,a,c,u){return(u=u||g())[0]=t,u[1]=e,u[2]=n,u[3]=0,u[4]=i,u[5]=r,u[6]=s,u[7]=0,u[8]=o,u[9]=a,u[10]=c,u[11]=0,u},fromMat4:function(t,e){return(e=e||g())[0]=t[0],e[1]=t[1],e[2]=t[2],e[3]=0,e[4]=t[4],e[5]=t[5],e[6]=t[6],e[7]=0,e[8]=t[8],e[9]=t[9],e[10]=t[10],e[11]=0,e},fromQuat:function(t,e){e=e||g();const n=t[0],i=t[1],r=t[2],s=t[3],o=n+n,a=i+i,c=r+r,u=n*o,f=i*o,d=i*a,l=r*o,h=r*a,p=r*c,x=s*o,m=s*a,v=s*c;return e[0]=1-d-p,e[1]=f+v,e[2]=l-m,e[3]=0,e[4]=f-v,e[5]=1-u-p,e[6]=h+x,e[7]=0,e[8]=l+m,e[9]=h-x,e[10]=1-u-d,e[11]=0,e},negate:function(t,e){return(e=e||g())[0]=-t[0],e[1]=-t[1],e[2]=-t[2],e[4]=-t[4],e[5]=-t[5],e[6]=-t[6],e[8]=-t[8],e[9]=-t[9],e[10]=-t[10],e},copy:y,clone:w,equalsApproximately:function(t,e){return Math.abs(t[0]-e[0])<h&&Math.abs(t[1]-e[1])<h&&Math.abs(t[2]-e[2])<h&&Math.abs(t[4]-e[4])<h&&Math.abs(t[5]-e[5])<h&&Math.abs(t[6]-e[6])<h&&Math.abs(t[8]-e[8])<h&&Math.abs(t[9]-e[9])<h&&Math.abs(t[10]-e[10])<h},equals:function(t,e){return t[0]===e[0]&&t[1]===e[1]&&t[2]===e[2]&&t[4]===e[4]&&t[5]===e[5]&&t[6]===e[6]&&t[8]===e[8]&&t[9]===e[9]&&t[10]===e[10]},identity:M,transpose:function(t,e){if((e=e||g())===t){let n;return n=t[1],t[1]=t[4],t[4]=n,n=t[2],t[2]=t[8],t[8]=n,n=t[6],t[6]=t[9],t[9]=n,e}const n=t[0],i=t[1],r=t[2],s=t[4],o=t[5],a=t[6],c=t[8],u=t[9],f=t[10];return e[0]=n,e[1]=s,e[2]=c,e[4]=i,e[5]=o,e[6]=u,e[8]=r,e[9]=a,e[10]=f,e},inverse:_,determinant:function(t){const e=t[0],n=t[1],i=t[2],r=t[4],s=t[5],o=t[6],a=t[8],c=t[9],u=t[10];return e*(s*u-c*o)-r*(n*u-c*i)+a*(n*o-s*i)},invert:b,multiply:B,mul:z,setTranslation:function(t,e,n){return t!==(n=n||M())&&(n[0]=t[0],n[1]=t[1],n[2]=t[2],n[4]=t[4],n[5]=t[5],n[6]=t[6]),n[8]=e[0],n[9]=e[1],n[10]=1,n},getTranslation:function(t,e){return(e=e||x())[0]=t[8],e[1]=t[9],e},getAxis:function(t,e,n){const i=4*e;return(n=n||x())[0]=t[i+0],n[1]=t[i+1],n},setAxis:function(t,e,n,i){i!==t&&(i=y(t,i));const r=4*n;return i[r+0]=e[0],i[r+1]=e[1],i},getScaling:function(t,e){e=e||x();const n=t[0],i=t[1],r=t[4],s=t[5];return e[0]=Math.sqrt(n*n+i*i),e[1]=Math.sqrt(r*r+s*s),e},translation:function(t,e){return(e=e||g())[0]=1,e[1]=0,e[2]=0,e[4]=0,e[5]=1,e[6]=0,e[8]=t[0],e[9]=t[1],e[10]=1,e},translate:function(t,e,n){n=n||g();const i=e[0],r=e[1],s=t[0],o=t[1],a=t[2],c=t[4],u=t[5],f=t[6],d=t[8],l=t[9],h=t[10];return t!==n&&(n[0]=s,n[1]=o,n[2]=a,n[4]=c,n[5]=u,n[6]=f),n[8]=s*i+c*r+d,n[9]=o*i+u*r+l,n[10]=a*i+f*r+h,n},rotation:function(t,e){e=e||g();const n=Math.cos(t),i=Math.sin(t);return e[0]=n,e[1]=i,e[2]=0,e[4]=-i,e[5]=n,e[6]=0,e[8]=0,e[9]=0,e[10]=1,e},rotate:function(t,e,n){n=n||g();const i=t[0],r=t[1],s=t[2],o=t[4],a=t[5],c=t[6],u=Math.cos(e),f=Math.sin(e);return n[0]=u*i+f*o,n[1]=u*r+f*a,n[2]=u*s+f*c,n[4]=u*o-f*i,n[5]=u*a-f*r,n[6]=u*c-f*s,t!==n&&(n[8]=t[8],n[9]=t[9],n[10]=t[10]),n},scaling:function(t,e){return(e=e||g())[0]=t[0],e[1]=0,e[2]=0,e[4]=0,e[5]=t[1],e[6]=0,e[8]=0,e[9]=0,e[10]=1,e},scale:function(t,e,n){n=n||g();const i=e[0],r=e[1];return n[0]=i*t[0],n[1]=i*t[1],n[2]=i*t[2],n[4]=r*t[4],n[5]=r*t[5],n[6]=r*t[6],t!==n&&(n[8]=t[8],n[9]=t[9],n[10]=t[10]),n},uniformScaling:function(t,e){return(e=e||g())[0]=t,e[1]=0,e[2]=0,e[4]=0,e[5]=t,e[6]=0,e[8]=0,e[9]=0,e[10]=1,e},uniformScale:function(t,e,n){return(n=n||g())[0]=e*t[0],n[1]=e*t[1],n[2]=e*t[2],n[4]=e*t[4],n[5]=e*t[5],n[6]=e*t[6],t!==n&&(n[8]=t[8],n[9]=t[9],n[10]=t[10]),n}});let S=Float32Array;function C(t,e,n){const i=new S(3);return void 0!==t&&(i[0]=t,void 0!==e&&(i[1]=e,void 0!==n&&(i[2]=n))),i}const j=C;function U(t,e,n){return(n=n||new S(3))[0]=t[0]-e[0],n[1]=t[1]-e[1],n[2]=t[2]-e[2],n}const A=U;function E(t,e,n){return(n=n||new S(3))[0]=t[0]*e,n[1]=t[1]*e,n[2]=t[2]*e,n}const I=E;function k(t,e){return(e=e||new S(3))[0]=1/t[0],e[1]=1/t[1],e[2]=1/t[2],e}const T=k;function G(t,e,n){n=n||new S(3);const i=t[2]*e[0]-t[0]*e[2],r=t[0]*e[1]-t[1]*e[0];return n[0]=t[1]*e[2]-t[2]*e[1],n[1]=i,n[2]=r,n}function D(t,e){return t[0]*e[0]+t[1]*e[1]+t[2]*e[2]}function L(t){const e=t[0],n=t[1],i=t[2];return Math.sqrt(e*e+n*n+i*i)}const q=L;function R(t){const e=t[0],n=t[1],i=t[2];return e*e+n*n+i*i}const H=R;function $(t,e){const n=t[0]-e[0],i=t[1]-e[1],r=t[2]-e[2];return Math.sqrt(n*n+i*i+r*r)}const F=$;function Y(t,e){const n=t[0]-e[0],i=t[1]-e[1],r=t[2]-e[2];return n*n+i*i+r*r}const O=Y;function X(t,e){e=e||new S(3);const n=t[0],i=t[1],r=t[2],s=Math.sqrt(n*n+i*i+r*r);return s>1e-5?(e[0]=n/s,e[1]=i/s,e[2]=r/s):(e[0]=0,e[1]=0,e[2]=0),e}function V(t,e){return(e=e||new S(3))[0]=t[0],e[1]=t[1],e[2]=t[2],e}const W=V;function Z(t,e,n){return(n=n||new S(3))[0]=t[0]*e[0],n[1]=t[1]*e[1],n[2]=t[2]*e[2],n}const N=Z;function Q(t,e,n){return(n=n||new S(3))[0]=t[0]/e[0],n[1]=t[1]/e[1],n[2]=t[2]/e[2],n}const J=Q;var K=Object.freeze({__proto__:null,create:C,setDefaultType:function(t){const e=S;return S=t,e},fromValues:j,set:function(t,e,n,i){return(i=i||new S(3))[0]=t,i[1]=e,i[2]=n,i},ceil:function(t,e){return(e=e||new S(3))[0]=Math.ceil(t[0]),e[1]=Math.ceil(t[1]),e[2]=Math.ceil(t[2]),e},floor:function(t,e){return(e=e||new S(3))[0]=Math.floor(t[0]),e[1]=Math.floor(t[1]),e[2]=Math.floor(t[2]),e},round:function(t,e){return(e=e||new S(3))[0]=Math.round(t[0]),e[1]=Math.round(t[1]),e[2]=Math.round(t[2]),e},clamp:function(t,e=0,n=1,i){return(i=i||new S(3))[0]=Math.min(n,Math.max(e,t[0])),i[1]=Math.min(n,Math.max(e,t[1])),i[2]=Math.min(n,Math.max(e,t[2])),i},add:function(t,e,n){return(n=n||new S(3))[0]=t[0]+e[0],n[1]=t[1]+e[1],n[2]=t[2]+e[2],n},addScaled:function(t,e,n,i){return(i=i||new S(3))[0]=t[0]+e[0]*n,i[1]=t[1]+e[1]*n,i[2]=t[2]+e[2]*n,i},angle:function(t,e){const n=t[0],i=t[1],r=t[2],s=t[0],o=t[1],a=t[2],c=Math.sqrt(n*n+i*i+r*r)*Math.sqrt(s*s+o*o+a*a),u=c&&D(t,e)/c;return Math.acos(u)},subtract:U,sub:A,equalsApproximately:function(t,e){return Math.abs(t[0]-e[0])<h&&Math.abs(t[1]-e[1])<h&&Math.abs(t[2]-e[2])<h},equals:function(t,e){return t[0]===e[0]&&t[1]===e[1]&&t[2]===e[2]},lerp:function(t,e,n,i){return(i=i||new S(3))[0]=t[0]+n*(e[0]-t[0]),i[1]=t[1]+n*(e[1]-t[1]),i[2]=t[2]+n*(e[2]-t[2]),i},lerpV:function(t,e,n,i){return(i=i||new S(3))[0]=t[0]+n[0]*(e[0]-t[0]),i[1]=t[1]+n[1]*(e[1]-t[1]),i[2]=t[2]+n[2]*(e[2]-t[2]),i},max:function(t,e,n){return(n=n||new S(3))[0]=Math.max(t[0],e[0]),n[1]=Math.max(t[1],e[1]),n[2]=Math.max(t[2],e[2]),n},min:function(t,e,n){return(n=n||new S(3))[0]=Math.min(t[0],e[0]),n[1]=Math.min(t[1],e[1]),n[2]=Math.min(t[2],e[2]),n},mulScalar:E,scale:I,divScalar:function(t,e,n){return(n=n||new S(3))[0]=t[0]/e,n[1]=t[1]/e,n[2]=t[2]/e,n},inverse:k,invert:T,cross:G,dot:D,length:L,len:q,lengthSq:R,lenSq:H,distance:$,dist:F,distanceSq:Y,distSq:O,normalize:X,negate:function(t,e){return(e=e||new S(3))[0]=-t[0],e[1]=-t[1],e[2]=-t[2],e},copy:V,clone:W,multiply:Z,mul:N,divide:Q,div:J,random:function(t=1,e){e=e||new S(3);const n=2*Math.random()*Math.PI,i=2*Math.random()-1,r=Math.sqrt(1-i*i)*t;return e[0]=Math.cos(n)*r,e[1]=Math.sin(n)*r,e[2]=i*t,e},zero:function(t){return(t=t||new S(3))[0]=0,t[1]=0,t[2]=0,t},transformMat4:function(t,e,n){n=n||new S(3);const i=t[0],r=t[1],s=t[2],o=e[3]*i+e[7]*r+e[11]*s+e[15]||1;return n[0]=(e[0]*i+e[4]*r+e[8]*s+e[12])/o,n[1]=(e[1]*i+e[5]*r+e[9]*s+e[13])/o,n[2]=(e[2]*i+e[6]*r+e[10]*s+e[14])/o,n},transformMat4Upper3x3:function(t,e,n){n=n||new S(3);const i=t[0],r=t[1],s=t[2];return n[0]=i*e[0]+r*e[4]+s*e[8],n[1]=i*e[1]+r*e[5]+s*e[9],n[2]=i*e[2]+r*e[6]+s*e[10],n},transformMat3:function(t,e,n){n=n||new S(3);const i=t[0],r=t[1],s=t[2];return n[0]=i*e[0]+r*e[4]+s*e[8],n[1]=i*e[1]+r*e[5]+s*e[9],n[2]=i*e[2]+r*e[6]+s*e[10],n},transformQuat:function(t,e,n){n=n||new S(3);const i=e[0],r=e[1],s=e[2],o=2*e[3],a=t[0],c=t[1],u=t[2],f=r*u-s*c,d=s*a-i*u,l=i*c-r*a;return n[0]=a+f*o+2*(r*l-s*d),n[1]=c+d*o+2*(s*f-i*l),n[2]=u+l*o+2*(i*d-r*f),n},getTranslation:function(t,e){return(e=e||new S(3))[0]=t[12],e[1]=t[13],e[2]=t[14],e},getAxis:function(t,e,n){const i=4*e;return(n=n||new S(3))[0]=t[i+0],n[1]=t[i+1],n[2]=t[i+2],n},getScaling:function(t,e){e=e||new S(3);const n=t[0],i=t[1],r=t[2],s=t[4],o=t[5],a=t[6],c=t[8],u=t[9],f=t[10];return e[0]=Math.sqrt(n*n+i*i+r*r),e[1]=Math.sqrt(s*s+o*o+a*a),e[2]=Math.sqrt(c*c+u*u+f*f),e}});let tt=Float32Array;function et(t,e){return(e=e||new tt(16))[0]=t[0],e[1]=t[1],e[2]=t[2],e[3]=t[3],e[4]=t[4],e[5]=t[5],e[6]=t[6],e[7]=t[7],e[8]=t[8],e[9]=t[9],e[10]=t[10],e[11]=t[11],e[12]=t[12],e[13]=t[13],e[14]=t[14],e[15]=t[15],e}const nt=et;function it(t){return(t=t||new tt(16))[0]=1,t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=1,t[6]=0,t[7]=0,t[8]=0,t[9]=0,t[10]=1,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,t}function rt(t,e){e=e||new tt(16);const n=t[0],i=t[1],r=t[2],s=t[3],o=t[4],a=t[5],c=t[6],u=t[7],f=t[8],d=t[9],l=t[10],h=t[11],p=t[12],x=t[13],m=t[14],v=t[15],g=l*v,y=m*h,w=c*v,M=m*u,_=c*h,b=l*u,B=r*v,z=m*s,P=r*h,S=l*s,C=r*u,j=c*s,U=f*x,A=p*d,E=o*x,I=p*a,k=o*d,T=f*a,G=n*x,D=p*i,L=n*d,q=f*i,R=n*a,H=o*i,$=g*a+M*d+_*x-(y*a+w*d+b*x),F=y*i+B*d+S*x-(g*i+z*d+P*x),Y=w*i+z*a+C*x-(M*i+B*a+j*x),O=b*i+P*a+j*d-(_*i+S*a+C*d),X=1/(n*$+o*F+f*Y+p*O);return e[0]=X*$,e[1]=X*F,e[2]=X*Y,e[3]=X*O,e[4]=X*(y*o+w*f+b*p-(g*o+M*f+_*p)),e[5]=X*(g*n+z*f+P*p-(y*n+B*f+S*p)),e[6]=X*(M*n+B*o+j*p-(w*n+z*o+C*p)),e[7]=X*(_*n+S*o+C*f-(b*n+P*o+j*f)),e[8]=X*(U*u+I*h+k*v-(A*u+E*h+T*v)),e[9]=X*(A*s+G*h+q*v-(U*s+D*h+L*v)),e[10]=X*(E*s+D*u+R*v-(I*s+G*u+H*v)),e[11]=X*(T*s+L*u+H*h-(k*s+q*u+R*h)),e[12]=X*(E*l+T*m+A*c-(k*m+U*c+I*l)),e[13]=X*(L*m+U*r+D*l-(G*l+q*m+A*r)),e[14]=X*(G*c+H*m+I*r-(R*m+E*r+D*c)),e[15]=X*(R*l+k*r+q*c-(L*c+H*l+T*r)),e}const st=rt;function ot(t,e,n){n=n||new tt(16);const i=t[0],r=t[1],s=t[2],o=t[3],a=t[4],c=t[5],u=t[6],f=t[7],d=t[8],l=t[9],h=t[10],p=t[11],x=t[12],m=t[13],v=t[14],g=t[15],y=e[0],w=e[1],M=e[2],_=e[3],b=e[4],B=e[5],z=e[6],P=e[7],S=e[8],C=e[9],j=e[10],U=e[11],A=e[12],E=e[13],I=e[14],k=e[15];return n[0]=i*y+a*w+d*M+x*_,n[1]=r*y+c*w+l*M+m*_,n[2]=s*y+u*w+h*M+v*_,n[3]=o*y+f*w+p*M+g*_,n[4]=i*b+a*B+d*z+x*P,n[5]=r*b+c*B+l*z+m*P,n[6]=s*b+u*B+h*z+v*P,n[7]=o*b+f*B+p*z+g*P,n[8]=i*S+a*C+d*j+x*U,n[9]=r*S+c*C+l*j+m*U,n[10]=s*S+u*C+h*j+v*U,n[11]=o*S+f*C+p*j+g*U,n[12]=i*A+a*E+d*I+x*k,n[13]=r*A+c*E+l*I+m*k,n[14]=s*A+u*E+h*I+v*k,n[15]=o*A+f*E+p*I+g*k,n}const at=ot;let ct,ut,ft;function dt(t,e,n){n=n||new tt(16);let i=t[0],r=t[1],s=t[2];const o=Math.sqrt(i*i+r*r+s*s);i/=o,r/=o,s/=o;const a=i*i,c=r*r,u=s*s,f=Math.cos(e),d=Math.sin(e),l=1-f;return n[0]=a+(1-a)*f,n[1]=i*r*l+s*d,n[2]=i*s*l-r*d,n[3]=0,n[4]=i*r*l-s*d,n[5]=c+(1-c)*f,n[6]=r*s*l+i*d,n[7]=0,n[8]=i*s*l+r*d,n[9]=r*s*l-i*d,n[10]=u+(1-u)*f,n[11]=0,n[12]=0,n[13]=0,n[14]=0,n[15]=1,n}const lt=dt;function ht(t,e,n,i){i=i||new tt(16);let r=e[0],s=e[1],o=e[2];const a=Math.sqrt(r*r+s*s+o*o);r/=a,s/=a,o/=a;const c=r*r,u=s*s,f=o*o,d=Math.cos(n),l=Math.sin(n),h=1-d,p=c+(1-c)*d,x=r*s*h+o*l,m=r*o*h-s*l,v=r*s*h-o*l,g=u+(1-u)*d,y=s*o*h+r*l,w=r*o*h+s*l,M=s*o*h-r*l,_=f+(1-f)*d,b=t[0],B=t[1],z=t[2],P=t[3],S=t[4],C=t[5],j=t[6],U=t[7],A=t[8],E=t[9],I=t[10],k=t[11];return i[0]=p*b+x*S+m*A,i[1]=p*B+x*C+m*E,i[2]=p*z+x*j+m*I,i[3]=p*P+x*U+m*k,i[4]=v*b+g*S+y*A,i[5]=v*B+g*C+y*E,i[6]=v*z+g*j+y*I,i[7]=v*P+g*U+y*k,i[8]=w*b+M*S+_*A,i[9]=w*B+M*C+_*E,i[10]=w*z+M*j+_*I,i[11]=w*P+M*U+_*k,t!==i&&(i[12]=t[12],i[13]=t[13],i[14]=t[14],i[15]=t[15]),i}const pt=ht;var xt=Object.freeze({__proto__:null,setDefaultType:function(t){const e=tt;return tt=t,e},create:function(t,e,n,i,r,s,o,a,c,u,f,d,l,h,p,x){const m=new tt(16);return void 0!==t&&(m[0]=t,void 0!==e&&(m[1]=e,void 0!==n&&(m[2]=n,void 0!==i&&(m[3]=i,void 0!==r&&(m[4]=r,void 0!==s&&(m[5]=s,void 0!==o&&(m[6]=o,void 0!==a&&(m[7]=a,void 0!==c&&(m[8]=c,void 0!==u&&(m[9]=u,void 0!==f&&(m[10]=f,void 0!==d&&(m[11]=d,void 0!==l&&(m[12]=l,void 0!==h&&(m[13]=h,void 0!==p&&(m[14]=p,void 0!==x&&(m[15]=x)))))))))))))))),m},set:function(t,e,n,i,r,s,o,a,c,u,f,d,l,h,p,x,m){return(m=m||new tt(16))[0]=t,m[1]=e,m[2]=n,m[3]=i,m[4]=r,m[5]=s,m[6]=o,m[7]=a,m[8]=c,m[9]=u,m[10]=f,m[11]=d,m[12]=l,m[13]=h,m[14]=p,m[15]=x,m},fromMat3:function(t,e){return(e=e||new tt(16))[0]=t[0],e[1]=t[1],e[2]=t[2],e[3]=0,e[4]=t[4],e[5]=t[5],e[6]=t[6],e[7]=0,e[8]=t[8],e[9]=t[9],e[10]=t[10],e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,e},fromQuat:function(t,e){e=e||new tt(16);const n=t[0],i=t[1],r=t[2],s=t[3],o=n+n,a=i+i,c=r+r,u=n*o,f=i*o,d=i*a,l=r*o,h=r*a,p=r*c,x=s*o,m=s*a,v=s*c;return e[0]=1-d-p,e[1]=f+v,e[2]=l-m,e[3]=0,e[4]=f-v,e[5]=1-u-p,e[6]=h+x,e[7]=0,e[8]=l+m,e[9]=h-x,e[10]=1-u-d,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,e},negate:function(t,e){return(e=e||new tt(16))[0]=-t[0],e[1]=-t[1],e[2]=-t[2],e[3]=-t[3],e[4]=-t[4],e[5]=-t[5],e[6]=-t[6],e[7]=-t[7],e[8]=-t[8],e[9]=-t[9],e[10]=-t[10],e[11]=-t[11],e[12]=-t[12],e[13]=-t[13],e[14]=-t[14],e[15]=-t[15],e},copy:et,clone:nt,equalsApproximately:function(t,e){return Math.abs(t[0]-e[0])<h&&Math.abs(t[1]-e[1])<h&&Math.abs(t[2]-e[2])<h&&Math.abs(t[3]-e[3])<h&&Math.abs(t[4]-e[4])<h&&Math.abs(t[5]-e[5])<h&&Math.abs(t[6]-e[6])<h&&Math.abs(t[7]-e[7])<h&&Math.abs(t[8]-e[8])<h&&Math.abs(t[9]-e[9])<h&&Math.abs(t[10]-e[10])<h&&Math.abs(t[11]-e[11])<h&&Math.abs(t[12]-e[12])<h&&Math.abs(t[13]-e[13])<h&&Math.abs(t[14]-e[14])<h&&Math.abs(t[15]-e[15])<h},equals:function(t,e){return t[0]===e[0]&&t[1]===e[1]&&t[2]===e[2]&&t[3]===e[3]&&t[4]===e[4]&&t[5]===e[5]&&t[6]===e[6]&&t[7]===e[7]&&t[8]===e[8]&&t[9]===e[9]&&t[10]===e[10]&&t[11]===e[11]&&t[12]===e[12]&&t[13]===e[13]&&t[14]===e[14]&&t[15]===e[15]},identity:it,transpose:function(t,e){if((e=e||new tt(16))===t){let n;return n=t[1],t[1]=t[4],t[4]=n,n=t[2],t[2]=t[8],t[8]=n,n=t[3],t[3]=t[12],t[12]=n,n=t[6],t[6]=t[9],t[9]=n,n=t[7],t[7]=t[13],t[13]=n,n=t[11],t[11]=t[14],t[14]=n,e}const n=t[0],i=t[1],r=t[2],s=t[3],o=t[4],a=t[5],c=t[6],u=t[7],f=t[8],d=t[9],l=t[10],h=t[11],p=t[12],x=t[13],m=t[14],v=t[15];return e[0]=n,e[1]=o,e[2]=f,e[3]=p,e[4]=i,e[5]=a,e[6]=d,e[7]=x,e[8]=r,e[9]=c,e[10]=l,e[11]=m,e[12]=s,e[13]=u,e[14]=h,e[15]=v,e},inverse:rt,determinant:function(t){const e=t[0],n=t[1],i=t[2],r=t[3],s=t[4],o=t[5],a=t[6],c=t[7],u=t[8],f=t[9],d=t[10],l=t[11],h=t[12],p=t[13],x=t[14],m=t[15],v=d*m,g=x*l,y=a*m,w=x*c,M=a*l,_=d*c,b=i*m,B=x*r,z=i*l,P=d*r,S=i*c,C=a*r;return e*(v*o+w*f+M*p-(g*o+y*f+_*p))+s*(g*n+b*f+P*p-(v*n+B*f+z*p))+u*(y*n+B*o+S*p-(w*n+b*o+C*p))+h*(_*n+z*o+C*f-(M*n+P*o+S*f))},invert:st,multiply:ot,mul:at,setTranslation:function(t,e,n){return t!==(n=n||it())&&(n[0]=t[0],n[1]=t[1],n[2]=t[2],n[3]=t[3],n[4]=t[4],n[5]=t[5],n[6]=t[6],n[7]=t[7],n[8]=t[8],n[9]=t[9],n[10]=t[10],n[11]=t[11]),n[12]=e[0],n[13]=e[1],n[14]=e[2],n[15]=1,n},getTranslation:function(t,e){return(e=e||C())[0]=t[12],e[1]=t[13],e[2]=t[14],e},getAxis:function(t,e,n){const i=4*e;return(n=n||C())[0]=t[i+0],n[1]=t[i+1],n[2]=t[i+2],n},setAxis:function(t,e,n,i){i!==t&&(i=et(t,i));const r=4*n;return i[r+0]=e[0],i[r+1]=e[1],i[r+2]=e[2],i},getScaling:function(t,e){e=e||C();const n=t[0],i=t[1],r=t[2],s=t[4],o=t[5],a=t[6],c=t[8],u=t[9],f=t[10];return e[0]=Math.sqrt(n*n+i*i+r*r),e[1]=Math.sqrt(s*s+o*o+a*a),e[2]=Math.sqrt(c*c+u*u+f*f),e},perspective:function(t,e,n,i,r){r=r||new tt(16);const s=Math.tan(.5*Math.PI-.5*t);if(r[0]=s/e,r[1]=0,r[2]=0,r[3]=0,r[4]=0,r[5]=s,r[6]=0,r[7]=0,r[8]=0,r[9]=0,r[11]=-1,r[12]=0,r[13]=0,r[15]=0,i===1/0)r[10]=-1,r[14]=-n;else{const t=1/(n-i);r[10]=i*t,r[14]=i*n*t}return r},ortho:function(t,e,n,i,r,s,o){return(o=o||new tt(16))[0]=2/(e-t),o[1]=0,o[2]=0,o[3]=0,o[4]=0,o[5]=2/(i-n),o[6]=0,o[7]=0,o[8]=0,o[9]=0,o[10]=1/(r-s),o[11]=0,o[12]=(e+t)/(t-e),o[13]=(i+n)/(n-i),o[14]=r/(r-s),o[15]=1,o},frustum:function(t,e,n,i,r,s,o){const a=e-t,c=i-n,u=r-s;return(o=o||new tt(16))[0]=2*r/a,o[1]=0,o[2]=0,o[3]=0,o[4]=0,o[5]=2*r/c,o[6]=0,o[7]=0,o[8]=(t+e)/a,o[9]=(i+n)/c,o[10]=s/u,o[11]=-1,o[12]=0,o[13]=0,o[14]=r*s/u,o[15]=0,o},aim:function(t,e,n,i){return i=i||new tt(16),ct=ct||C(),ut=ut||C(),ft=ft||C(),X(U(e,t,ft),ft),X(G(n,ft,ct),ct),X(G(ft,ct,ut),ut),i[0]=ct[0],i[1]=ct[1],i[2]=ct[2],i[3]=0,i[4]=ut[0],i[5]=ut[1],i[6]=ut[2],i[7]=0,i[8]=ft[0],i[9]=ft[1],i[10]=ft[2],i[11]=0,i[12]=t[0],i[13]=t[1],i[14]=t[2],i[15]=1,i},cameraAim:function(t,e,n,i){return i=i||new tt(16),ct=ct||C(),ut=ut||C(),ft=ft||C(),X(U(t,e,ft),ft),X(G(n,ft,ct),ct),X(G(ft,ct,ut),ut),i[0]=ct[0],i[1]=ct[1],i[2]=ct[2],i[3]=0,i[4]=ut[0],i[5]=ut[1],i[6]=ut[2],i[7]=0,i[8]=ft[0],i[9]=ft[1],i[10]=ft[2],i[11]=0,i[12]=t[0],i[13]=t[1],i[14]=t[2],i[15]=1,i},lookAt:function(t,e,n,i){return i=i||new tt(16),ct=ct||C(),ut=ut||C(),ft=ft||C(),X(U(t,e,ft),ft),X(G(n,ft,ct),ct),X(G(ft,ct,ut),ut),i[0]=ct[0],i[1]=ut[0],i[2]=ft[0],i[3]=0,i[4]=ct[1],i[5]=ut[1],i[6]=ft[1],i[7]=0,i[8]=ct[2],i[9]=ut[2],i[10]=ft[2],i[11]=0,i[12]=-(ct[0]*t[0]+ct[1]*t[1]+ct[2]*t[2]),i[13]=-(ut[0]*t[0]+ut[1]*t[1]+ut[2]*t[2]),i[14]=-(ft[0]*t[0]+ft[1]*t[1]+ft[2]*t[2]),i[15]=1,i},translation:function(t,e){return(e=e||new tt(16))[0]=1,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=1,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[10]=1,e[11]=0,e[12]=t[0],e[13]=t[1],e[14]=t[2],e[15]=1,e},translate:function(t,e,n){n=n||new tt(16);const i=e[0],r=e[1],s=e[2],o=t[0],a=t[1],c=t[2],u=t[3],f=t[4],d=t[5],l=t[6],h=t[7],p=t[8],x=t[9],m=t[10],v=t[11],g=t[12],y=t[13],w=t[14],M=t[15];return t!==n&&(n[0]=o,n[1]=a,n[2]=c,n[3]=u,n[4]=f,n[5]=d,n[6]=l,n[7]=h,n[8]=p,n[9]=x,n[10]=m,n[11]=v),n[12]=o*i+f*r+p*s+g,n[13]=a*i+d*r+x*s+y,n[14]=c*i+l*r+m*s+w,n[15]=u*i+h*r+v*s+M,n},rotationX:function(t,e){e=e||new tt(16);const n=Math.cos(t),i=Math.sin(t);return e[0]=1,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=n,e[6]=i,e[7]=0,e[8]=0,e[9]=-i,e[10]=n,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,e},rotateX:function(t,e,n){n=n||new tt(16);const i=t[4],r=t[5],s=t[6],o=t[7],a=t[8],c=t[9],u=t[10],f=t[11],d=Math.cos(e),l=Math.sin(e);return n[4]=d*i+l*a,n[5]=d*r+l*c,n[6]=d*s+l*u,n[7]=d*o+l*f,n[8]=d*a-l*i,n[9]=d*c-l*r,n[10]=d*u-l*s,n[11]=d*f-l*o,t!==n&&(n[0]=t[0],n[1]=t[1],n[2]=t[2],n[3]=t[3],n[12]=t[12],n[13]=t[13],n[14]=t[14],n[15]=t[15]),n},rotationY:function(t,e){e=e||new tt(16);const n=Math.cos(t),i=Math.sin(t);return e[0]=n,e[1]=0,e[2]=-i,e[3]=0,e[4]=0,e[5]=1,e[6]=0,e[7]=0,e[8]=i,e[9]=0,e[10]=n,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,e},rotateY:function(t,e,n){n=n||new tt(16);const i=t[0],r=t[1],s=t[2],o=t[3],a=t[8],c=t[9],u=t[10],f=t[11],d=Math.cos(e),l=Math.sin(e);return n[0]=d*i-l*a,n[1]=d*r-l*c,n[2]=d*s-l*u,n[3]=d*o-l*f,n[8]=d*a+l*i,n[9]=d*c+l*r,n[10]=d*u+l*s,n[11]=d*f+l*o,t!==n&&(n[4]=t[4],n[5]=t[5],n[6]=t[6],n[7]=t[7],n[12]=t[12],n[13]=t[13],n[14]=t[14],n[15]=t[15]),n},rotationZ:function(t,e){e=e||new tt(16);const n=Math.cos(t),i=Math.sin(t);return e[0]=n,e[1]=i,e[2]=0,e[3]=0,e[4]=-i,e[5]=n,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[10]=1,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,e},rotateZ:function(t,e,n){n=n||new tt(16);const i=t[0],r=t[1],s=t[2],o=t[3],a=t[4],c=t[5],u=t[6],f=t[7],d=Math.cos(e),l=Math.sin(e);return n[0]=d*i+l*a,n[1]=d*r+l*c,n[2]=d*s+l*u,n[3]=d*o+l*f,n[4]=d*a-l*i,n[5]=d*c-l*r,n[6]=d*u-l*s,n[7]=d*f-l*o,t!==n&&(n[8]=t[8],n[9]=t[9],n[10]=t[10],n[11]=t[11],n[12]=t[12],n[13]=t[13],n[14]=t[14],n[15]=t[15]),n},axisRotation:dt,rotation:lt,axisRotate:ht,rotate:pt,scaling:function(t,e){return(e=e||new tt(16))[0]=t[0],e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=t[1],e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[10]=t[2],e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,e},scale:function(t,e,n){n=n||new tt(16);const i=e[0],r=e[1],s=e[2];return n[0]=i*t[0],n[1]=i*t[1],n[2]=i*t[2],n[3]=i*t[3],n[4]=r*t[4],n[5]=r*t[5],n[6]=r*t[6],n[7]=r*t[7],n[8]=s*t[8],n[9]=s*t[9],n[10]=s*t[10],n[11]=s*t[11],t!==n&&(n[12]=t[12],n[13]=t[13],n[14]=t[14],n[15]=t[15]),n},uniformScaling:function(t,e){return(e=e||new tt(16))[0]=t,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=t,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[10]=t,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,e},uniformScale:function(t,e,n){return(n=n||new tt(16))[0]=e*t[0],n[1]=e*t[1],n[2]=e*t[2],n[3]=e*t[3],n[4]=e*t[4],n[5]=e*t[5],n[6]=e*t[6],n[7]=e*t[7],n[8]=e*t[8],n[9]=e*t[9],n[10]=e*t[10],n[11]=e*t[11],t!==n&&(n[12]=t[12],n[13]=t[13],n[14]=t[14],n[15]=t[15]),n}});Float32Array,Float32Array;class mt{constructor(t,e,n,i,r,s,o){this.height=t,this.width=e,this.viewMatrix=n,this.perspective=i,this.focalX=r,this.focalY=s,this.scaleModifier=o}static default(){return new mt(500,500,xt.lookAt([0,0,0],[0,0,-1],[0,1,0]),xt.perspective(Math.PI/4,1,.2,100),600,600,1)}dotZ(){const t=this.depthAxis();return e=>K.dot(t,e)}getPosition(){const t=xt.inverse(this.viewMatrix);return xt.getTranslation(t)}getProjMatrix(){var t=xt.clone(this.perspective);return t=xt.mul(t,function(t,e,n,i){const r=xt.create();return r[0]=1,r[5]=-1,r[10]=1,r[15]=1,r}()),xt.multiply(t,this.viewMatrix)}translate(t,e,n){const i=xt.inverse(this.viewMatrix);xt.translate(i,[t,e,n],i),xt.inverse(i,this.viewMatrix)}rotate(t,e,n){const i=xt.inverse(this.viewMatrix);xt.rotateX(i,e,i),xt.rotateY(i,t,i),xt.rotateZ(i,n,i),xt.inverse(i,this.viewMatrix)}depthAxis(){return xt.getAxis(xt.transpose(this.viewMatrix),2)}}class vt{constructor(t,e){this.drag=!1,this.oldX=0,this.oldY=0,this.dRX=0,this.dRY=0,this.dRZ=0,this.dTX=0,this.dTY=0,this.dTZ=0,this.dirty=!0,this.camera=t,this.canvas=e,this.createCallbacks()}static default(t){return new vt(mt.default(),t)}createCallbacks(){this.canvas.addEventListener("mousedown",(t=>{this.drag=!0,this.oldX=t.pageX,this.oldY=t.pageY,this.setDirty(),t.preventDefault()}),!1),this.canvas.addEventListener("mouseup",(t=>{this.drag=!1}),!1),this.canvas.addEventListener("mousemove",(t=>{if(!this.drag)return!1;this.dRX=2*(t.pageX-this.oldX)*Math.PI/this.canvas.width,this.dRY=2*-(t.pageY-this.oldY)*Math.PI/this.canvas.height,this.oldX=t.pageX,this.oldY=t.pageY,this.setDirty(),t.preventDefault()}),!1),this.canvas.addEventListener("wheel",(t=>{this.dTZ=.1*t.deltaY,this.setDirty(),t.preventDefault()}),!1),window.addEventListener("keydown",(t=>{const e={w:()=>{this.dTY-=.1},s:()=>{this.dTY+=.1},a:()=>{this.dTX-=.1},d:()=>{this.dTX+=.1},q:()=>{this.dTZ+=.1},e:()=>{this.dTZ-=.1},j:()=>{this.dRX+=.1},l:()=>{this.dRX-=.1},i:()=>{this.dRY+=.1},k:()=>{this.dRY-=.1},u:()=>{this.dRZ+=.1},o:()=>{this.dRZ-=.1}};e[t.key]&&(e[t.key](),this.setDirty(),t.preventDefault())}),!1)}setNewCamera(t){this.camera=t,this.setDirty()}setDirty(){this.dirty=!0}setClean(){this.dirty=!1}isDirty(){return this.dirty}getCamera(){return this.isDirty()&&(this.camera.translate(this.dTX,this.dTY,this.dTZ),this.camera.rotate(this.dRX,this.dRY,this.dRZ),this.dTX=this.dTY=this.dTZ=this.dRX=this.dRY=this.dRZ=0,this.setClean()),this.camera}}function gt(t,e){return 2*Math.atan(e/(2*t))}class yt{constructor(t,e,n){this.gpu=t,this.adapter=e,this.device=n}static create(){return t=this,e=void 0,i=function*(){const t=navigator.gpu;if(!t)return Promise.reject("WebGPU not supported on this browser! (navigator.gpu is null)");const e=yield t.requestAdapter();if(!e)return Promise.reject("WebGPU not supported on this browser! (gpu.adapter is null)");const n=yield e.requestDevice({label:"GPUDevice"});return new yt(t,e,n)},new((n=void 0)||(n=Promise))((function(r,s){function o(t){try{c(i.next(t))}catch(t){s(t)}}function a(t){try{c(i.throw(t))}catch(t){s(t)}}function c(t){var e;t.done?r(t.value):(e=t.value,e instanceof n?e:new n((function(t){t(e)}))).then(o,a)}c((i=i.apply(t,e||[])).next())}));var t,e,n,i}destroy(){this.device.destroy(),this.adapter=null,this.device=null}}function wt(t){return`\n// Uniform buffer to store j and k\nstruct Uniforms {\n    j: u32,\n    k: u32,\n};\n\n@binding(0) @group(0) var<storage, read_write> data: array<vec4f>;\n@binding(1) @group(0) var<storage, read_write> indices: array<vec4<u32>>;\n@binding(2) @group(0) var<uniform> uniforms: Uniforms;\n\n@compute @workgroup_size(128)\nfn main(@builtin(global_invocation_id) global_id: vec3<u32>) {\n    let j = uniforms.j;\n    let k = uniforms.k;\n    \n    let max = (global_id.x + 1) * ${t};\n    for (var n = global_id.x * ${t}; n < max && (max ^ j) > max; n += 4) {\n       var datan = data[n / 4];\n       var indicesn = indices[n / 4];\n       var swap = false;\n       var dataixj = vec4f(0, 0, 0, 0);\n       var indicesixj = vec4<u32>(0, 0, 0, 0);\n       var lastIxjLoadedMajorIdx: u32 = 0;\n       for (var l: u32 = 0; l < 4; l++) {\n           let i = n + l;\n           let datai = datan[l];\n           let indicesi = indicesn[l];\n\n           let ixj = i ^ j;\n           if (ixj <= i) {\n               continue;\n           }\n\n           let ixjMajor = ixj / 4;\n           let ixjMinor = ixj % 4;\n           let writeToWorkgroupBlock = (ixjMajor == n / 4);\n           if (writeToWorkgroupBlock) {\n               dataixj = datan;\n               indicesixj = indicesn;\n               lastIxjLoadedMajorIdx = 0;\n           } else if (lastIxjLoadedMajorIdx != ixjMajor) {\n               if (lastIxjLoadedMajorIdx != 0) {\n                   data[lastIxjLoadedMajorIdx] = dataixj;\n                   indices[lastIxjLoadedMajorIdx] = indicesixj;\n               } \n               dataixj = data[ixjMajor];\n               indicesixj = indices[ixjMajor];\n               lastIxjLoadedMajorIdx = ixjMajor;\n           }\n\n           let swap_pos = ((i & k) == 0 && datai > dataixj[ixjMinor]);\n           let swap_neg = ((i & k) != 0 && datai < dataixj[ixjMinor]);\n\n           if (swap_pos || swap_neg) {\n               swap = true;\n               datan[l] = dataixj[ixjMinor];\n               dataixj[ixjMinor] = datai;\n               indicesn[l] = indicesixj[ixjMinor];\n               indicesixj[ixjMinor] = indicesi;\n               if (writeToWorkgroupBlock) {\n                   datan[ixjMinor] = datai;\n                   indicesn[ixjMinor] = indicesi;\n               }\n           }\n       }\n       if (swap) {\n           data[n / 4] = datan;\n           indices[n / 4] = indicesn;\n       }\n       if (lastIxjLoadedMajorIdx != 0) {\n          data[lastIxjLoadedMajorIdx] = dataixj;\n          indices[lastIxjLoadedMajorIdx] = indicesixj;\n       }\n    }\n}\n`}class Mt{constructor(t,e){if(Math.log2(e)%1!=0)throw new Error("nElements must be a power of 2");this.context=t,this.nElements=e,this.valuesBuffer=this.context.device.createBuffer({size:4*this.nElements,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC|GPUBufferUsage.COPY_DST,mappedAtCreation:!1,label:"bitonicSorter.valuesBuffer"}),this.indicesBuffer=this.context.device.createBuffer({size:4*this.nElements,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC|GPUBufferUsage.COPY_DST,mappedAtCreation:!1,label:"bitonicSorter.indicesBuffer"}),this.initialIndexBuffer=this.context.device.createBuffer({size:4*this.nElements,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC,mappedAtCreation:!0,label:"bitonicSorter.initialIndexBuffer"});const n=new Uint32Array(this.initialIndexBuffer.getMappedRange());for(let t=0;t<this.nElements;t++)n[t]=t;this.initialIndexBuffer.unmap(),this.numThreads=8192;const i=Math.ceil(this.nElements/this.numThreads);this.pipeline=this.context.device.createComputePipeline({compute:{module:this.context.device.createShaderModule({code:wt(i)}),entryPoint:"main"},layout:"auto"}),this.createUniforms()}createUniforms(){const t=[],e=[];for(let n=2;n<=this.nElements;n<<=1)for(let i=n>>1;i>0;i>>=1){const r=new Uint32Array([i,n]),s=this.context.device.createBuffer({size:r.byteLength,usage:GPUBufferUsage.UNIFORM,mappedAtCreation:!0,label:`bitonicSorter.uniformsBuffer.k=${n}.j=${i}`});new Uint32Array(s.getMappedRange()).set(r),s.unmap();const o=this.context.device.createBindGroup({layout:this.pipeline.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:this.valuesBuffer}},{binding:1,resource:{buffer:this.indicesBuffer}},{binding:2,resource:{buffer:s}}]});t.push(s),e.push(o)}this.uniformBuffers=t,this.bindGroups=e}destroy(){this.valuesBuffer.destroy(),this.indicesBuffer.destroy(),this.initialIndexBuffer.destroy();for(const t of this.uniformBuffers)t.destroy()}argsort(t){if(t.size!=this.valuesBuffer.size)throw new Error("Input buffer size does not match the size of the sorter");const e=this.context.device.createCommandEncoder();e.clearBuffer(this.valuesBuffer),e.copyBufferToBuffer(t,0,this.valuesBuffer,0,t.size),e.copyBufferToBuffer(this.initialIndexBuffer,0,this.indicesBuffer,0,this.initialIndexBuffer.size);for(const t of this.bindGroups){const n=e.beginComputePass();n.setPipeline(this.pipeline),n.setBindGroup(0,t),n.dispatchWorkgroups(this.numThreads/128),n.end()}return this.context.device.queue.submit([e.finish()]),this.indicesBuffer}}function _t(t,e){return`\nstruct IndexVertex {\n    vec1: u32,\n    vec2: u32,\n    vec3: u32,\n    vec4: u32,\n    vec5: u32,\n    vec6: u32,\n};\n\n@group(0) @binding(0) var<storage, read> indices: array<u32>;\n@group(0) @binding(1) var<storage, read_write> indexBuffer: array<IndexVertex>;\n\nvar<private> vertex: IndexVertex;\n\n@compute @workgroup_size(64)\nfn main(@builtin(global_invocation_id) global_id: vec3<u32>) {\n    for (var i = global_id.x * ${t}; i < (global_id.x + 1) * ${t}; i++) {\n        if (i >= ${e}) {\n            break;\n        }\n        let index = indices[i];\n\n        vertex.vec1 = index * 6 + 0;\n        vertex.vec2 = index * 6 + 1;\n        vertex.vec3 = index * 6 + 2;\n        vertex.vec4 = index * 6 + 3;\n        vertex.vec5 = index * 6 + 4;\n        vertex.vec6 = index * 6 + 5;\n        indexBuffer[i] = vertex;\n    }\n}\n`}const bt=new d(i);class Bt{constructor(t,e){var n;this.context=t,this.nUnpadded=e.numGaussians,this.nPadded=(n=this.nUnpadded,Math.pow(2,Math.ceil(Math.log2(n)))),this.numThreads=2048,this.positionsBuffer=this.context.device.createBuffer({size:e.positionsArrayLayout.size,usage:GPUBufferUsage.STORAGE,mappedAtCreation:!0,label:"depthSorter.positionsBuffer"}),new Uint8Array(this.positionsBuffer.getMappedRange()).set(new Uint8Array(e.positionsBuffer)),this.positionsBuffer.unmap(),this.depthBuffer=this.context.device.createBuffer({size:4*this.nPadded,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC,label:"depthSorter.depthBuffer"}),this.projMatrixBuffer=this.context.device.createBuffer({size:bt.size,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST,label:"depthSorter.projMatrixBuffer"});const i=this.context.device.createBindGroupLayout({entries:[{binding:0,visibility:GPUShaderStage.COMPUTE,buffer:{type:"read-only-storage"}},{binding:1,visibility:GPUShaderStage.COMPUTE,buffer:{type:"storage"}},{binding:2,visibility:GPUShaderStage.COMPUTE,buffer:{type:"uniform"}}]}),r=this.context.device.createPipelineLayout({bindGroupLayouts:[i]}),s=Math.ceil(this.nPadded/this.numThreads);var o,a;this.computeDepthPipeline=this.context.device.createComputePipeline({layout:r,compute:{module:this.context.device.createShaderModule({code:(o=s,a=this.nUnpadded,`\n@group(0) @binding(0) var<storage, read> vertices: array<vec3<f32>>;\n@group(0) @binding(1) var<storage, read_write> depths: array<f32>;\n@group(0) @binding(2) var<uniform> projMatrix: mat4x4<f32>;\n\n@compute @workgroup_size(64)\nfn main(@builtin(global_invocation_id) global_id: vec3<u32>) {\n    for (var i = global_id.x * ${o}; i < (global_id.x + 1) * ${o}; i++) {\n        //if (i >= arrayLength(&vertices)) {\n        if (i >= ${a}) {\n            depths[i] = 1e20f; // pad with +inf\n        } else {\n            let pos = vertices[i];\n            let projPos = projMatrix * vec4<f32>(pos, 1.0);\n            depths[i] = projPos.z;\n        }\n    }\n}\n`)}),entryPoint:"main"}}),this.computeDepthBindGroup=this.context.device.createBindGroup({layout:i,entries:[{binding:0,resource:{buffer:this.positionsBuffer}},{binding:1,resource:{buffer:this.depthBuffer}},{binding:2,resource:{buffer:this.projMatrixBuffer}}]}),this.sorter=new Mt(this.context,this.nPadded),this.indexBuffer=this.context.device.createBuffer({size:6*this.nUnpadded*4,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC,label:"depthSorter.indexBuffer"});const c=Math.ceil(this.nUnpadded/this.numThreads);this.copyToIndexBufferPipeline=this.context.device.createComputePipeline({compute:{module:this.context.device.createShaderModule({code:_t(c,this.nUnpadded)}),entryPoint:"main"},layout:"auto"}),this.copyToIndexBufferBindGroup=this.context.device.createBindGroup({layout:this.copyToIndexBufferPipeline.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:this.sorter.indicesBuffer}},{binding:1,resource:{buffer:this.indexBuffer}}]})}destroy(){this.positionsBuffer.destroy(),this.depthBuffer.destroy(),this.projMatrixBuffer.destroy(),this.indexBuffer.destroy(),this.sorter.destroy()}sort(t){const e=new ArrayBuffer(bt.size);bt.pack(0,t,new DataView(e)),this.context.device.queue.writeBuffer(this.projMatrixBuffer,0,e,0,e.byteLength);{const t=this.context.device.createCommandEncoder(),e=t.beginComputePass();e.setPipeline(this.computeDepthPipeline),e.setBindGroup(0,this.computeDepthBindGroup),e.dispatchWorkgroups(this.numThreads/64),e.end(),this.context.device.queue.submit([t.finish()])}this.sorter.argsort(this.depthBuffer);{const t=this.context.device.createCommandEncoder(),e=t.beginComputePass();e.setPipeline(this.copyToIndexBufferPipeline),e.setBindGroup(0,this.copyToIndexBufferBindGroup),e.dispatchWorkgroups(this.numThreads/64),e.end(),this.context.device.queue.submit([t.finish()])}return this.indexBuffer}}var zt=function(t,e,n,i){return new(n||(n=Promise))((function(r,s){function o(t){try{c(i.next(t))}catch(t){s(t)}}function a(t){try{c(i.throw(t))}catch(t){s(t)}}function c(t){var e;t.done?r(t.value):(e=t.value,e instanceof n?e:new n((function(t){t(e)}))).then(o,a)}c((i=i.apply(t,e||[])).next())}))};const Pt=new c([["viewMatrix",new d(i)],["projMatrix",new d(i)],["cameraPosition",new o(i)],["tanHalfFovX",i],["tanHalfFovY",i],["focalX",i],["focalY",i],["scaleModifier",i]]);function St(t){return[[t[0],t[1],t[2],t[3]],[t[4],t[5],t[6],t[7]],[t[8],t[9],t[10],t[11]],[t[12],t[13],t[14],t[15]]]}class Ct{static requestContext(t){return zt(this,void 0,void 0,(function*(){const e=navigator.gpu;if(!e)return Promise.reject("WebGPU not supported on this browser! (navigator.gpu is null)");const n=yield e.requestAdapter();if(!n)return Promise.reject("WebGPU not supported on this browser! (gpu.adapter is null)");const i=t.gaussiansBuffer.byteLength,r=yield n.requestDevice({requiredLimits:{maxStorageBufferBindingSize:1.5*i,maxBufferSize:1.5*i}});return new yt(e,n,r)}))}destroy(){return zt(this,void 0,void 0,(function*(){return new Promise(((t,e)=>{this.destroyCallback=t}))}))}constructor(t,e,n,i,r){this.destroyCallback=null,this.canvas=t,this.interactiveCamera=e,this.context=i;const s=t.getContext("webgpu");if(!s)throw new Error("WebGPU context not found!");this.contextGpu=s,this.fpsCounter=r,this.lastDraw=performance.now(),this.numGaussians=n.numGaussians;const o="rgba16float";this.contextGpu.configure({device:this.context.device,format:o,alphaMode:"premultiplied"}),this.pointDataBuffer=this.context.device.createBuffer({size:n.gaussianArrayLayout.size,usage:GPUBufferUsage.STORAGE,mappedAtCreation:!0,label:"renderer.pointDataBuffer"}),new Uint8Array(this.pointDataBuffer.getMappedRange()).set(new Uint8Array(n.gaussiansBuffer)),this.pointDataBuffer.unmap(),this.uniformBuffer=this.context.device.createBuffer({size:Pt.size,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST,label:"renderer.uniformBuffer"});const a=function(t,e,n){const i={1:"\n    // spherical harmonic coefficients\n    const SH_C0 = 0.28209479177387814f;\n    const SH_C1 = 0.4886025119029199f;\n\n    fn compute_color_from_sh(position: vec3<f32>, sh: array<vec3<f32>, 4>) -> vec3<f32> {\n        let dir = normalize(position - uniforms.camera_position);\n        var result = SH_C0 * sh[0];\n\n        // if deg > 0\n        let x = dir.x;\n        let y = dir.y;\n        let z = dir.z;\n\n        result = result + SH_C1 * (-y * sh[1] + z * sh[2] - x * sh[3]);\n\n        // unconditional\n        result = result + 0.5;\n\n        return max(result, vec3<f32>(0.));\n    }\n",2:"\n    // spherical harmonic coefficients\n    const SH_C0 = 0.28209479177387814f;\n    const SH_C1 = 0.4886025119029199f;\n    const SH_C2 = array(\n        1.0925484305920792f,\n        -1.0925484305920792f,\n        0.31539156525252005f,\n        -1.0925484305920792f,\n        0.5462742152960396f\n    );\n\n    fn compute_color_from_sh(position: vec3<f32>, sh: array<vec3<f32>, 9>) -> vec3<f32> {\n        let dir = normalize(position - uniforms.camera_position);\n        var result = SH_C0 * sh[0];\n\n        // if deg > 0\n        let x = dir.x;\n        let y = dir.y;\n        let z = dir.z;\n\n        result = result + SH_C1 * (-y * sh[1] + z * sh[2] - x * sh[3]);\n\n        let xx = x * x;\n        let yy = y * y;\n        let zz = z * z;\n        let xy = x * y;\n        let xz = x * z;\n        let yz = y * z;\n\n        // if (sh_degree > 1) {\n        result = result +\n            SH_C2[0] * xy * sh[4] +\n            SH_C2[1] * yz * sh[5] +\n            SH_C2[2] * (2. * zz - xx - yy) * sh[6] +\n            SH_C2[3] * xz * sh[7] +\n            SH_C2[4] * (xx - yy) * sh[8];\n        \n        // unconditional\n        result = result + 0.5;\n\n        return max(result, vec3<f32>(0.));\n    }\n",3:"\n    // spherical harmonic coefficients\n    const SH_C0 = 0.28209479177387814f;\n    const SH_C1 = 0.4886025119029199f;\n    const SH_C2 = array(\n        1.0925484305920792f,\n        -1.0925484305920792f,\n        0.31539156525252005f,\n        -1.0925484305920792f,\n        0.5462742152960396f\n    );\n    const SH_C3 = array(\n        -0.5900435899266435f,\n        2.890611442640554f,\n        -0.4570457994644658f,\n        0.3731763325901154f,\n        -0.4570457994644658f,\n        1.445305721320277f,\n        -0.5900435899266435f\n    );\n\n    fn compute_color_from_sh(position: vec3<f32>, sh: array<vec3<f32>, 16>) -> vec3<f32> {\n        let dir = normalize(position - uniforms.camera_position);\n        var result = SH_C0 * sh[0];\n\n        // if deg > 0\n        let x = dir.x;\n        let y = dir.y;\n        let z = dir.z;\n\n        result = result + SH_C1 * (-y * sh[1] + z * sh[2] - x * sh[3]);\n\n        let xx = x * x;\n        let yy = y * y;\n        let zz = z * z;\n        let xy = x * y;\n        let xz = x * z;\n        let yz = y * z;\n\n        // if (sh_degree > 1) {\n        result = result +\n            SH_C2[0] * xy * sh[4] +\n            SH_C2[1] * yz * sh[5] +\n            SH_C2[2] * (2. * zz - xx - yy) * sh[6] +\n            SH_C2[3] * xz * sh[7] +\n            SH_C2[4] * (xx - yy) * sh[8];\n        \n        // if (sh_degree > 2) {\n        result = result +\n            SH_C3[0] * y * (3. * xx - yy) * sh[9] +\n            SH_C3[1] * xy * z * sh[10] +\n            SH_C3[2] * y * (4. * zz - xx - yy) * sh[11] +\n            SH_C3[3] * z * (2. * zz - 3. * xx - 3. * yy) * sh[12] +\n            SH_C3[4] * x * (4. * zz - xx - yy) * sh[13] +\n            SH_C3[5] * z * (xx - yy) * sh[14] +\n            SH_C3[6] * x * (xx - 3. * yy) * sh[15];\n\n        // unconditional\n        result = result + 0.5;\n\n        return max(result, vec3<f32>(0.));\n    }\n"}[e];return`\n// for some reason passing these as uniform is broken\nconst canvas_height = ${t.height};\nconst canvas_width = ${t.width};\nconst sh_degree = ${e};\nconst n_sh_coeffs = ${n};\n\nstruct PointInput {\n    @location(0) position: vec3<f32>,\n    @location(1) log_scale: vec3<f32>,\n    @location(2) rot: vec4<f32>,\n    @location(3) opacity_logit: f32,\n    sh: array<vec3<f32>, n_sh_coeffs>,\n};\n\nstruct PointOutput {\n    @builtin(position) position: vec4<f32>,\n    @location(0) color: vec3<f32>,\n    @location(1) uv: vec2<f32>,\n    @location(2) conic_and_opacity: vec4<f32>,\n};\n\nstruct Uniforms {\n    viewMatrix: mat4x4<f32>,\n    projMatrix: mat4x4<f32>,\n    camera_position: vec3<f32>,\n    tan_fovx: f32,\n    tan_fovy: f32,\n    focal_x: f32,\n    focal_y: f32,\n    scale_modifier: f32,\n};\n\n${i}\n\nfn sigmoid(x: f32) -> f32 {\n    if (x >= 0.) {\n        return 1. / (1. + exp(-x));\n    } else {\n        let z = exp(x);\n        return z / (1. + z);\n    }\n}\n\nfn compute_cov3d(log_scale: vec3<f32>, rot: vec4<f32>) -> array<f32, 6> {\n    let modifier = uniforms.scale_modifier;\n    let S = mat3x3<f32>(\n        exp(log_scale.x) * modifier, 0., 0.,\n        0., exp(log_scale.y) * modifier, 0.,\n        0., 0., exp(log_scale.z) * modifier,\n    );\n\n    let r = rot.x;\n    let x = rot.y;\n    let y = rot.z;\n    let z = rot.w;\n\n    let R = mat3x3<f32>(\n        1. - 2. * (y * y + z * z), 2. * (x * y - r * z), 2. * (x * z + r * y),\n        2. * (x * y + r * z), 1. - 2. * (x * x + z * z), 2. * (y * z - r * x),\n        2. * (x * z - r * y), 2. * (y * z + r * x), 1. - 2. * (x * x + y * y),\n    );\n\n    let M = S * R;\n    let Sigma = transpose(M) * M;\n\n    return array<f32, 6>(\n        Sigma[0][0],\n        Sigma[0][1],\n        Sigma[0][2],\n        Sigma[1][1],\n        Sigma[1][2],\n        Sigma[2][2],\n    );\n} \n\nfn ndc2pix(v: f32, size: u32) -> f32 {\n    return ((v + 1.0) * f32(size) - 1.0) * 0.5;\n}\n\nfn compute_cov2d(position: vec3<f32>, log_scale: vec3<f32>, rot: vec4<f32>) -> vec3<f32> {\n    let cov3d = compute_cov3d(log_scale, rot);\n\n    var t = uniforms.viewMatrix * vec4<f32>(position, 1.0);\n\n    let limx = 1.3 * uniforms.tan_fovx;\n    let limy = 1.3 * uniforms.tan_fovy;\n    let txtz = t.x / t.z;\n    let tytz = t.y / t.z;\n\n    t.x = min(limx, max(-limx, txtz)) * t.z;\n    t.y = min(limy, max(-limy, tytz)) * t.z;\n\n    let J = mat4x4(\n        uniforms.focal_x / t.z, 0., -(uniforms.focal_x * t.x) / (t.z * t.z), 0.,\n        0., uniforms.focal_y / t.z, -(uniforms.focal_y * t.y) / (t.z * t.z), 0.,\n        0., 0., 0., 0.,\n        0., 0., 0., 0.,\n    );\n\n    let W = transpose(uniforms.viewMatrix);\n\n    let T = W * J;\n\n    let Vrk = mat4x4(\n        cov3d[0], cov3d[1], cov3d[2], 0.,\n        cov3d[1], cov3d[3], cov3d[4], 0.,\n        cov3d[2], cov3d[4], cov3d[5], 0.,\n        0., 0., 0., 0.,\n    );\n\n    var cov = transpose(T) * transpose(Vrk) * T;\n\n    // Apply low-pass filter: every Gaussian should be at least\n    // one pixel wide/high. Discard 3rd row and column.\n    cov[0][0] += 0.3;\n    cov[1][1] += 0.3;\n\n    return vec3<f32>(cov[0][0], cov[0][1], cov[1][1]);\n}\n\n\n@binding(0) @group(0) var<uniform> uniforms: Uniforms;\n@binding(1) @group(1) var<storage, read> points: array<PointInput>;\n\nconst quadVertices = array<vec2<f32>, 6>(\n    vec2<f32>(-1.0, -1.0),\n    vec2<f32>(-1.0, 1.0),\n    vec2<f32>(1.0, -1.0),\n    vec2<f32>(1.0, 1.0),\n    vec2<f32>(-1.0, 1.0),\n    vec2<f32>(1.0, -1.0),\n);\n\n@vertex\nfn vs_points(@builtin(vertex_index) vertex_index: u32) -> PointOutput {\n    var output: PointOutput;\n    let pointIndex = vertex_index / 6u;\n    let quadIndex = vertex_index % 6u;\n    let quadOffset = quadVertices[quadIndex];\n    let point = points[pointIndex];\n\n    let cov2d = compute_cov2d(point.position, point.log_scale, point.rot);\n    let det = cov2d.x * cov2d.z - cov2d.y * cov2d.y;\n    let det_inv = 1.0 / det;\n    let conic = vec3<f32>(cov2d.z * det_inv, -cov2d.y * det_inv, cov2d.x * det_inv);\n    let mid = 0.5 * (cov2d.x + cov2d.z);\n    let lambda_1 = mid + sqrt(max(0.1, mid * mid - det));\n    let lambda_2 = mid - sqrt(max(0.1, mid * mid - det));\n    let radius_px = ceil(3. * sqrt(max(lambda_1, lambda_2)));\n    let radius_ndc = vec2<f32>(\n    radius_px / (canvas_height),\n    radius_px / (canvas_width),\n    );\n    output.conic_and_opacity = vec4<f32>(conic, sigmoid(point.opacity_logit));\n\n    var projPosition = uniforms.projMatrix * vec4<f32>(point.position, 1.0);\n    projPosition = projPosition / projPosition.w;\n    output.position = vec4<f32>(projPosition.xy + 2 * radius_ndc * quadOffset, projPosition.zw);\n    output.color = compute_color_from_sh(point.position, point.sh);\n    output.uv = radius_px * quadOffset;\n\n    return output;\n}\n\n@fragment\nfn fs_main(input: PointOutput) -> @location(0) vec4<f32> {\n    // we want the distance from the gaussian to the fragment while uv\n    // is the reverse\n    let d = -input.uv;\n    let conic = input.conic_and_opacity.xyz;\n    let power = -0.5 * (conic.x * d.x * d.x + conic.z * d.y * d.y) + conic.y * d.x * d.y;\n    let opacity = input.conic_and_opacity.w;\n\n    if (power > 0.0) {\n    discard;\n    }\n\n    let alpha = min(0.99, opacity * exp(power));\n\n    return vec4<f32>(input.color * alpha, alpha);\n}\n`}(t,n.sphericalHarmonicsDegree,n.nShCoeffs),c=this.context.device.createShaderModule({code:a});this.drawPipeline=this.context.device.createRenderPipeline({layout:"auto",vertex:{module:c,entryPoint:"vs_points"},fragment:{module:c,entryPoint:"fs_main",targets:[{format:o,blend:{color:{srcFactor:"one-minus-dst-alpha",dstFactor:"one",operation:"add"},alpha:{srcFactor:"one-minus-dst-alpha",dstFactor:"one",operation:"add"}}}]},primitive:{topology:"triangle-list",stripIndexFormat:void 0,cullMode:void 0}}),this.uniformsBindGroup=this.context.device.createBindGroup({layout:this.drawPipeline.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:this.uniformBuffer}}]}),this.pointDataBindGroup=this.context.device.createBindGroup({layout:this.drawPipeline.getBindGroupLayout(1),entries:[{binding:1,resource:{buffer:this.pointDataBuffer}}]}),this.depthSorter=new Bt(this.context,n),this.drawIndexBuffer=this.context.device.createBuffer({size:24*n.numGaussians,usage:GPUBufferUsage.INDEX|GPUBufferUsage.COPY_DST,mappedAtCreation:!1,label:"renderer.drawIndexBuffer"}),requestAnimationFrame((()=>this.animate(!0)))}destroyImpl(){if(null===this.destroyCallback)throw new Error("destroyImpl called without destroyCallback set!");this.uniformBuffer.destroy(),this.pointDataBuffer.destroy(),this.drawIndexBuffer.destroy(),this.depthSorter.destroy(),this.context.destroy(),this.destroyCallback()}draw(t){const e=this.context.device.createCommandEncoder(),n=this.depthSorter.sort(this.depthSortMatrix);e.copyBufferToBuffer(n,0,this.drawIndexBuffer,0,24*this.depthSorter.nUnpadded);const i={colorAttachments:[{view:this.contextGpu.getCurrentTexture().createView(),clearValue:{r:0,g:0,b:0,a:0},storeOp:"store",loadOp:"clear"}]},r=e.beginRenderPass(i);r.setPipeline(this.drawPipeline),r.setBindGroup(0,this.uniformsBindGroup),r.setBindGroup(1,this.pointDataBindGroup),r.setIndexBuffer(this.drawIndexBuffer,"uint32"),r.drawIndexed(6*this.numGaussians,1,0,0,0),r.end(),this.context.device.queue.submit([e.finish()]);const s=performance.now(),o=1e3/(s-this.lastDraw);this.lastDraw=s,this.fpsCounter.innerText="FPS: "+o.toFixed(2),this.fpsCounter.style.display="block",requestAnimationFrame(t)}animate(t){if(null!==this.destroyCallback)return void this.destroyImpl();if(!this.interactiveCamera.isDirty()&&!t)return void requestAnimationFrame((()=>this.animate()));const e=this.interactiveCamera.getCamera(),n=e.getPosition(),i=.5*this.canvas.width/e.focalX,r=.5*this.canvas.height/e.focalY;this.depthSortMatrix=St(e.viewMatrix);let s=new ArrayBuffer(this.uniformBuffer.size),o={viewMatrix:St(e.viewMatrix),projMatrix:St(e.getProjMatrix()),cameraPosition:Array.from(n),tanHalfFovX:i,tanHalfFovY:r,focalX:e.focalX,focalY:e.focalY,scaleModifier:e.scaleModifier};Pt.pack(0,o,new DataView(s)),this.context.device.queue.writeBuffer(this.uniformBuffer,0,s,0,s.byteLength),this.draw((()=>this.animate()))}}navigator.gpu||alert("WebGPU not supported on this browser! (navigator.gpu is null)");const jt=document.getElementById("canvas-webgpu"),Ut=document.getElementById("loading-popup"),At=document.getElementById("fps-counter"),Et=document.getElementById("cameraButton"),It=document.getElementById("cameraList"),kt=document.getElementById("plyButton");let Tt=vt.default(jt);var Gt;kt.addEventListener("change",(function(t){const e=t.target.files[0];e&&(Ut.style.display="block",function(t){return new Promise(((e,n)=>{const i=new FileReader;i.onload=t=>{t.target&&t.target.result?"string"!=typeof t.target.result?e(t.target.result):n("Got a text file instead of a binary one"):n("Failed to load file")},i.onerror=t=>{t.target?n(t.target.error):n("Failed to load file")},i.readAsArrayBuffer(t)}))}(e).then((function(t){return e=this,n=void 0,r=function*(){Gt&&(yield Gt.destroy());const e=new l(t);try{const t=yield Ct.requestContext(e),n=new Ct(jt,Tt,e,t,At);Gt=n,Ut.style.display="none"}catch(t){Ut.style.display="none",alert(t)}},new((i=void 0)||(i=Promise))((function(t,s){function o(t){try{c(r.next(t))}catch(t){s(t)}}function a(t){try{c(r.throw(t))}catch(t){s(t)}}function c(e){var n;e.done?t(e.value):(n=e.value,n instanceof i?n:new i((function(t){t(n)}))).then(o,a)}c((r=r.apply(e,n||[])).next())}));var e,n,i,r})))})),new class{constructor(t,e,n,i){this.currentLineId=0,this.handleFileInputChange=t=>{var e;const n=null===(e=this.fileInput.files)||void 0===e?void 0:e[0];if(n){const t=new FileReader;t.onload=this.handleFileLoad,t.readAsText(n)}},this.handleFileLoad=t=>{if(!t.target)return;const e=t.target.result,n=JSON.parse(e);this.currentLineId=0,this.listElement.innerHTML="",n.forEach((t=>{this.currentLineId++;const e=document.createElement("li"),n=function(t,e,n){const i=function(t,e,n,i){const r=Math.tan(i/2)*t,s=-r,o=Math.tan(n/2)*t,a=-o,c=xt.create();return c[0]=.4/(o-a),c[5]=.4/(r-s),c[8]=(o+a)/(o-a),c[9]=(r+s)/(r-s),c[10]=100/99.8,c[11]=-20/99.8,c[14]=1,c[15]=0,xt.transpose(c)}(.2,0,gt(t.fx,t.width),gt(t.fy,t.height)),r=function(t,e){const n=t,i=xt.fromMat3(n),r=K.mulScalar(e,-1);return xt.translate(i,r,i),i}(P.create(...t.rotation.flat()),t.position);return new mt(n,e,r,i,t.fx,t.fy,Math.max(e/t.width,n/t.height))}(t,this.canvas.width,this.canvas.height);e.textContent=t.img_name,e.addEventListener("click",this.createCallbackForLine(n)),this.listElement.appendChild(e)}))},this.createCallbackForLine=t=>()=>{this.cameraSetCallback(t)},this.fileInput=t,this.listElement=e,this.canvas=n,this.cameraSetCallback=i,this.fileInput.addEventListener("change",this.handleFileInputChange)}}(Et,It,jt,(t=>Tt.setNewCamera(t)))})();
//# sourceMappingURL=main.js.map